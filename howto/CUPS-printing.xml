<?xml version="1.0" encoding="ISO-8859-1"?>
<chapter id="CUPS-printing">

<chapterinfo>

	<author>
		<firstname>Kurt</firstname><surname>Pfeifle</surname>
		<affiliation>
			<orgname>Danka Deutschland GmbH </orgname>
                        <address><email>kpfeifle@danka.de</email></address>
		</affiliation>
	</author>
	<author>
		<firstname>Ciprian</firstname><surname>Vizitiu</surname>
		<affiliation>
			<address><email>CVizitiu@gbif.org</email></address>
		</affiliation>
		<contrib>drawings</contrib>
	</author>

	<author>&person.jelmer;<contrib>drawings</contrib></author>
        <author>&person.sgw;<contrib>Deutsche Übersetzung</contrib></author>
</chapterinfo>

<title>Unterstützung des CUPS-Drucksystems</title>

<sect1>

	<title>Einleitung</title>

	<sect2>
		<title>Eigenschaften und Vorzüge</title>

		<para>
		Das Common UNIX Print System (<ulink url="http://www.cups.org/">CUPS</ulink>)
		ist mittlerweile sehr populär geworden. Alle großen
		Linux Distributionen liefern dieses als das Standard-Drucksystem
		aus. Für viele ist es ein mystisches Tool.
		Meistens funktioniert es einfach. Daher wird es 
		oft als <quote>Black Box</quote> angesehen, und solange
		es funktioniert, möchte sich auch niemand damit
		befassen. Sobald aber ein kleines Problem auftritt,
		bekommt man Schwierigkeiten damit, herauszufinden, wie man mit
		der Fehlersuche beginnt. Sehr viele Informationen, welche
		auch für CUPS relevant sind, finden Sie im Kapitel
		<quote>Klassische Druckerunterstützung</quote>.
		</para>

		<para>
		CUPS bietet einige mächtige und einmalige Möglichkeiten.
		Neu ist auch die sehr einfache Handhabung der
		grundsätzlichen Funktionen. Da diese Funktionen anders
		sind als in den mehr traditionell orientierten
		Drucksystemen, wenden Sie am besten nicht ihr
		bisheriges Wissen bzgl. Drucken an.
		Versuchen Sie eher, CUPS von Grund auf zu
		vestehen. Diese Dokumentation möchte Sie zu einem
		kompletten Verständniss von CUPS führen. 
		Beginnen wir mit den grundsätzlichen Dingen.
		</para>


	</sect2>

	<sect2>
		<title>Überblick</title>

		<para>
		CUPS ist mehr als nur ein System für das Printspooling. Es ist
		ein komplettes Drucker-Management-System, welches das
		neue Internet Printing Protocol (IPP) erfüllt. IPP ist
		ein IETF- (Industry-and-Internet-Engineering Task Force) Standard für 
		das Drucken in Netzwerken. Viele seiner Funktionen können
		remote oder lokal über einen Webbrowser verwaltet 
		werden (Bereitstellung eines plattform-unabhängigen
		Zugriffs auf den CUPS-Printserver). Zusätzlich hat es die
		traditionellen Kommandozeilen-Tools und weitere moderne
		GUI-Schnittstellen. (GUI-Schnittstellen von
		Drittherstellern, wie etwa das überwältigende, in KDE
		enthaltene <ulink url="http://printing.kde.org/">KDEPrint</ulink>).
		</para>
		
		<para>
		CUPS erlaubt das Anlegen von <quote>raw</quote>-
		Druckern (keine Übersetzung der Druckdaten) genauso wie
		von <quote>smarten</quote> Druckern (Cups übersetzt das
		Dateiformat in das benötigte Druckerformat). Diese
		gibt CUPS auf vielfache Arten ähnliche Fähigkeiten wie das MS
		Windows Print Monitoring System. Sind Sie ein CUPS-
		Verfechter, dann werden Sie sicher argumentieren, daß CUPS 
		sogar besser ist! Wie auch immer, lassen Sie uns
		damit weitermachen, wie man CUPS für eine Zusammenarbeit
		mit MS Windows Druckclients über SAMBA konfigurieren kann.
		</para>

	</sect2>
</sect1>

<sect1>
	<title>Grundlegende Konfiguration für die CUPS-Unterstützung</title>

	<para>
	In Samba-3.0 (gilt auch für 2.2.x) sind für das grundlegende
	Drucken mit CUPS nur 2 Einträge nötig:
	<smbconfoption><name>printing</name><value>cups</value></smbconfoption>
	and
	<smbconfoption><name>printcap</name><value>cups</value></smbconfoption>.
	CUPS benötigt keine printcap-Datei.
	Dennoch gibt es in der Konfigurationsdatei
	<filename>cupsd.conf</filename> zwei zugehörige Einträge, die
	kontrollieren, wie diese Datei anzulegen und zu verwalten ist, damit
	Anwendungen von Drittherstellern damit umgehen können (Beispiel:
	<parameter>Printcap /etc/printcap</parameter> and
	<parameter>PrintcapFormat BSD</parameter>).
	Ältere Programme benötigen oft diese printcap-Datei mit den
	Namen der Drucker, um drucken zu können. Stellen Sie daher sicher, daß CUPS so
	konfiguriert wurde, daß diese printcap-Datei erstellt und
	gewartet wird. Für Details sehen Sie die man-Page
	<command>man cupsd.conf</command>, die CUPS-relevanten
	Dokumentationen, sowie die vielen Infos vom CUPS Server
	selbst: <ulink noescape="1" url="http://localhost:631/documentation.html">http://localhost:631/documentation.html</ulink>.
	</para>

	<sect2>
		<title>Das Verlinken von smbd mit libcups.so</title>

		<para>
		Samba hat eine spezielle Beziehung zu CUPS. Samba kann
		mit Unterstützung für die CUPS-Library übersetzt werden. Die meisten
		aktuellen Installationen haben diesen Support bereits
		per default in smbd und den anderen Samba-Binaries
		integriert. Sie können CUPS auch benutzen, wenn Samba
		nicht gegen die <filename>libcups.so</filename>
		&smbmdash; gelinkt ist, aber es gibt einige Unterschiede in
		den benötigten oder unterstützten Konfigurationen.
		</para>
		
		<para>
		Wenn Samba mit <filename>libcups</filename> kompiliert
		wurde, verwendet <smbconfoption><name>printcap</name><value>cups</value></smbconfoption>
		die CUPS-API, um Drucker aufzufinden, Jobs zu übergeben,
		Queues abzufragen usw. 
		Sonst wird dies auf die System V Druck-Kommandos mit der zusätzlichen
		<command>-oraw</command>-Option umgesetzt.
		Auf einem Linux-System können Sie mit dem
		<command>ldd</command> Utility nähere Details erfahren
		(ldd muss nicht auf allen Plattformen vorhanden sein,
		oder dessen Funktion kann in einem vergleichbarem
		Programm inkludiert sein).
		</para>


<para><screen>
&rootprompt;<userinput>ldd `which smbd`</userinput>
libssl.so.0.9.6 =&gt; /usr/lib/libssl.so.0.9.6 (0x4002d000)
libcrypto.so.0.9.6 =&gt; /usr/lib/libcrypto.so.0.9.6 (0x4005a000)
libcups.so.2 =&gt; /usr/lib/libcups.so.2 (0x40123000)
[....]
</screen></para>

		<para>
		Die Zeile 
		<computeroutput>libcups.so.2 =&gt; /usr/lib/libcups.so.2 (0x40123000)</computeroutput> 
		bedeutet, daß der CUPS-Support in Samba einkompiliert wurde.
		In diesem Fall, und bei gesetztem printing = cups,
		<emphasis>werden anderweitige manuell gesetzte print
		Kommandos in &smb.conf; ignoriert</emphasis>.
		Bitte merken Sie sich diesen wichtigen Punkt !
		</para>

		<tip><para>Sollte es aus irgendeinem Grund nötig sein,
		Ihre eigenen Druck-Kommandos zu setzen, können sie
		dies erreichen, in dem sie die Option 
		<smbconfoption><name>printing</name><value>sysv</value></smbconfoption>
		verwenden.
		Sie verlieren so jedoch die Unterstützung der engen CUPS/Samba-Integration. 
		Wenn Sie das vorhaben, müssen Sie folgende Druckkommandos manuell konfigurieren
		(am wichtigsten:	
		<smbconfoption><name>print command</name></smbconfoption>; andere Kommandos sind
		<smbconfoption><name>lppause command</name></smbconfoption>,
	        <smbconfoption><name>lpresume command</name></smbconfoption>,
                <smbconfoption><name>lpq command</name></smbconfoption>,
	        <smbconfoption><name>lprm command</name></smbconfoption>,
                <smbconfoption><name>queuepause command</name></smbconfoption> und
                <smbconfoption><name>queue resume command</name></smbconfoption>).</para></tip>
        </sect2>

	<sect2>
		<title>Einfache &smb.conf; Einstellungen für CUPS</title>

		<para>
		Als Zusammenfassung <link linkend="cups-exam-simple">
		zeigt das folgende Beispiel</link>
		ein einfaches Drucker-relevantes Setup
		für &smb.conf;, um den grundlegenden Support für CUPS zu erhalten:
		</para>


		<para><smbconfexample id="cups-exam-simple">
		<title>Einfachste Drucker-bezogene smb.conf</title>
		<smbconfsection>[global]</smbconfsection>
		<smbconfoption><name>load printers</name><value>yes</value></smbconfoption>
		<smbconfoption><name>printing</name><value>cups</value></smbconfoption>
		<smbconfoption><name>printcap name</name><value>cups</value></smbconfoption>

		<smbconfsection>[printers]</smbconfsection>
		<smbconfoption><name>comment</name><value>Alle Drucker</value></smbconfoption>
		<smbconfoption><name>path</name><value>/var/spool/samba</value></smbconfoption>
		<smbconfoption><name>browseable</name><value>no</value></smbconfoption>
		<smbconfoption><name>public</name><value>yes</value></smbconfoption>
		<smbconfoption><name>guest ok</name><value>yes</value></smbconfoption>
		<smbconfoption><name>writable</name><value>no</value></smbconfoption>
		<smbconfoption><name>printable</name><value>yes</value></smbconfoption>
		<smbconfoption><name>printer admin</name><value>root, @ntadmins</value></smbconfoption>

		</smbconfexample></para>

		<para>
		Das ist alles, was Sie an grundlegenden Einstellungen
		zum Drucken mit CUPS benötigen. Dies wird alle Grafik-,
		Text-, PDF-, und Postscript-Dateien drucken, die von Ihren Windows-Clients
		übermittelt werden. Aber die meisten Ihrer Windows-Benutzer
		würden nicht wissen, wie sie solche Dateien ohne einen
		grafischen Druckerdialog übermitteln können. Windows
		Clients haben meist lokale Druckertreiber
		installiert, welche in den Anwendungen durch den Druck-Button
		aktiviert werden. Ihre Benutzer drucken auch selten
		Dateien aus der Kommandozeile. Im Gegensatz zu Unix
		Client's senden sie kaum Grafik-, Text- oder PDF-
		formatierte Dateien direkt zum Spooler. Sie
		drucken fast ausschließlich aus GUI-Anwendungen über den
		<quote>Druckertreiber</quote>, welcher zwischen der
		nativen Ausgabe des Programms und dem Druckdatenstrom
		sitzt. Ist das Ausgabegerät kein PostScript-Drucker, so
		ist der Druckdatenstrom in einem <quote>Binärformat</quote>
		welches nur der betreffende Drucker versteht.
		Lesen Sie bitte weiter, um zu verstehen, welche Probleme
		dabei entstehen und wie Sie diese vermeiden.	
		</para>
	</sect2>

	<sect2>
	<title>Komplexere CUPS-Einstellungen in der &smb.conf;</title>
	<para>
	<link linkend="overridesettings">Die nächste Konfiguration</link> 
	beschreibt ein etwas komplexeres Drucker-Setup der &smb.conf;.
	Es aktiviert generellen CUPS-Druck-Support für alle Drucker, definiert aber einen
	Drucker, der davon abweichend konfiguriert wird.
	</para>

	<para><smbconfexample id="overridesettings">
	<title>Das Aufheben globaler CUPS-Einstellungen für einen Drucker</title>
	<smbconfsection>[global]</smbconfsection>
	<smbconfoption><name>printing</name><value>cups</value></smbconfoption>
	<smbconfoption><name>printcap name</name><value>cups</value></smbconfoption>
	<smbconfoption><name>load printers</name><value>yes</value></smbconfoption>

	<smbconfsection>[printers]</smbconfsection>
	<smbconfoption><name>comment</name><value>Alle Drucker</value></smbconfoption>
	<smbconfoption><name>path</name><value>/var/spool/samba</value></smbconfoption>
	<smbconfoption><name>public</name><value>yes</value></smbconfoption>
	<smbconfoption><name>guest ok</name><value>yes</value></smbconfoption>
	<smbconfoption><name>writable</name><value>no</value></smbconfoption>
	<smbconfoption><name>printable</name><value>yes</value></smbconfoption>
	<smbconfoption><name>printer admin</name><value>root, @ntadmins</value></smbconfoption>

	<smbconfsection>[special_printer]</smbconfsection>
	<smbconfoption><name>comment</name><value>Ein spezieller Drucker mit seinen eigenen Einstellungen</value></smbconfoption>
	<smbconfoption><name>path</name><value>/var/spool/samba-special</value></smbconfoption>
	<smbconfoption><name>printing</name><value>sysv</value></smbconfoption>
	<smbconfoption><name>printcap</name><value>lpstat</value></smbconfoption>
	<smbconfoption><name>print command</name><value>echo "NEW: `date`: printfile %f" \</value></smbconfoption>
	<member><parameter> >> /tmp/smbprn.log ; \</parameter></member>
	<member><parameter>echo "     `date`: p-%p s-%s f-%f" >> /tmp/smbprn.log ; \</parameter></member>
	<member><parameter>echo "     `date`: j-%j J-%J z-%z c-%c" >> /tmp/smbprn.log : rm %f</parameter></member>
	<smbconfoption><name>public</name><value>no</value></smbconfoption>
	<smbconfoption><name>guest ok</name><value>no</value></smbconfoption>
	<smbconfoption><name>writable</name><value>no</value></smbconfoption>
	<smbconfoption><name>printable</name><value>yes</value></smbconfoption>
	<smbconfoption><name>printer admin</name><value>kurt</value></smbconfoption>
	<smbconfoption><name>hosts deny</name><value>0.0.0.0</value></smbconfoption>
	<smbconfoption><name>hosts allow</name><value>turbo_xp, 10.160.50.23, 10.160.51.60</value></smbconfoption>
	</smbconfexample></para>

	<para>
	Diese spezielle Freigabe ist nur für Testzwecke gedacht. Sie schreibt den Druckauftrag nicht
	in eine Datei, sondern protokolliert nur die Auftrags-Parameter, die Samba bekannt sind, in die
	Datei <filename>/tmp/smbprn.log</filename> und löscht die Auftrags-Datei. Außerdem ist der
	Parameter <smbconfoption><name>printer admin</name></smbconfoption> dieser Freigabe
	<quote>kurt</quote> (nicht die Gruppe <quote>@ntadmins</quote>), Gast-Zugriff ist nicht erlaubt,
	die Freigabe wird nicht in der Netzwerkumgebung angezeigt (also müssen Sie wissen, daß es sie 
	gibt), und sie erlaubt nur den Zugriff von nur drei Hosts. Um CUPS daran zu hindern, sich
	hier einzumischen und die Druckjobs dieser Freigabe zu übernehmen, müssen wir dies setzen:
	<smbconfoption><name>printing</name><value>sysv</value></smbconfoption> und
	<smbconfoption><name>printcap</name><value>lpstat</value></smbconfoption>.
	</para>
	</sect2>
</sect1>

<sect1>
	<title>Erweiterte Konfiguration</title>

	<para>
	Bevor wir in all die Konfigurations-Optionen eintauchen, lassen Sie uns ein paar Punkte
	klären. <emphasis>Netzwerk-Druck muß organisiert und korrekt eingerichtet werden</emphasis>.
	Dies passiert meistens nicht. Bestehenden alten Systemen oder 
	LAN-Umgebungen in kleinen Firmen mangelt es oft an Design und guter Wartung.
	</para>


	<sect2>
	<title>Zentrales Spooling vs. <quote>Peer-to-Peer</quote>-Druck</title>


	<para>
<indexterm><primary>spooling</primary><secondary>central</secondary></indexterm>
<indexterm><primary>spooling</primary><secondary>peer-to-peer</secondary></indexterm>
	Viele kleine Büro- oder Heim-Netzwerke, genauso wie schlecht organisierte grössere
	Umgebungen, erlauben jedem Client direkten Zugriff auf verfügbare Netzwerkdrucker.
	Dies ist im Allgemeinen eine schlechte Idee. Es blockiert oft den Zugriff eines Clients
	auf den Drucker, wenn der Auftrag eines anderen Clients gedruckt wird. Dies könnte
	die Applikation des ersten Clients "einfrieren", während diese darauf wartet, den
	Auftrag loszuwerden. Es gibt auch immer wieder Beschwerden darüber, daß Aufträge
	gedruckt werden, deren Seiten miteinander vermischt sind. Ein besseres Konzept
	ist die Verwendung eines Druck-Servers; er routet alle Aufträge durch ein zentrales
	System, welches unverzüglich antwortet, Aufträge von mehreren verschiedenen Clients
	zur selben Zeit annimmt, und diese danach in der korrekten Reihenfolge an die Drucker
	weiterleitet.
	</para>
	</sect2>

	<sect2>
	<title>"Raw" Print Serving &smbmdash; Hersteller-Treiber auf den Windows Clients</title>


	<para>
	<indexterm><primary>spooling-only</primary></indexterm>
	<indexterm><primary>"raw" printing</primary></indexterm>
	Die meisten traditionell konfigurierten UNIX-Druck-Server, die für Samba's Windows clients
	arbeiten, zeigen ein wirklich simples Setup. Ihre einzige Aufgabe war die Verwaltung des
	<quote>raw spooling</quote> aller Jobs, die ihnen von Samba übergeben wurde. Dieser Ansatz bedeutete,
	daß von den Windows Clients erwartet wurde, daß sie die Druckauftrags-Datei so vorbereiten, daß
	diese bereit zum Versenden an das Drucker-Gerät ist. Hier muß ein nativer (vom Hersteller
	bereitgestellter) Windows Druckertreiber für das Zielgerät auf jedem einzelnen Client installiert werden.
	</para>

	<para>
	Es ist möglich, CUPS, Samba und Ihre Windows Clients in derselben traditionellen und simplen Art zu
	konfigurieren. Wenn CUPS-Drucker für RAW-print-through Betriebsart konfiguriert sind, ist es die
	Verantwortung des Samba-Clients, den Druckauftrag (die Datei) vollständig wiederzugeben. Die Datei muß in
	einem Format gesendet werden, die passend für die direkte Weitergabe an den Drucker ist. Clients müssen
	dafür die vom Hersteller bereitgestellten Treiber verwenden, CUPS wird keinerlei Format-Wandlung
	durchführen.
	</para>

	<para>
	Die einfachste mögliche Druck-Konfiguration ist die Verwendung von "raw print-through".	
	Dies wird dadurch erreicht, daß der Drucker so installiert wird, als ob er physisch an den
	Windows client angeschlossen wäre. Sie leiten dann die Ausgabe auf eine raw-Netzwerk-Druck-Warteschlange
	um. Folgender Ablauf erzielt dies:
	</para>

	<procedure>
		<step><para>
		Editieren Sie <filename>/etc/cups/mime.types</filename>, um die Zeile nahe dem Dateiende
		auszukommentieren, die dies enthält:
<screen>
#application/octet-...
</screen>
		</para></step>

		<step><para>
		Machen Sie dasselbe mit der Datei <filename>/etc/cups/mime.convs</filename>.
		</para></step>

		<step><para>
		Fügen Sie mittels Web interface einen raw-Drucker hinzu. Gehen Sie mit Ihrem Browser auf
		<constant>http://localhost:631</constant>. Klicken Sie auf Administration und fügen Sie den
		Drucker gemäß der Aufforderungen hinzu. Installieren Sie keine Treiber dafür. Wählen Sie Raw.
		Wählen Sie den Queue-Namen <constant>Raw Queue</constant>.
                </para></step>

		<step><para>
		Im Abschnitt <constant>[printers]</constant> der Datei &smb.conf; fügen Sie hinzu:
		<smbconfoption><name>use client driver</name><value>Yes</value></smbconfoption>,
		und im Abschnitt <constant>[global]</constant>:
		<smbconfoption><name>printing</name><value>CUPS</value></smbconfoption>, plus
		<smbconfoption><name>printcap</name><value>CUPS</value></smbconfoption>.
		</para></step>

		<step><para>
		Installieren Sie den Drucker, als ob er ein lokaler Drucker wäre. Z.B.:
		Drucken auf <constant>LPT1:</constant>.
                </para></step>

		<step><para>
		Editieren Sie die Konfiguration im Tab <guimenu>Detail</guimenu>, legen Sie einen
		<constant>local port</constant> an, der auf die raw-Druck-Queue zeigt, die Sie oben
		angelegt haben. Beispiel: <constant>\\server\raw_q</constant>.
		Hier ist <constant>raw_q</constant> der Name, den Sie der Drucker-Warteschlange in der
		CUPS-Umgebung gegeben haben.
		</para></step>
	</procedure>

	</sect2>

	<sect2>
	<title>Installation von Windows Client Treibern</title>

	<para>
	Die Druckertreiber auf den Windows Clients können auf zwei funktional verschiedene Arten 
	installiert werden:
	</para>

	<itemizedlist>
	<listitem><para>Manuelles Installieren der Treiber, lokal auf jedem Client, einer nach dem anderen;
	dies ergibt Drucken im alten <emphasis>LanMan</emphasis>-Stil und verwendet eine Verbindung vom Typ
	<filename>\\sambaserver\druckerfreigabe</filename>.
	</para></listitem>


	<listitem><para>
	<indexterm><primary>point 'n' print</primary></indexterm>
	Ablegen und Vorbereiten der Treiber (für den späteren Download) auf dem Druckserver (Samba); dies
	befähigt die Clients, <quote>Point'n'Print</quote> zu verwenden, um Treiber semi-automatisch
	installiert zu bekommen, wenn sie das erste Mal auf den Drucker zugreifen; bei dieser Methode verwenden
	NT/200x/XP-Clients Druckaufrufe vom Typ <emphasis>SPOOLSS/MS-RPC</emphasis>.</para></listitem>
        </itemizedlist>

	<para>
	Die zweite Methode wird zur Verwendung empfohlen.
	</para>
	</sect2>

	<sect2 id="cups-raw">
	<title>Explizites Aktivieren von <quote>raw</quote>-Druck für <emphasis>application/octet-stream</emphasis></title>


	<para>
	<indexterm><primary>application/octet-stream</primary></indexterm>
	<indexterm><primary>raw printing</primary></indexterm>
	<indexterm><primary>MIME</primary><secondary>raw</secondary></indexterm>
	Wenn Sie die erste Variante verwenden (Treiber werden auf Client-Seite installiert), ist dies eine
	Einstellung, die sie beachten müssen: CUPS muß mitgeteilt werden, daß es <quote>raw</quote>-Druck von
	Binär-Dateiformaten erlauben soll. Die CUPS-Dateien, die korrekt für RAW-Modus-Drucker gesetzt sein
	müssen, sind:	
	</para>

	<itemizedlist>
		<listitem><para><filename>/etc/cups/mime.types</filename></para></listitem>
		<listitem><para><filename>/etc/cups/mime.convs</filename></para></listitem>
	</itemizedlist>

	<para>
	Beide enthalten Einträge (am Ende der jeweiligen Datei), die auskommentiert werden müssen, um
	RAW-Modus-Betrieb zu erlauben. In <filename>/etc/cups/mime.types</filename> muß diese Zeile vorhanden
	sein:

	<filterline>
	 application/octet-stream
	</filterline>

	<indexterm><primary>/etc/cups/mime.convs</primary></indexterm>
	<indexterm><primary>/etc/cups/mime.types</primary></indexterm>

	In <filename>/etc/cups/mime.convs</filename> müssen Sie diese Zeile haben:

	<indexterm><primary>application/vnd.cups-raw</primary></indexterm>

	<filterline>
		application/octet-stream   application/vnd.cups-raw   0   - 
	</filterline>

	Wenn diese beiden Dateien nicht korrekt für RAW-Windows-CLient-Druck konfiguriert sind, kann es sein, daß
	Sie die gefürchtete Meldung <computeroutput>Unable to
        convert file 0</computeroutput> in Ihrer CUPS error_log Datei vorfinden.
	</para>

	<note><para>Das Editieren von <filename>mime.convs</filename> und
	<filename>mime.types</filename>
	<emphasis>erwingt</emphasis> den <quote>raw</quote>-Druck nicht, es
	<emphasis>erlaubt</emphasis> ihn nur.
	</para></note>

	<formalpara><title>Hintergrund</title>


	<para>
	<indexterm><primary>application/octet-stream</primary></indexterm>
	Da CUPS ein mehr sicherheitsbewußtes Drucksystem ist als die traditionellen Systeme, erlaubt es
	in der Voreinstellung nicht, daß ein Benutzer beliebige (möglicherweise binäre) Daten an
	Druck-Geräte sendet. Dies könnte leicht dazu benutzt werden, um einen
	<quote>Denial of Service</quote>-Angriff auf Ihre(n) Drucker zu starten, was zumindest den Verlust von
	einer Menge Papier und Tinte nach sich ziehen würde. <quote>Unbekannte</quote> Daten werden von CUPS
	als <parameter>MIME type: application/octet-stream</parameter> gekennzeichnet, und es wird ihnen nicht
	erlaubt, zum Drucker zu gelangen. In der Voreinstellung können Sie nur andere (bekannte) MIME-Typen
	 <quote>raw</quote> senden. Das <quote>raw</quote>-Senden von Daten bedeutet, daß CUPS nicht versucht,
	die Daten zu konvertieren und sie einfach unangetastet an den Drucker weiterleitet (sehen Sie das nächste
	Kapitel für noch mehr Hintergrund-Erklärungen dazu). 
	</para>
	</formalpara>

	<para>
	Dies ist alles, was Sie darüber wissen müssen, um die CUPS/Samba-Combo zum <quote>raw</quote>-Druck
	der von Windows-Clients, die Herstellertreiber lokal installiert haben, vorbereiteten Dateien 
	zu bringen. Wenn Sie nicht an Hintergrund-Informationen zu erweitertem CUPS/Samba-Druck interessiert
	sind, überspringen Sie einfach die restlichen Abschnitte dieses Kapitels.
	</para>
	</sect2>

	<sect2>
	<title>Die Methoden, um Treiber auf den Server zu laden</title>

	<para>
	Dieser Abschnitt beschreibt drei übliche Methoden, zuzüglich einer neuen, mit denen Druckertreiber
	auf den Server geladen werden können ("Upload").
	</para>

	<para>
	<indexterm><primary>point 'n' print</primary></indexterm>
	Wenn Sie Druck vom Typ MS-RPC verwenden wollen, müssen Sie die Treiber zuerst auf den Samba-Server
	hochladen (Freigabe <smbconfsection>[print$]</smbconfsection>). Für die Behandlung des Themas, wie
	man Druckertreiber auf dem Samba-Host ablegt (damit die Windows-Clients diese via
	<quote>Point'n'Print</quote> herunterladen und verwenden können, lesen Sie bitte das vorhergehende
	Kapitel dieser HOWTO-Sammlung. Dort finden Sie Beschreibungen und Referenzen zu drei Methoden, um
	Druckertreiber auf dem Samba-Server vorzubereiten:
	</para>
	<itemizedlist>
		<listitem><para>
	<indexterm><primary>Druckerinstallations-Assistent</primary></indexterm>
				Die GUI, <quote>Druckerinstallations-Assistent</quote>
	<emphasis>upload-von-einem-Windows-Client</emphasis> Methode.</para></listitem>

	<listitem><para>Die Befehlszeilen, <quote>smbclient/rpcclient</quote>
	upload-von-einer-UNIX-Workstation Methode.</para></listitem>


	<listitem><para>
	<indexterm><primary>imprints</primary></indexterm>
			Die Imprints Toolset Methode.</para></listitem>
	</itemizedlist>

	<para>
	Diese drei Methoden können genauso auf CUPS angewendet werden. Ein neuer und praktischerer Weg, um
	Windows-Treiber in Samba zu laden, steht zur Verfügung, wenn Sie CUPS verwenden:
	</para>


	<itemizedlist>
		<listitem><para>
	<indexterm><primary>cupsaddsmb</primary></indexterm>
				Das <parameter>cupsaddsmb</parameter> Werkzeug.</para></listitem>
	</itemizedlist>

	<para>
	<command>cupsaddsmb</command> wird weiter unten im Detail behandelt. Zuerst erkunden wir aber das
	CUPS-Filter-System und vergleichen die Windows- und UNIX-Druck-Architektur.
	</para>
	</sect2>
</sect1>

<sect1>
	<title>Erweitertes intelligentes Drucken mit Download von Postscript-Treibern</title>


	<para>
	<indexterm><primary>PostScript</primary><seealso>Ghostscript</seealso></indexterm>
	Wir wissen nun, wie man einen <quote>dump</quote>-Druckserver aufsetzt, das ist ein Server, der
	Druckaufträge <quote>raw</quote> verwaltet, also die Druckdaten unberührt läßt.
	</para>

	<para>
	Möglicherweise müssen Sie CUPS auf eine	intelligentere Art installieren. Die Gründe können mannigfaltig
	sein:
	</para>

	<itemizedlist>
	<listitem><para>
	Vielleicht will Ihr Chef monatliche Statistiken: Welcher Drucker hat wieviele Seiten gedruckt?
	Was war die durchschnittliche Grösse eines Druckauftrags? Wieviele Druckaufträge gab es im Durchschnitt
	pro Tag? Welche Abteilung druckt wieviel?</para></listitem>

	<listitem><para>
	Vielleicht sollen Sie ein Druck-Quota-System aufbauen: Benutzer sollten nicht mehr drucken können, als
	ein vorgeschriebenes Limit pro Periode.</para></listitem>

	<listitem><para>
	Vielleicht ist Ihr Netzwerkdruck-Setup ein komplettes Durcheinander und muß von Grund auf
	reorganisiert werden.</para></listitem>

	<listitem><para>
	Vielleicht haben Sie bereits zu viele <quote>blue screens</quote> gesehen, die von Druckertreibern
	herrühren, die unvollständig "debugged" wurden und in NT 
	<quote>kernel mode</quote> laufen?</para></listitem> 
	
	</itemizedlist>

	<para>
	Diese Ziele können nicht mit einem RAW-Druckserver erreicht werden. Um einen Server aufzubauen, der
	diesen Anforderungen entspricht, müssen Sie zuerst lernen, wie CUPS arbeitet, und wie Sie seine
	Features aktivieren.
	</para>

	<para>
	Was nun folgt, ist der Vergleich von einigen fundamentalen Konzepten des Windows- und UNIX-Drucks;
	danach folgt eine Beschreibung des CUPS-Filter-Systems, wie es arbeitet, und wie Sie es beeinflussen
	können.
	</para>

	<sect2 id="gdipost">
	<title>GDI unter Windows -- PostScript auf UNIX</title>


	<para>
	<indexterm><primary>GDI</primary></indexterm>
	<indexterm><primary>PostScript</primary></indexterm>
	Netzwerkdurck ist eine der kompliziertesten und fehlerträchtigsten Alltags-Aufgaben, die ein Benutzer
	oder Administrator zu bewältigen hat. Dies gilt für alle Betriebssysteme. Und hier sind die Gründe dafür.
	</para>


	<para>
	<indexterm><primary>PCL</primary></indexterm>
	<indexterm><primary>PDL</primary></indexterm>
	Bei den meisten Dateiformaten können Sie nicht erwarten, sie einfach in den Drucker zu schmeissen, und
	sie werden gedruckt. Es muß eine Wandlung des Dateiformats passieren. Das Problem dabei ist, daß es 
	keinen gemeinsamen Standard für Druck-Datei-Formate über alle Hersteller und Druckertypen gibt.
	Während sich PostScript (Handelsmarke von Adobe) und, zu einem gewissen Teil, PCL (Handelsmarke von HP)
	zu halb-offiziellen <quote>Standards</quote> entwickelt haben, indem sie die weitest verbreiteten
	PDLs (Page Description Languages) sind, gibt es nach wie vor viele Hersteller, die
	<quote>ihr eigenes Süppchen kochen</quote> (der Grund dafür können inakzeptabel hohe Lizenzgebühren
	für Drucker-interne PostScript-Interpreter sein, usw.).
	</para>
	</sect2>

	<sect2>
	<title>Windows Drivers, GDI and EMF</title>


	<para>
	<indexterm><primary>GDI</primary></indexterm>
	<indexterm><primary>EMF</primary></indexterm>
	<indexterm><primary>WYSIWYG</primary></indexterm>
	Im Windows OS wird die Formatwandlung von den Druckertreibern erledigt. Auf der Windows-Plattform
	haben alle Anwendungs-Programmierer eine eingebaute API zur Verfügung, das Graphical Device
        Interface (GDI), als Teil und Paket des Betriebssystems selbst, um darauf aufzubauen. Dieser GDI-Kern
	wird als gemeinsame einheitliche Grundlage für alle Windows-Programme verwendet, um Bilder,
	Schriften und Dokumente <emphasis>am Bildschirm "on screen"</emphasis> darzustellen, genauso wie
	<emphasis>auf Papier "on paper"</emphasis> (Druck). Daher können Druckertreiber-Hersteller sich mit ihrem
	Druckertreiber-Input auf einen wohldefinierten GDI-Output standardisieren. Das Erreichen von
	WYSIWYG (<quote>What You See Is What You Get</quote>) ist relativ einfach, weil die on-screen
	Grafik-Primitive, genauso wie die on-paper gezeichneten Objekte von einer gemeinsamen Quelle stammen.
	Diese Quelle, die GDI, erzeugt oft ein Dateiformat namens Enhanced MetaFile (EMF). EMF wird vom
	Druckertreiber verarbeitet und in ein Drucker-spezifisches Format konvertiert.
	</para>

	<note><para>
	<indexterm><primary>PDF</primary></indexterm>
	Zusätzlich zur GDI-Basis in MS Windows, hat Apple sich entschieden, Papier- und Bildschirmausgaben
	für seine (auf BSD-UNIX basierende, wußten Sie das?) Betriebssysteme Mac OS X und Darwin auf
	eine gemeinsame Basis zu stellen. 
	<indexterm><primary>X Window System</primary></indexterm>
	<indexterm><primary>PostScript</primary></indexterm>
	<indexterm><primary>PCL</primary></indexterm>
	<indexterm><primary>Xprint</primary></indexterm>
	Apples <emphasis>Core Graphic Engine</emphasis> verwendet eine Abwandlung von <emphasis>PDF</emphasis>
	für alle Anzeigen.	
	</para></note>

	<para>

	<image><imagedescription>Windows druckt auf einen lokalen Drucker.</imagedescription><imagefile>1small</imagefile></image>
	</para>
	</sect2>

	<sect2>
	<title>UNIX Druckdatei-Konvertierung und GUI-Grundlagen</title>


	<para>
	<indexterm><primary>X Window System</primary></indexterm>
	<indexterm><primary>PostScript</primary></indexterm>
	<indexterm><primary>PCL</primary></indexterm>
	<indexterm><primary>Xprint</primary></indexterm>
	In UNIX and Linux gibt es keine vergleichbare Schicht im OS-Kernel oder dem X-
	(Bildschirm-Darstellungs) Server. Jede Anwendung ist für sich selbst verantwortlich, um ihre
	Druckausgabe zu erzeugen. Zum Glück verwenden die meisten Postscript und das gibt zumindest etwas
	gemeinsame Grundlagen. Unglücklicherweise gibt es viele verschiedene Qualitätsstufen für Postscript.
	Und noch schlechter, es gibt einen riesigen Unterschied (und keinen gemeinsamen Ursprung) zwischen
	der Darstellung desselben Dokuments auf dem Bildschirm und wie dieses Dokument auf Papier
	dargestellt wird. WYSIWYG ist schwieriger zu erreichen. Dies stammt aus der Zeit, Jahrzehnte zurück,
	als die Vorläufer von X.org beim Entwurf der UNIX-Grundlagen und -Protokolle für GUIs, die
	Verantwortung für <quote>Papierausgabe</quote> ablehnten, und sich auf <quote>nur on-screen</quote>
	beschränkten. (Seit einigen Jahren ist das Projekt <quote>Xprint</quote> in Entwicklung, man versucht,
	Druckunterstützung in das X-Framework zu integrieren, inklusive eines PostScript- und eines PCL-Treibers,
	aber dieses Projekt ist noch nicht bereit für die Anwendung.) Sie können diese unangenehme Erbe bis heute
	sehen, wenn Sie sich die verschiedenen <quote>font</quote>-Verzeichnisse auf Ihrem System ansehen;
	es gibt eigene Schriften für X-Darstellung und andere für den Druck auf Papier.
	</para>

	<formalpara>
	<title>Hintergrund</title>


	<para>
	<indexterm><primary>PostScript</primary></indexterm>
	Die Programmiersprache PostScript ist eine <quote>Erfindung</quote> von Adobe Inc., aber ihre
	Spezifikationen wurden vollständig veröffentlicht. Ihre Stärke liegt in den mächtigen Fähigkeiten,
	graphische Objekte zu beschreiben (Schriften, Formen, Muster, Linien, Kurven, und Punkte), deren
	Attribute (Farbe, Strichstärke), und die Art, diese zu manipulieren (Skalieren, Verzerren, Rotieren,
	Verschieben). Wegen der offenen Spezifikation kann jeder mit entsprechenden Fähigkeiten damit beginnen,
	seine eigene Implementation eines PostScript-Interpreters zu schreiben, und diesen zu verwenden, um
	PostScript-Dateien auf dem Schirm oder auf Papier darzustellen. Die meisten grafischen Ausgabegeräte
	basieren auf dem Konzept von <quote>Raster-Bildern</quote> oder <quote>Pixeln</quote> (eine zu erwähnende
	Ausnahme bilden Stift-Plotter). Natürlich können Sie eine PostScript-Datei in seiner Text-Form betrachten
	und ihren PostScript-Code lesen, die Sprach-Befehle, die von einem Rasterizer interpretiert werden
	müssen. Rasterizer erzeugen Pixel-Bilder, welche von einem Viewer auf dem Schirm dargestellt werden
	können, oder von einem Drucker auf dem Papier.
	</para>
	</formalpara>
	</sect2>

	<sect2 id="post-and-ghost">
	<title>PostScript und Ghostscript</title>

	<para>
	<indexterm><primary>PostScript</primary></indexterm>
	<indexterm><primary>GhostScript</primary><seealso>PostScript</seealso></indexterm>
	<indexterm><primary>PostScript</primary><secondary>RIP</secondary></indexterm>
	Also fehlt UNIX eine gemeinsame Basis für Druck und Bildschirmdarstellung. Trotz diesem ungünstigen
	Erbe, ist grundsätzlich Drucken ziemlich einfach, wenn Sie PostScript-Drucker zur Verfügung haben.
	Der Grund dafür ist, daß diese Drucker einen eingebauten PostScript-<quote>Interpreter</quote>
	besitzen, auch genannt, einen Raster Image Processor (RIP) (der sie auch teurer als andere Drucker sein
	läßt); wenn Sie diesen Druckern PostScript schicken, werden diese sie auch drucken. Ihr RIP macht all
	die harte Arbeit des Umwandelns von PostScript-Zeichenbefehlen in ein Bitmap-Bild, wie Sie es auf
	Papier sehen, in einer Auflösung, wie Sie von Ihrem Drucker unterstützt wird. Dies entspricht dem
	PostScript-Druck einer Datei aus Windows.
	</para>

	<note><para>
	<indexterm><primary>PPD</primary></indexterm>
	Traditionelle UNIX-Programme und -Druck-Systeme &smbmdash; bei Verwendung von PostScript &smbmdash;
	sind nicht PPD-fähig. PPDs sind <quote>PostScript Printer Description</quote>-Dateien. Sie ermöglichen
	es Ihnen, alle Optionen, die ein Drucker kennt, anzugeben und zu kontrollieren: Duplexdruck, Stapeln
	und Lochen. Daher konnten UNIX-Anwender lange Zeit viele der unterstützten Geräte- und Auftrags-Optionen
	nicht nutzen, im Unterschied zu Windows- und Apple-Anwendern. Aber jetzt gibt es CUPS.
	</para>
	</note>

	<para>
	<image><imagedescription>Drucken auf einen PostScript-Drucker.</imagedescription>
			<imagefile>2small</imagefile></image>
	</para>


	<para>
	<indexterm><primary>PDL</primary></indexterm>
	Jedoch gibt es auch andere Drucker-Typen da draussen. Diese Typen wissen nicht, wie man PostScript
	druckt. Sie verwenden ihre eigene Page Description Language (PDL, oft proprietär). Das Drucken auf
	diesen Geräten stellt höhere Anforderungen. Da Ihre UNIX-Anwendungen meistens PostScript erzeugen,
	und da diese Geräte kein PostScript verstehen, müssen Sie die Druckdateien auf dem host in ein 
	für Ihren Drucker passendes Format konvertieren, bevor Sie diese an den Drucker senden können.
	</para>
	</sect2>

	<sect2>
	<title>Ghostscript &smbmdash; der Software RIP für Nicht-PostScript-fähige Drucker</title>


	<para>
	<indexterm><primary>GhostScript</primary></indexterm>
	Hier betritt Ghostscript das Geschehen. Ghostscript ist der traditionelle (und ziemlich mächtige)
	PostScript-Interpreter, der auf UNIX-Plattformen verwendet wird. Es ist ein RIP als Software, imstande,
	<emphasis>viele</emphasis> Datei-Konvertierungen für ein sehr grosses Spektrum von Hardware-Geräten bzw.
	Software-Dateiformaten durchzuführen. Ghostscript-Technologie und -Treiber ermöglichen PostScript-Druck
	auf Nicht-PostScript-fähige Hardware.
	</para>

	<para>
	<image><imagedescription>Ghostscript als RIP für Nicht-PostScript-fähige Drucker.</imagedescription>
		<imagefile>3small</imagefile>
	</image>
	</para>

	<tip><para>
	Verwenden Sie den Befehl <quote>gs -h</quote>, um alle eingebauten <quote>devices</quote> Ihrer
	Ghostscript-Version anzusehen. Wenn Sie den Parameter <parameter>-sDEVICE=png256</parameter> auf
	Ihrer Ghostscript-Befehlszeile angeben, teilen Sie Ghostscript mit, den Input in eine PNG-Datei
	zu konvertieren. Ein <quote>device</quote> auf der Befehlszeile anzugeben, ist der wichtigste
	Parameter, um Ghostscript exakt mitzuteilen, wie es den Input darstellen soll. Neue Versionen von
	Ghostscript werden in ziemlich regelmässigen Intervallen veröffentlicht, mittlerweile von
	artofcode LLC. Diese Versionen werden ursprünglich unter die Lizenz <quote>AFPL</quote> gestellt,
	aber dann unter der GNU GPL wiederveröffentlicht, sobald die nächste AFPL-Version erscheint.
	GNU Ghostscript ist wahrscheinlich die auf den meisten Samba-Systemen installierte Version. Aber
	es hat einige Mängel.
	<indexterm><primary>Ghostscript</primary><secondary>ESP</secondary><see>ESP GhostScript</see></indexterm>
	Daher wurde ESP Ghostscript als eine Erweiterung zu GNU Ghostscript entwickelt, mit vielen Bug-fixes,
	zusätzlichen Geräten und Erweiterungen. Es wird gemeinsam von Entwicklern von CUPS, Gimp-Print, 
	MandrakeSoft, SuSE, Red Hat, und Debian verwaltet und entwickelt. Es beinhaltet das Gerät
	<quote>cups</quote> (essentiell wichtig, um von CUPS aus auf Nicht-PS-Drucker zu drucken).
	</para></tip>
	</sect2>

	<sect2>
	<title>Spezifikation der PostScript Printer Description (PPD)</title>


	<para>
	<indexterm><primary>PPD</primary></indexterm>
	Während PostScript im Kern eine Seiten-Beschreibungs-Sprache (PDL) ist, um das Layout einer Seite auf
	eine geräte-unabhängige Art darzustellen, werden in der Praxis Druckaufträge schlußendlich immer von
	Hardware mit geräteabhängigen Eigenschaften ausgegeben. Um all die Unterschiede in der Hardware zu
	berücksichtigen und Innovation zu ermöglichen, hat Adobe eine Syntax und ein Dateiformat für
	PostScript Printer Description (PPD) Dateien bestimmt. Jeder PostScript-Drucker wird mit einer dieser
	Dateien geliefert.
	</para>

	<para>
	PPDs enthalten all die Informationen über generelle und spezifische Eigenschaften des jeweiligen
	Drucker-Modells: Welche verschiedenen Auflösungen kann es verarbeiten? Hat es eine Duplex-Einheit?
	Wieviele Papierschächte gibt es? Welche Arten von Medien und deren Formate kann es verarbeiten? Für
	jeden Punkt benennen PPDs auch die spezielle Befehlsfolge, die man zu dessen Aktivierung an den
	Drucker (meist innerhalb der PostScript-Datei) senden muß.
	</para>

	<para>
	Die Information in diesen PPDs ist dafür bestimmt, von den Druckertreibern berücksichtigt zu werden.
	Daher wird als Teil des für einen bestimmten Drucker installierten Windows PostScript Treibers die
	PPD des Druckers installiert. Wo es Sinn macht, werden die PPD-Features in den UI-Dialogen des Treibers
	dargestellt, um dem Benutzer eine Auswahl von Druck-Optionen zu geben. Schlußendlich wird die Auswahl des
	Benutzers in die vom Drucker erstellte PostScript-Datei geschrieben (in der Form spezieller PostScript,
	PJL, JCL oder hersteller-spezifischer Befehle).
	</para>

	<warning><para>
	<indexterm><primary>PDF</primary></indexterm>
	Eine PostScript-Datei, die angelegt wurde, um geräte-spezifische Befehle zum Erreichen einer bestimmten
	Druckausgabe (z.B. Duplexdruck, Stapeldruck oder Faltungen) auf einem bestimmten Ausgabegerät zu
	enthalten, kann möglicherweise nicht so drucken, wie erwartet, oder auf anderen Druckermodellen gar
	nicht zu drucken sein; es kann auch sein, daß diese Datei nicht mehr für weitere Verarbeitung durch
	Software geeignet ist (z.B. durch ein PDF-distilling Programm).
	</para></warning>
	</sect2>

	<sect2>
	<title>Verwendung von Windows-formatierten Hersteller-PPDs</title>

	<para>
	CUPS kann mit allen spezifikations-gemässen PPDs ungehen, wie sie von Herstellern für ihre
	PostScript-Modelle bereitgestellt werden. Sogar wenn ein Hersteller unser Lieblings-Betriebssystem
	nicht in seinen Handbüchern und Broschüren erwähnt hat, können Sie sich sicher darauf verlassen:
	<emphasis>Wenn Sie die Windows NT Version der PPD erhalten, können Sie diese unverändert mit CUPS
	verwenden</emphasis> und daher die volle Leistungsfähigkeit Ihres Druckers nutzen, genauso wie ein
	Windows NT Benutzer es könnte!
	</para>

	<tip><para>
	Um die Spezifikations-Entsprechung einer beliebigen PPD online zu prüfen, gehen Sie auf
	<ulink noescape="1" url="http://www.cups.org/testppd.php">http://www.cups.org/testppd.php</ulink>
	und laden Sie Ihre PPD. Sie sehen das Ergebnis sofort. CUPS hat seit der Version 1.1.19 ein weitaus
	strikteres internes PPD-Parsing und eine Code-Prüfung aktiviert; im Fall von Druckerproblemen sollte
	diese Online-Ressource einer Ihrer ersten Anlaufstellen sein.
	</para></tip>

	<warning><para>
	<indexterm><primary>foomatic</primary></indexterm>
	<indexterm><primary>cupsomatic</primary></indexterm>
	Für tatsächliche PostScript-Drucker verwenden Sie <emphasis>nicht</emphasis> die 
	<emphasis>Foomatic</emphasis> oder <emphasis>cupsomatic</emphasis> PPDs von Linuxprinting.org. Mit diesen
	Geräten sind immer die vom Hersteller bereitgestellten PPDs erste Wahl!
	</para></warning>

	<tip><para>
	Wenn Sie nach einem Original-Hersteller-PPD eines spezifischen Geräts suchen, und Sie wissen, daß eine
	NT4-Box (oder irgendeine andere Windows-Box) in Ihrem LAN den PostScript-Treiber installiert hat, 
	verwenden Sie einfach <command>smbclient //NT4-box/print\$ -U username</command>, um auf das
	Windows-Verzeichnis zuzugreifen, in dem alle Druckertreiber-Dateien gespeichert sind. Durchsuchen Sie
	zuerst das Unterverzeichnis <filename>W32X86/2</filename> nach den gesuchten PPDs.
	</para></tip>
	</sect2>

	<sect2>
	<title>CUPS verwendet auch PPDs für Nicht-PostScript-Drucker</title>

	<para>
	CUPS verwendet auch spezielle PPDs, um mit Nicht-PostScript-Druckern umzugehen. Diese PPDs sind
	üblicherweise nicht von den Herstellern verfügbar (und, nein, Sie können nicht einfach das die PPD
	eines PostScript-Druckers mit demselben Modellnamen verwenden und hoffen, daß diese auch mit der
	Nicht-PostScript-Version funktioniert). Um zu verstehen, wie diese PPDs funktionieren, müssen wir
	zuerst tief in die Architektur der CUPS-Filter und -Dateiwandlung eintauchen. Bleiben Sie dran.
	</para>
	</sect2>
</sect1>

<title>Die CUPS Filter-Architektur</title>

<para>
Der Kern des CUPS-Filter-Systems beruht auf Ghostscript. Zusätzlich dazu verwendet CUPS einige andere eigene
Filter. Sie (oder der Hersteller Ihres Betriebssystems) können sogar noch mehr Filter hinzugefügt haben.
CUPS behandelt alle Dateiformate unter der Zuordnung verschiedener MIME-Typen. Jede einlangende Druckdatei
wird einem initialen Auto-Typing zugeführt. Dieses Auto-Typing bestimmt den MIME-Typ der Druckdatei. Ein
bestimmter MIME-Typ bedingt null keine oder mehrere mögliche Filter-Ketten, die für den gewählten Zieldrucker
relevant sind. Dieser Abschnitt behandelt, wie die Erkennungs- und Umwandlungs-Regeln von MIME-Typen
zusammenarbeiten. Sie werden von CUPS dazu verwendet, um automatisch eine funktionierende Filterkette für
jedes beliebige Eingabe-Datenformat zu bilden.
</para>

<para>
Wenn CUPS eine PostScript-Datei in ein Bitmap rastert, passiert dies in 2 Stufen:
</para>

<itemizedlist>
	<listitem><para>Die erste Stufe verwendet ein Ghostscript-device namens <quote>cups</quote>
	(dies seit Version 1.1.15), und erzeugt ein generisches Raster-Format namens
	<quote>CUPS raster</quote>.
</para></listitem>

<listitem><para>Die zweite Stufe verwendet einen <quote>raster driver</quote>, der das generische
	<quote>CUPS raster</quote> in ein geräte-spezifisches Raster konvertiert.</para></listitem>
</itemizedlist>

<para>
Stellen Sie sicher, daß Ihre Ghostscript-Version das Gerät <quote>cups</quote> einkompiliert hat 
(Überprüfung mittels <command>gs -h | grep cups</command>). Ansonsten könnten Sie das gefürchtete
<computeroutput>Unable to convert file 0</computeroutput> in Ihrer CUPS error_log Datei vorfinden. Um 
<quote>cups</quote> als GErät in Ihrem Ghostscript zu haben, müssen Sie entweder GNU Ghostscript patchen und
neu kompilieren, oder Sie verwenden
<indexterm><primary>ESP</primary><secondary>Ghostscript</secondary>
</indexterm><ulink
url="http://www.cups.org/ghostscript.php">ESP Ghostscript</ulink>.
Die bessere Alternative ist ESP Ghostscript. Es unterstützt nicht nur CUPS, sondern auch 300 andere Geräte
(während GNU Ghostscript nur ungefähr 180 Geräte unterstützt). Wegen dieser breiten Unterstützung von
Ausgabegeräten ist ESP Ghostscript auch die erste Wahl für nicht-CUPS-Spooler. Es wird mittlerweile von
Linuxprinting.org für alle Spooler empfohlen.
</para>

<para>
<indexterm><primary>cupsomatic</primary></indexterm>
<indexterm><primary>foomatic</primary></indexterm>
CUPS-Drucker können zur Verwendung externer Darstellungs-Pfade. Einer der gängigsten ist das
Konzept Foomatic/cupsomatic von <ulink url="http://www.linuxprinting.org/">Linuxprinting.org.</ulink>
Dieses verwendet den klassischen Ghostscript-Ansatz, alles auf einmal zu tun. Es verwendet nicht das Gerät
<quote>cups</quote>, sondern eines der vielen anderen. 
<indexterm><primary>ESP</primary><secondary>Ghostscript</secondary></indexterm>
Jedoch erzielt man auch bei Verwendung von 
Foomatic/cupsomatic das beste Ergebnis und die breiteste Drucker-Modell-Unterstützung mit ESP Ghostscript
(mehr zu cupsomatic/Foomatic, im Speziellen zur neuen Version, die jetzt <emphasis>foomatic-rip</emphasis>
heißt, weiter unten).
</para>

<sect2>
<title>MIME-Typen und CUPS-Filter</title>


<para>
<indexterm><primary>MIME</primary><secondary>Filter</secondary></indexterm>
	<indexterm><primary>MIME</primary></indexterm>
CUPS liest die Datei <filename>/etc/cups/mime.types</filename> (und alle anderen Dateien mit einem Suffix
<filename>*.types</filename> im selben Verzeichnis) beim Start. Diese Dateien enthalten die 
MIME-Typ-Erkennungs-Regeln, die angewendet werden, wenn CUPS seine Auto-Typing-Routinen ausführt.
Die Regel-Syntax wird in der manpage von <filename>mime.types</filename> erklärt und in dem
Abschnitt "comments" in der Datei <filename>mime.types</filename> selbst. Eine einfache Regel sieht so aus:

<indexterm><primary>application/pdf</primary></indexterm>
<filterline>
 application/pdf         pdf string(0,%PDF)
</filterline>

Das bedeutet, daß wenn ein Dateiname den Suffix <filename>.pdf</filename> hat oder der magische String
<emphasis>%PDF</emphasis> exakt am Beginn der Datei selbst (Offset 0 vom Start) steht, ist dies eine
PDF-Datei ((<parameter>application/pdf</parameter>). Eine weitere Regel ist:

<filterline>
 application/postscript  ai eps ps string(0,%!) string(0,&lt;04&gt;%!)
</filterline>

Wenn der Dateiname einen der Suffixes <filename>.ai</filename>, <filename>.eps</filename>, 
<filename>.ps</filename> hat, oder die Datei selbst mit einem der Strings
<emphasis>%!</emphasis> oder <emphasis><![CDATA[<04>%!]]></emphasis> beginnt, ist es eine generische
PostScript-Datei (<parameter>application/postscript</parameter>).
</para>

<warning><para>
Verwechseln Sie nicht die anderen mime.types Dateien, die Ihr System verwendet, mit denen im Verzeichnis
<filename>/etc/cups/</filename>.
</para></warning>

<note><para>
Es gibt einen wichtigen Unterschied zwischen zwei ähnlichen MIME-Typen in CUPS: einer ist
<parameter>application/postscript</parameter>, der andere ist 
<parameter>application/vnd.cups-postscript</parameter>. Während <parameter>application/postscript</parameter>
geräte-unabhängig sein soll (Auftrags-Optionen sind immer noch außerhalb des PS-Datei-Inhalts, 
von CUPS eingebettet in der Befehlszeile oder Umgebungsvariablen), kann 
<parameter>application/vnd.cups-postscript</parameter> die Auftrags-Optionen in die Postscript-Daten selbst
eingefügt erhalten (wo anwendbar). Die Transformation des generischen PostScript-Formats
(<parameter>application/postscript</parameter>) zu geräte-spezifischem PostScript
(<parameter>application/vnd.cups-postscript</parameter>) ist die Aufgabe des CUPS-Filters
<parameter>pstops</parameter>. pstops verwendet Informationen aus dem PPD, um die Transformation durchzuführen.
</para></note>

<para>
CUPS kann mit seinen Filtern folgende Formate und ihre zugehörigen MIME-Typen handhaben: 
ASCII text, HP-GL, PDF, PostScript, DVI, und viele Bild-Formate (GIF. PNG, TIFF, JPEG, Photo-CD, SUN-Raster,
PNM, PBM, SGI-RGB, und noch mehr).
</para>
</sect2>

<sect2>
<title>MIME Typ Umwandlungs-Regeln</title>


<para>
<indexterm><primary>MIME</primary></indexterm>
<indexterm><primary>application/pdf</primary></indexterm>
CUPS liest die Datei <filename>/etc/cups/mime.convs</filename> (und alle anderen Dateien mit der Endung
<filename>*.convs</filename> im selben Verzeichnis) beim Starten. Diese Dateien enthalten Zeilen, diese
benennen einen Eingabe-MIME-Typus, einen Ausgabe-MIME-Typus, einen Format-Wandlungs-Filter, der den
Ausgabe-Typus aus dem Eingabe-Typus erzeugen kann, sowie virtuelle Kosten, die mit dieser Wandlung verbunden
sind. Ein Beispiel für eine solche Zeile ist dies:

<filterline>
 application/pdf         application/postscript   33   pdftops
</filterline>

Das bedeutet, daß der Filter <parameter>pdftops</parameter> den Typ <parameter>application/pdf</parameter> als
Eingabe verwenden und daraus <parameter>application/postscript</parameter> als Ausgabe erzeugen wird; die
virtuellen Kosten dieser Operation sind 33 CUPS-$. Der nächste Filter ist teurer, er kostet 66 CUPS-$:

<indexterm><primary>pdf</primary></indexterm>

<filterline>
 application/vnd.hp-HPGL application/postscript   66   hpgltops
</filterline>

Dies ist der Filter <parameter>hpgltops</parameter>, der HP-GL Plotter-Dateien in PostScript umwandelt.

<indexterm><primary>application/octet-stream</primary></indexterm>

<filterline>
 application/octet-stream
</filterline>

Hier zwei weitere Beispiele:

<indexterm><primary>text/plain</primary></indexterm>

<filterline>
 application/x-shell     application/postscript   33    texttops
 text/plain              application/postscript   33    texttops
</filterline>

Die letzten beiden Beispiele lassen den Filter <parameter>texttops</parameter> sowohl an
<parameter>text/plain</parameter>, wie auch an <parameter>application/x-shell</parameter> arbeiten.
(Hinweis: Diese Unterscheidung wird für das Syntax-Highlighting von <parameter>texttops</parameter>
benötigt).
</para>
</sect2>

<sect2>
<title>Überblick über das Filtern</title>


<para>
<indexterm><primary>MIME</primary></indexterm>
Es gibt viel mehr Kombinationen in <filename>mime.convs</filename>. Sie sind jedoch nicht darauf beschränkt,
die hier vordefinierten Kombinationen zu verwenden. Sie können jeden Filter, den Sie wollen, in das
CUPS-Grundgerüst einsetzen. Es muß einigen minimalen Erfordernissen entsprechen, oder dazu gebracht werden.
Wenn Sie irgend einen coolen Filter finden (oder schreiben), stellen Sie sicher, daß er dem entspricht, was CUPS
braucht, und daß Sie die richtigen Zeilen in die Dateien <filename>mime.types</filename> und
<filename>mime.convs</filename> einfügen, dann wird er nahtlos innerhalb CUPS arbeiten.
</para>

<sect3>
<title>Filter Erfordernisse</title>
<para>
Die erwähnten <quote>CUPS Erfordernisse</quote> für Filter sind simpel. Nehmen Sie Dateinamen oder
<filename>stdin</filename> als Input und schreiben Sie diesen auf <filename>stdout</filename>. Die Filter
sollten diese 5-6 Argumente verstehen:
<emphasis>printer job user title copies options [filename]</emphasis>
</para>

<variablelist>
<varlistentry><term>printer </term>
<listitem><para>
Der Name der Drucker-Queue (normalerweise ist dies der Name des ausgeführten Filters).</para></listitem>
</varlistentry>

<varlistentry><term>job </term>
<listitem><para>Die numerische Auftrags-ID des gerade gedruckten Auftrags.</para></listitem>
</varlistentry>

<varlistentry><term>user </term>
<listitem><para>Der String aus dem Attribut originating-user-name.</para></listitem>
</varlistentry>

<varlistentry><term>title </term>
<listitem><para>Der String aus dem Attribut job-name.</para></listitem>
</varlistentry>

<varlistentry><term>copies </term>
<listitem><para>Der numerische Wert des Attributs number-copies.</para></listitem>
</varlistentry>

<varlistentry><term>options </term>
<listitem><para>Die Auftrags-Optionen.</para></listitem>
</varlistentry>

<varlistentry><term>filename </term>
<listitem><para>(Optional) Die Datei der Druckanfrage (wenn dies fehlt, erwarten die Filter, die Daten
über <filename>stdin</filename> geliefert zu bekommen).
In den meisten Fällen ist es einfach, ein einfaches Wrapper-Skript um Filter zu schreiben, um sie mit
CUPS arbeiten zu lassen.</para></listitem>
</varlistentry>
</variablelist>
</sect3>
</sect2>

<sect2>
<title>Vorfilter ("Prefilters")</title>


<para>
<indexterm><primary>PostScript</primary></indexterm>
Wie zuvor bemerkt, ist PostScript das zentrale Dateiformat für jedes UNIX-basierende Drucksystem. Von
PostScript aus generiert CUPS Rasterdaten zur Lieferung an Nicht-PostScript-Drucker.
</para>

<para>
Aber was passiert, wenn Sie eines der unterstützten Nicht-PS-Formate in den Druck schicken? Dann verwendet
CUPS <quote>pre-filters</quote> auf diese Eingabeformate, um als erstes PostScript zu erzeugen. Es gibt solche
Vorfilter, um PS aus ASCII text, PDF, DVI, oder HP-GL zu erzeugen. Die Ausgabe dieser Filter ist immer vom
MIME Typ <parameter>application/postscript</parameter> (das bedeutet, daß jegliche geräte-spezifische 
Druckoptionen noch nicht von CUPS ins PS eingebettet werden, und daß der nächste aufzurufende Filter
pstops ist). Ein weiterer Vorfilter läuft über alle unterstützten Bildformate, der Filter 
<parameter>imagetops</parameter>. Seine Ausgabe ist immer vom MIME Typ 
<parameter>application/vnd.cups-postscript</parameter> (nicht application/postscript), was bedeutet, daß sie
die Druckoptionen bereits in der Datei eingebettet hat.
</para>

<para>
	<image scale="25"><imagedescription>Das Vorfiltern in CUPS, um PostScript zu erzeugen.</imagedescription>
	<imagefile>4small</imagefile>
</image>
</para>
</sect2>

<sect2>
<title>pstops</title>

<para>
<emphasis>pstops</emphasis> ist der Filter, um 
<parameter>application/postscript</parameter> auf <?latex \linebreak ?>
<parameter>application/vnd.cups-postscript</parameter> zu wandeln. Es wurde bereits oben erwähnt, daß dieser
Filter alle geräte-spezifischen Druckoptionen (Befehle an den Drucker, um Duplexdruck, Stapeln und Lochen zu
veranlassen, usw.) in die PostScript-Datei einbindet.
</para>

<para>
	<image scale="25"><imagedescription>Das Hinzufügen von geräte-spezifischen Druckoptionen.</imagedescription>
		<imagefile>5small</imagefile>
	</image>
</para>

<para>
Das ist nicht alles. Andere ausgeführte Aufgaben sind:
</para>

<itemizedlist>
<listitem><para>
Die Auswahl der zu druckenden Seiten (wenn Sie nur die Seiten <quote>3, 6, 8-11, 16, 19-21</quote> drucken
wollen, oder nur die ungeraden Seiten).
</para></listitem>

<listitem><para>
Zwei oder mehr logische Seiten auf ein Blatt Papier drucken (die sogenannte <quote>number-up</quote> Funktion).
</para></listitem>

<listitem><para>
Das Zählen der Seiten des Auftrags, um die Abrechnungs-Information in die Datei 
<filename>/var/log/cups/page_log</filename> zu schreiben.
</para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>pstoraster</title>

<para>
<parameter>pstoraster</parameter> ist im Kern des CUPS-Filtersystems. Er ist verantwortlich für die erste Stufe
des Raster-Prozesses. Sein Input ist vom MIME-Typ application/vnd.cups-postscript; seine Ausgabe ist
application/vnd.cups-raster. Dieses Ausgabeformat ist noch nicht zum Drucken gedacht, die Aufgabe ist, als
allgemeines Input-Format für spezialisierte <emphasis>Raster-Treiber</emphasis> gedacht, die imstande sind,
geräte-spezifische Druckerdaten zu generieren.
</para>

<para>
	<image scale="25"><imagedescription>PostScript auf Übergangs-Raster-Format.</imagedescription><imagefile>6small</imagefile></image>
</para>

<para>
CUPS-Raster ist ein generisches Rasterformat mit mächtigen Eigenschaften. Es ist imstande, Informationen zu
einzelnen Seiten, Farbprofile, und mehr zu inkludieren, um diese Informationen nachfolgenden Raster-Treibern
zu übergeben. Sein MIME-Typ ist bei IANA registriert und seine Spezifikation ist, natürlich, völlig offen.
Es ist entworfen, um es Herstellern zu ermöglichen, ziemlich einfach und günstig Raster-Treiber für Linux
und UNIX zu entwickeln, wenn diese es möchten. CUPS übernimmt immer die erste Stufe des Rasterns, so daß
Hersteller sich nicht um die Ghostscript-Komplikationen kümmern müssen (tatsächlich gibt es derzeit mehr als
nur einen Hersteller, der die Entwicklung von CUPS-Raster-Treibern finanziert).
</para>

<para>
	<image><imagedescription>CUPS-Raster Erzeugung mittels Ghostscript.</imagedescription>
		<imagefile>7small</imagefile>
	</image>
</para>

<para>
CUPS-Versionen vor Version 1.1.15 beinhalteten einen binären (oder source code) Standalone-Filter namens
<parameter>pstoraster</parameter>. <parameter>pstoraster</parameter> wurde von GNU Ghostscript 5.50
abgeleitet, und konnte neben oder zusätzlich zu einem beliebigen GNU oder AFPL Ghostscript-Paket
installiert werden, ohne Konflikte zu verursachen.
</para>

<para>
Mit Version 1.1.15 hat sich dies geändert. Die dafür benötigten Funktionen wurden zurück in Ghostscript
integriert (nun basierend auf GNU Ghostscript Version 7.05). Der <parameter>pstoraster</parameter>-Filter
ist nun ein einfaches Shell-Skript, das <command>gs</command> mit dem Parameter <command>-sDEVICE=cups</command>
aufruft. Wenn Ihr Ghostscript nicht erfolgreich auf <command>gs -h |grep cups</command> antwortet, könnte es
sein, daß Sie nicht drucken können. Aktualisieren Sie Ihr Ghostscript.
</para>
</sect2>

<sect2>
<title>imagetops und imagetoraster</title>

<para>
Im Abschnitt über Vorfilter haben wir den Vorfilter erwähnt, der PostScript aus Bildformaten erzeugt. Der
Filter <parameter>imagetoraster</parameter> wird verwendet, um Bilder direkt auf Raster zu konvertieren, ohne
die Zwischenstufe PostScript. Er wird öfter als die oben erwähnten Vorfilter verwendet. Wir fassen das
Filtern von Bilddateien im <link linkend="small8">nächsten Bild</link> zusammen. 
</para>

<para>
	<image id="small8"><imagedescription>Konvertierung von Bildformaten zu CUPS-Raster-Format.</imagedescription>
		<imagefile>8small</imagefile>
	</image>
</para>

</sect2>

<sect2>
<title>rasterto [druckerspezifisch]</title>

<para>
CUPS wird mit ziemlich verschiedenen Rastertreibern geliefert, die CUPS-Raster verarbeiten. Auf meinem System
finde ich in /usr/lib/cups/filter/ diese:
<parameter>rastertoalps</parameter>, <parameter>rastertobj</parameter>, <parameter>rastertoepson</parameter>, <parameter>rastertoescp</parameter>,
<parameter>rastertopcl</parameter>, <parameter>rastertoturboprint</parameter>, <parameter>rastertoapdk</parameter>, <parameter>rastertodymo</parameter>,
<parameter>rastertoescp</parameter>, <parameter>rastertohp</parameter>, und
<parameter>rastertoprinter</parameter>. 
Keine Sorge, wenn Sie weniger Filter vorfinden; manche von diesen wurden von kommerziellen CUPS-Erweiterungen
installiert (wie <parameter>rastertoturboprint</parameter>), andere (wie <parameter>rastertoprinter</parameter>)
von sogenannten "third-party" Treiber-Entwicklungs-Projekten (wie Gimp-Print), um möglichst eng mit CUPS
zusammen zu arbeiten.
</para>

<para>
	<image id="small9"><imagedescription>Raster auf druckerspezifische Formate.</imagedescription>
		<imagefile>9small</imagefile>
	</image>
</para>
</sect2>

<sect2>
<title>CUPS Backends</title>

<para>
Der letzte Teil jeder CUPS-Filterkette ist ein Backend. Backends sind spezielle Programme, die das druckfertige
Programm schlußendlich an das Gerät senden. Es gibt ein separates Backend-Programm für jedes Transfer-Protokoll,
um Druckaufträge über das Netzwerk zu senden, oder für jedes lokales Interface. Jede CUPS-Druckwarteschlange
braucht eine CUPS <quote>device-URI</quote>, mit dem es assoziiert wird. Die device URI ist eine Art, das
Backend enkodiert anzugeben, das verwendet wird, um den Auftrag an seinen Bestimmungsort zu senden.
Netzwerk device-URIs verwenden zwei Schrägstriche in ihrer Syntax, lokale device-URIs nur einen, wie Sie der
folgenden Liste entnehmen können. Bitte denken Sie daran, daß die Namen der lokalen Interfaces stark von
den hier angegebenen Beispielen abweichen können, wenn Ihr Betriebssystem nicht Linux ist:
</para>

<variablelist>
	<varlistentry><term>usb </term>
	<listitem><para>
	Dieses Backend sendet Druckdateien auf mittels USB angeschlossene Drucker. Ein Beispiel für die
	CUPS device-URI ist:
	<filename>usb:/dev/usb/lp0</filename>.
	</para></listitem></varlistentry>

	<varlistentry><term>serial </term>
	<listitem><para>
	Dieses Backend sendet Druckdateien auf seriell angeschlossene Drucker. Ein Beispiel für die
        CUPS device-URI ist:
	<filename>serial:/dev/ttyS0?baud=11500</filename>.
	</para></listitem></varlistentry>

	<varlistentry><term>parallel </term>
	<listitem><para>
	Dieses Backend sendet Druckdateien auf an Parallel-Ports angeschlossene Drucker. Ein Beispiel für die
        CUPS device-URI ist:
	<filename>parallel:/dev/lp0</filename>.
	</para></listitem></varlistentry>

	<varlistentry><term>SCSI </term>
	<listitem><para>
	Dieses Backend sendet Druckdateien auf an das SCSI-Interface angeschlossene Drucker. Ein Beispiel für die
        CUPS device-URI ist:
	<filename>scsi:/dev/sr1</filename>.
	</para></listitem></varlistentry>

	<varlistentry><term>lpd </term>
	<listitem><para>
	Dieses Backend sendet Druckdateien auf über LPR/LPD angeschlossene Netzwerk-Drucker. Ein Beispiel für die
        CUPS device-URI ist:
	<filename>lpd://remote_host_name/remote_queue_name</filename>.
	</para></listitem></varlistentry>

	<varlistentry><term>AppSocket/HP JetDirect </term>
	<listitem><para>
	Dieses Backend sendet Druckdateien an mittels AppSocket (a.k.a. "HP JetDirect") angeschlossene 
	Netzwerk-Drucker. Ein Beispiel für die
        CUPS device-URI ist:
	<filename>socket://10.11.12.13:9100</filename>.
	</para></listitem></varlistentry>

	<varlistentry><term>ipp </term>
	<listitem><para>
	Dieses Backend sendet Druckdateien an mittels IPP angeschlossene Netzwerk-Drucker. Ein Beispiel für die
        CUPS device-URI ist:
	<filename>ipp:://192.193.194.195/ipp</filename>
	(für viele HP-Drucker) oder
	<filename>ipp://remote_cups_server/printers/remote_printer_name</filename>.
	</para></listitem></varlistentry>

	<varlistentry><term>http </term>
	<listitem><para>
	Dieses Backend sendet Druckdateien an mittels HTTP angeschlossene Drucker.
	(Das http:// CUPS-Backend ist nur ein symlink auf das ipp:// Backend.)
	Beispiele für die CUPS device-URIs sind:
	<filename>http:://192.193.194.195:631/ipp</filename>
	(für viele HP-Drucker) oder
	<filename>http://remote_cups_server:631/printers/remote_printer_name</filename>.
	</para></listitem></varlistentry>

	<varlistentry><term>smb </term>
	<listitem><para>
	Dieses Backend sendet Druckdateien an Windows-Druckerfreigaben.
	Ein Beispiel für die CUPS device-URI ist:
	</para>

	<para>
	<simplelist>
	<member><filename>smb://workgroup/server/printersharename</filename></member>
	<member><filename>smb://server/printersharename</filename></member>
	<member><filename>smb://username:password@workgroup/server/printersharename</filename></member>
	<member><filename>smb://username:password@server/printersharename</filename></member>
	</simplelist>
	</para>

	<para>
	Das smb:// Backend ist ein Symlink auf das Samba-Werkzeug <parameter>smbspool</parameter> (nicht in
	CUPS inkludiert). Wenn der Symlink in Ihrem CUPS-Backend-Verzeichnis nicht vorhanden ist, können Sie
	es mittels root-Benutzer anlegen (lassen): <command>ln -s `which smbspool'
        /usr/lib/cups/backend/smb</command>.
	</para></listitem></varlistentry>
</variablelist>

<para>
Es ist einfach, Ihre eigenen Backends als Shell- oder Perl-Skripts zu schreiben, wenn Sie irgendeine Änderung
oder Erweiterung zum CUPS-Druck-System brauchen. Ein Grund könnte sein, daß Sie <quote>spezielle</quote>
Drucker anlegen wollen, die Druckaufträge per email senden (durch das <quote>mailto:/</quote> Backend), diese
in PDF wandeln (durch das <quote>pdfgen:/</quote> Backend), oder sie mittels <quote>/dev/null</quote> entsorgen.
(Tatsächlich habe ich den systemweiten Standard-Drucker so installiert, daß mit einem devnull:/ Backend verbunden
ist; es gibt einfach zu viele Leute, die Aufträge ohne Angabe eines Druckers senden, oder Skripts und Programme,
die keinen Drucker angeben. Der systemweite Standard löscht den Auftrag und sendet eine höfliche Email zurück
an den $USER, in der er gebeten wird, immer den richtigen Druckernamen anzugeben.)
</para>

<para>
Nicht alle erwähnten Backends müssen auf Ihrem System vorhanden oder verwendbar sein (abhängig von der
Hardware-Konfiguration). Ein Test für alle verfügbaren CUPS-Backends ist mit dem Werkzeug 
<emphasis>lpinfo</emphasis> möglich. Mit der Option <option>-v</option> listet es alle verfügbaren Backends:
</para>

<para><screen>
&prompt;<userinput>lpinfo -v</userinput>
</screen></para>
</sect2>

<sect2>
<title>Die Rolle von <parameter>cupsomatic/foomatic</parameter></title>

<para>
<indexterm><primary>cupsomatic</primary></indexterm>
<indexterm><primary>foomatic</primary></indexterm>
<parameter>cupsomatic</parameter>-Filter sind wahrscheinlich die meist verwendeten Filter in CUPS-Installationen.
Seien sich im Klaren darüber, daß diese Filter nicht von den CUPS-Leuten entwickelt wurden. Es sind "third party"
Erweiterungen für CUPS. Sie verwenden die traditionellen Ghostscript devices, um Aufträge für CUPS darzustellen.
Bei der Fehlersuche sollten Sie über den Unterschied Bescheid wissen. Hier findet der gesamte Darstellungsprozess
in einem Schritt statt, innerhalb von Ghostscript, unter Verwendung eines passenden device für den Ziel-Drucker.
<parameter>cupsomatic</parameter> verwendet PPDs, die aus der Foomatic Drucker &amp; Treiber Datenbank auf
Linuxprinting.org generiert werden.
</para>

<para>
Sie erkennen diese PPDs an der Zeile, die den <parameter>cupsomatic</parameter> Filter aufruft:

<filterline>
 *cupsFilter: "application/vnd.cups-postscript  0  cupsomatic"
</filterline>

Sie finden diese Zeile unter den ersten 40 (oder ähnlich) Zeilen der PPD-Datei. Wenn Sie ein solches PPD
installiert haben, scheint der Drucker im CUPS Web Interface mit der Erwähnung <parameter>foomatic</parameter>
in der Treiberbeschreibung auf. <parameter>cupsomatic</parameter> ist ein Perl-Skript, das Ghostscript mit all
den komplizierten Befehlszeilen-Optionen aufruft, automatisch generiert aus dem gewählten PPD und den
Befehlszeilen-Optionen, die dem Druckauftrag mitgegeben wurden.
</para>

<para>
<indexterm><primary>point 'n' print</primary></indexterm>
Jedoch ist <parameter>cupsomatic</parameter> mittlerweile veraltet. Seine PPDs (besonders deren erste Generation,
immer noch in regem Gebrauch da draussen) entsprechen nicht den Adobe Spezifikationen. Sie könnten 
Schwierigkeiten damit haben, wenn Sie sie mittels <quote>Point'n'Print</quote> auf Windows-Clients downloaden
wollen. Ein besserer und leistungsfähigerer Nachfolge ist nun in einer stabilen Beta-Version verfügbar:
er heisst <parameter>foomatic-rip</parameter>. Um <parameter>foomatic-rip</parameter> als Filter mit CUPS zu
verwenden, brauchen Sie die PPDs von neueren Typ. Diese haben eine ähnliche, jedoch andere Zeile:

<filterline>
 *cupsFilter: "application/vnd.cups-postscript  0  foomatic-rip"
</filterline>

Der Mechanismus auf Linuxprinting.org, der PPDs generiert, wurde umgestaltet. Die neuen PPDs entsprechen den
Adobe Spezifikationen. Zuoberst stellen Sie eine neue Art bereit, um verschiedene Qualitätsstufen anzugeben
(hochauflösende Fotos, normale Farbe, Graustufen und Entwurf), mit einem einzelnen Click, wo Sie zuvor fünf
oder mehr verschiedene Auswahlen treffen mußten (Medientyp, Auflösung, Tintenart und Dithering-Algorithmus).
Es gibt Unterstützung für individuelle Mediengrössen. Es gibt Unterstützung für das Umschalten von Optionen
zwischen einzelnen Seiten eines Druckauftrags. Und das Beste ist, daß der neue foomatic-rip nun nahtlos mit
allen klassischen Spoolern zusammenarbeitet (wie LPRng, BSD-LPD, PDQ, PPR usw.), was diesen Spoolern die
Verwendung von PPDs eröffnet.
</para>
</sect2>

<sect2>
<title>Das gesamte Bild</title>

<para>
Wenn Sie einen Überblick über all die Filter sehen wollen, und wie sie sich zueinander verhalten, finden Sie
das gesamte Bild dieses Puzzles am Ende dieses Dokuments.
</para>
</sect2>

<sect2>
<title><filename>mime.convs</filename></title>

<para>
CUPS bildet automatisch alle möglichen Filterketten für jeden beliebigen MIME-Typ, und jeden installierten
Drucker. Aber wie entscheidet es für oder gegen eine bestimmte Alternative? (Es kann oft Fälle geben, in denen
es zwei oder mehr Filterketten für denselben Ziel-Drucker gibt.) Einfach. Sie haben vielleicht die Zahlen in der
dritten Spalte der Datei mime.convs bemerkt. Diese repräsentieren virtuelle Kosten, die dem jeweiligen Filter
zugeordnet sind. Jede mögliche Filterkette ergibt eine Summe von <quote>Filter-Kosten.</quote>CUPS entscheidet
zugunsten der <quote>günstigsten</quote> Route.
</para>

<tip><para>
Die Einstellung von <parameter>FilterLimit 1000</parameter> in <filename>cupsd.conf</filename> erlaubt es nicht,
mehr Filter gleichzeitig auszuführen, als solche, die insgesamt 1000 virtuelle Filter-Kosten verbrauchen. Dies
ist eine effiziente Art, die Last eines CUPS-Servers zu begrenzen, indem man einen passenden Wert für
<quote>FilterLimit</quote> setzt. Ein FilterLimit von 200 erlaubt nur ungefähr einen Auftrag zur gleichen Zeit, 
während ein FilterLimit von 1000 ungefähr 5 Aufträge gleichzeitig erlaubt.
</para></tip>
</sect2>

<sect2>
	<title><quote>Raw</quote> Druck</title>

<para>
Sie können CUPS (so ziemlich) jede Datei <quote>raw</quote> drucken lassen. <quote>Raw</quote> bedeutet, daß sie
nicht gefiltert wird. CUPS sendet die Datei an den Drucker <quote>wie sie ist</quote>, ohne sich darum zu 
kümmern, ob der Drucker imstande ist, diese Datei zu <quote>verdauen</quote>. Die Benutzer müssen sich selbst
darum kümmern, daß sie nur sinnvolle Datenformate senden. Raw-Druck kann in jeder Warteschlange passieren, wenn
die Option <quote><parameter>-o raw</parameter></quote> auf der Befehlszeile angegeben wird. Sie können auch
nur-raw-Queues anlegen, indem Sie einfach keinerlei PPD mit einer Queue assoziieren. Dieser Befehl:
</para>

<para><screen>
&prompt;<userinput>lpadmin -P rawprinter -v socket://11.12.13.14:9100 -E</userinput>
</screen></para>

<para>
installiert eine Queue namens <quote>rawprinter</quote>, verbunden mittels dem Protokoll <quote>socket</quote>
(a.k.a. <quote>HP JetDirect</quote>) mit dem Gerät auf IP-Adresse 11.12.1.3.14, Port 9100. (Wenn Sie ein PPD
mit <command>-P /path/to/PPD</command> der Befehlszeile hinzugefügt hätten, hätten Sie eine 
<quote>normale</quote> Druck-Queue installiert.)
</para>

<para>
CUPS behandelt automatisch jeden Auftrag, der an eine Queue gesendet wird, als <quote>raw</quote>, wenn es keine
mit der Queue assoziierte PPD vorfindet. Jedoch wird CUPS nur bekannte MIME-Typen senden (wie in seiner eigenen
Datei mime.types definiert) und andere ablehnen.
</para>
</sect2>

<sect2>
<title>application/octet-stream Druck</title>

<para>
Jeder MIME-Typ ohne Regel in der Datei <filename>/etc/cups/mime.types</filename> wird als unbekannt oder als
<parameter>application/octet-stream</parameter> betrachtet und nicht gesendet. Weil CUPS per Standard ablehnt,
unbekannte MIME-Typen zu drucken, haben Sie vielleicht schon einmal erlebt, daß Druckaufträge von Windows-Clients
nicht gedruckt wurden. Sie haben vielleicht eine Fehlermeldung in Ihren CUPS-Logdateien gefunden, die lautet wie:
</para>

<para><computeroutput>
 Unable to convert file 0 to printable format for job
</computeroutput></para>

<para>
Um das Drucken von Dateien des Typs <parameter>application/octet-stream</parameter> zu ermöglichen, müssen Sie
zwei Dateien editieren:
</para>

<itemizedlist>
<listitem><para><filename>/etc/cups/mime.convs</filename></para></listitem>

<listitem><para><filename>/etc/cups/mime.types</filename></para></listitem>
</itemizedlist>

<para>
Both contain entries (at the end of the respective files) which must
be uncommented to allow RAW mode operation for
<parameter>application/octet-stream</parameter>. In <filename>/etc/cups/mime.types</filename>
make sure this line is present:

<indexterm><primary>application/octet-stream</primary></indexterm>

<filterline>
application/octet-stream
</filterline>

This line (with no specific auto-typing rule set) makes all files
not otherwise auto-typed a member of <parameter>application/octet-stream</parameter>. In
<filename>/etc/cups/mime.convs</filename>, have this
line: 

<filterline>
application/octet-stream   application/vnd.cups-raw   0   -
</filterline>

<indexterm><primary>MIME</primary></indexterm>

Diese Zeile weist CUPS an, für den MIME-Typen <parameter>application/octet-stream</parameter> den 
<emphasis>Null Filter</emphasis> zu verwenden (markiert mit <quote>-</quote>, tut gar nichts), und das Resultat
als <parameter>application/vnd.cups-raw</parameter> zu kennzeichnen. Dies ist immer ein grünes Licht für den
CUPS-Scheduler, um die Datei an das Backend zu übergeben, das sich dann zum Drucker verbindet und die Datei
sendet.
</para>

<note><para>Das Editieren von <filename>mime.convs</filename> und <filename>mime.types</filename>
 <emphasis>erzwingt</emphasis> den <quote>raw</quote>-Druck nicht, es <emphasis>erlaubt</emphasis> ihn nur.
</para></note>

<formalpara>
<title>Hintergrund</title>

<para>
Da CUPS ein mehr sicherheitsbewußtes Drucksystem ist als die traditionellen Systeme, erlaubt es
in der Voreinstellung nicht, daß ein Benutzer beliebige (möglicherweise binäre) Daten an
Druck-Geräte sendet. (Dies könnte leicht dazu benutzt werden, um einen <quote>Denial of Service</quote>-Angriff
auf Ihre(n) Drucker zu starten, was zumindest den Verlust von einer Menge Papier und Tinte nach sich ziehen 
würde.)
<quote>Unbekannte</quote> Daten werden von CUPS als <emphasis>MIME-Typ</emphasis>
<emphasis>application/octet-stream</emphasis> behandelt. Während Sie Daten <quote>raw</quote> senden 
<emphasis>können</emphasis>, muß der MIME-Typ dafür einer sein, der CUPS bekannt ist, und erlaubt ist. Die Datei
<filename>/etc/cups/mime.types</filename> legt die Regeln fest, wie CUPS MIME-Typen erkennt. Die Datei
<filename>/etc/cups/mime.convs</filename> entscheidet, welche Wandlungs-Filter auf welche MIME-Typen angewandt
werden können.
</para>
</formalpara>
</sect2>

<sect2>
<title>PostScript Printer Descriptions (PPDs) für Nicht-PS-Drucker</title>


<para>
<indexterm><primary>PPD</primary></indexterm>
Ursprünglich waren PPDs nur zur Verwendung mit PostScript-Drucker gedacht. Hier helfen sie dabei, 
geräte-spezifische Befehle und Einstellungen an den RIP zu senden, der die Auftragsdatei verarbeitet. CUPS hat
die Reichweite von PPDs erweitert, um auch Nicht-PS-Drucker abzudecken. Dies war nicht schwierig, da es ein
standardisiertes Dateiformat ist. Auf eine gewisse Art war es auch logisch: CUPS verarbeitet PostScript und
verwendet einen PostScript RIP (Ghostscript), um die Auftragsdateien zu verarbeiten. Der einzige Unterschied ist:
Ein PostScript-Drucker hat den RIP eingebaut, für die anderen Arten von Drucker läuft der Ghostscript RIP auf
dem Druck-Server.
</para>

<para>
PPDs für einen Nicht-PS-Drucker beinhalten ein paar Zeilen, die einzigartig für CUPS sind. Die wichtigste sieht
ungefähr so aus:

<indexterm><primary>application/vnd.cups-raster</primary></indexterm>

<filterline>
 *cupsFilter: application/vnd.cups-raster  66   rastertoprinter
</filterline>

Dies ist das letzte Stück im CUPS-Filter-Puzzle. Diese Zeile weist den CUPS-Daemon an, als letzten Filter
<parameter>rastertoprinter</parameter> zu verwenden. Dieser Filter sollte als Input eine Datei vom MIME-Typ
<parameter>application/vnd.cups-raster</parameter> serviert bekommen. Daher sollte CUPS automatisch eine
Filterkette konstruieren, die als letzte Ausgabe den angegebenen MIME-Typ liefert. Diese wird dann als Input
für den erwähnten Filter <parameter>rastertoprinter</parameter> verwendet. Nachdem der letzte Filter seine Arbeit
getan hat (<parameter>rastertoprinter</parameter> ist ein Gimp-Print-Filter), sollte die Datei an das Backend
gesendet werden, welches in weiterer Folge an das Ausgabe-Gerät sendet.
</para>

<para>
CUPS liefert standardmässig nur ein paar generische PPDs, aber diese sind verwendbar für ein paar hundert 
Drucker-Modelle. Es kann sein, daß Sie damit nicht verschiedene Papierschächte verwalten könne, oder daß Sie
breitere Druckränder erhalten, als Ihr spezielles Modell unterstützt. Sehen Sie 
<link linkend="cups-ppds">Mit CUPS gelieferte PPDs</link> für eine Zusammenfassung.
</para>

<table frame="all" id="cups-ppds">
	<title>Mit CUPS gelieferte PPDs</title>
	<tgroup cols="2" align="left">
		<colspec align="left"/>
		<colspec align="justify" width="1*"/>
		<thead><row><entry>PPD Datei</entry><entry>Drucker-Typ</entry></row></thead>
		<tbody>
		<row><entry>deskjet.ppd</entry><entry>ältere HP Inkjet Drucker und Kompatible</entry></row>

		<row><entry>deskjet2.ppd</entry> <entry>neuere HP Inkjet Drucker und Kompatible</entry> </row>

		<row><entry>dymo.ppd</entry> <entry>Label-Drucker</entry> </row>

		<row><entry>epson9.ppd</entry> <entry>Epson 9pin Nadeldrucker und Kompatible</entry> </row>

		<row><entry>epson24.ppd</entry> <entry>Epson 24pin Nadeldrucker und Kompatible</entry> </row>

		<row><entry>okidata9.ppd</entry> <entry>Okidata 9pin Nadeldrucker und Kompatible</entry> </row>

		<row><entry>okidat24.ppd</entry> <entry>Okidata 24pin Nadeldrucker und Kompatible</entry> </row>

		<row><entry>stcolor.ppd</entry> <entry>ältere Epson Stylus Color Drucker</entry> </row>

		<row><entry>stcolor2.ppd</entry> <entry>neuere Epson Stylus Color Drucker</entry> </row>

		<row><entry>stphoto.ppd</entry> <entry>ältere Epson Stylus Photo Drucker</entry> </row>

		<row><entry>stphoto2.ppd</entry> <entry>neuere Epson Stylus Photo Drucker</entry> </row>

		<row><entry>laserjet.ppd</entry> <entry>alle PCL Drucker. Weiter unten finden Sie mehr über
		einige andere Treiber/PPD-Pakete, die für die Verwendung mit CUPS geeignet sind.</entry> </row>

		</tbody>
	</tgroup>
</table>

</sect2>

<sect2>
<title><emphasis>cupsomatic/foomatic-rip</emphasis> versus <emphasis>nativer CUPS</emphasis>-Druck</title>


<para>
<indexterm><primary>cupsomatic</primary></indexterm>
<indexterm><primary>foomatic-rip</primary></indexterm>
Natives CUPS-Rastern arbeitet in zwei Schritten:
</para>

<itemizedlist>
<listitem><para>
Zuerst kommt der Schritt <parameter>pstoraster</parameter>. Dies verwendet das spezielle CUPS-device
<indexterm><primary>ESP</primary><secondary>Ghostscript</secondary></indexterm>
aus ESP Ghostscript 7.05.x als Werkzeug.
</para></listitem>

<listitem><para>
Als zweites kommt der Schritt <parameter>rasterdriver</parameter>. Er verwendet geräte-spezifische Filter; es
gibt einige Hersteller, die Filter guter Qualität für diesen Schritt zur Verfügung stellen. Manche sind freie 
Software, andere Shareware/nicht-frei, manche proprietär.</para></listitem>
</itemizedlist>

<para>
Oft erzeugt dies bessere Qualität (und hat einige Vorteile mehr) als andere Methoden.
</para>

<para>
	<image id="cupsomatic-dia"><imagedescription>cupsomatic/foomatic Verarbeitung versus nativem CUPS.</imagedescription>
		<imagefile>10small</imagefile>
	</image>
</para>

<para>
Eine andere Methode ist der Weg über <parameter>cupsomatic/foomatic-rip</parameter>. Beachten Sie, daß
<parameter>cupsomatic</parameter> <emphasis>nicht</emphasis> von den CUPS-Leuten geschrieben wird. Dies ist ein
unabhängiger Beitrag zur Entwicklung des Druckens von den Leuten von Linuxprinting.org <footnote>sehen Sie auch
<ulink noescape="1" url="http://www.cups.org/cups-help.html">http://www.cups.org/cups-help.html</ulink></footnote>.
<parameter>cupsomatic</parameter> wird nicht mehr entwickelt, gewartet oder unterstützt. Es wurde ersetzt durch
<parameter>foomatic-rip</parameter>. <parameter>foomatic-rip</parameter> ist eine komplette Neufassung der alten
Idee von <parameter>cupsomatic</parameter>, aber sehr stark verbessert und generalisiert, um andere (Nicht-CUPS)
Spooler zu unterstützen. Ein Upgrade auf foomatic-rip ist wärmstens empfohlen, besonders wenn Sie auf eine
aktuelle Version von CUPS aktualisieren.
</para>

<para>
	<indexterm><primary>cupsomatic</primary></indexterm>
	<indexterm><primary>foomatic</primary></indexterm>
Sowohl die Methode <parameter>cupsomatic</parameter> (alt) und die Methode <parameter>foomatic-rip</parameter> 
(neu) von Linuxprinting.org verwenden die traditionelle Ghostscript-Verarbeitung von Druckdateien, die alles
in einem Schritt erledigt. Dies hängt davon ab, daß all die anderen Geräte bereits in Ghostscript eingebaut
sind. Die Qualität ist so gut (oder schlecht), wie Ghostscript-Darstellung in anderen Spoolern ist. Der
Vorteil ist, daß diese Methode viele Drucker-Modelle unterstützt, die (noch) nicht von der moderneren 
CUPS-Methode unterstützt werden.
</para>

<para>
Natürlich können Sie beide Methoden nebeneinander auf einem System einsetzen (und sogar auf einem Drucker, wenn
Sie verschiedene Queues installieren) und herausfinden, welche am Besten für Sie funktioniert.
</para>

<para>
<parameter>cupsomatic</parameter> "kidnappt" die Druckdatei nach der Stufe
<parameter>application/vnd.cups-postscript</parameter> und lenkt es um durch die CUPS-externe, systemweite
Ghostscript-Installation. Daher umgeht die Druckdatei den Filter <parameter>pstoraster</parameter> (und umgeht
auch die CUPS-Raster-Treiber <parameter>rastertosomething</parameter>). Nachdem Ghostscript sein Rastern beendet
hat, übergibt <parameter>cupsomatic</parameter> die dargestellte Datei direkt an das CUPS-Backend. Das 
Flußdiagramm in <link linkend="cupsomatic-dia">cupsomatic/foomatic Verarbeitung versus Nativem CUPS</link>
illustriert den Unterschied zwischen nativer CUPS-Darstellung und der 
<parameter>Foomatic/cupsomatic</parameter>-Methode.
</para>
</sect2>

<sect2>
<title>Beispiele für Filterketten</title>

<para>
Hier ein paar Beispiele für gängige Filterketten, um die Funktion von CUPS zu illustrieren.
</para>

<para>
Nehmen wir an, Sie wollen eine PDF-Datei auf einem per HP JetDirect angeschlossenen PostScript-Drucker drucken,
aber Sie wollen nur die Seiten 3-5, 7, 11-13 drucken, und das mit <quote>two-up</quote> und <quote>Duplex</quote>:
</para>

<itemizedlist>
<listitem><para>Ihre Druck-Optionen (Seitenauswahl, two-up, Duplex) werden an CUPS per Befehlszeile
weitergegeben.</para></listitem>

<listitem><para>Die (komplette) PDF-Datei wird an CUPS gesendet und automatisch als
<parameter>application/pdf</parameter> typisiert.</para></listitem>

<listitem><para>Die Datei muß daher zuerst den Vorfilter <parameter>pdftops</parameter> passieren,
der den PostScript MIME-Typ <parameter>application/postscript</parameter> erzeugt (eine Vorschau an dieser
Stelle würde immer noch alle Seiten des originalen PDFs zeigen).</para></listitem>

<listitem><para>Die Datei passiert sodann den Filter <parameter>pstops</parameter>, der die 
Befehlszeilen-Optionen anwendet: er wählt die Seiten 3-5, 7, und 11-13, legt ein Layout mit
<quote>2 Seiten pro Blatt</quote> an, und fügt den korrekten Befehl für <quote>Duplex</quote> (wie
im PPD des Druckers definiert) in die PostScript-Datei ein; die Datei ist jetzt vom PostScript MIME-Typ
<parameter>application/vnd.cups-postscript</parameter>.</para></listitem>

<listitem><para>Die Datei geht jetzt ans <parameter>socket</parameter>-Backend, das den Auftrag an die
Drucker weiterleitet.</para></listitem>
</itemizedlist>

<para>
Die daraus resultierende Filterkette ist in <link linkend="pdftosocket">Filterkette PDF auf socket</link>
dargestellt.
<image id="pdftosocket"><imagefile>pdftosocket</imagefile><imagedescription>Filterkette PDF auf socket</imagedescription></image>
</para>

<para>
Nehmen wir an, Sie wollen aus dem selben Filter auf einen an USB angeschlossenen Epson Stylus Photo 
Drucker drucken, der mittels dem CUPS-PPD <filename>stphoto2.ppd</filename> installiert wurde. Die
ersten paar Filter-Stufen sind fast die selben:
</para>

<itemizedlist>
<listitem><para>Ihre Druck-Optionen (Seitenauswahl, two-up, Duplex) werden an CUPS per Befehlszeile
weitergegeben.</para></listitem>

<listitem><para>Die (komplette) PDF-Datei wird an CUPS gesendet und automatisch als
<parameter>application/pdf</parameter> typisiert.</para></listitem>

<listitem><para>Die Datei muß daher zuerst den Vorfilter <parameter>pdftops</parameter> passieren,
der den PostScript MIME-Typ <parameter>application/postscript</parameter> erzeugt (eine Vorschau an dieser
Stelle würde immer noch alle Seiten des originalen PDFs zeigen).</para></listitem>

<listitem><para>Die Datei passiert sodann den Filter <parameter>pstops</parameter>, der die
Befehlszeilen-Optionen anwendet: er wählt die Seiten 3-5, 7, und 11-13, legt ein Layout mit
<quote>2 Seiten pro Blatt</quote> an, und fügt den korrekten Befehl für <quote>Duplex</quote> ...
(Oops &smbmdash; dieser Drucker und diese PPD unterstützen gar keinen Duplex-Druck &smbmdash; also wird
diese Option ignoriert) in die PostScript-Datei ein; die Datei ist jetzt vom PostScript MIME-Typ
<parameter>application/vnd.cups-postscript</parameter>.</para></listitem>

<listitem><para>Die Datei passiert jetzt die Filter-Stufe <parameter>pstoraster</parameter> und wird
zum MIME-Typ <parameter>application/cups-raster</parameter>.</para></listitem>

<listitem><para>Zuletzt tut der Filter <parameter>rastertoepson</parameter> seine Arbeit (wie in der PPD
des Druckers angezeigt), legt die drucker-spezifischen Rasterdaten an, und bettet alle vom Benutzer
gewählten Druck-Optionen in die Druckdaten ein.</para></listitem>

<listitem><para>Die Datei geht an das Backend <parameter>usb</parameter>, das es an die Drucker 
weiterleitet.</para></listitem>
</itemizedlist>

<para>
Die daraus resultierende Filterkette ist in <link linkend="pdftoepsonusb">diesem Bild</link> dargestellt.
</para>

<image id="pdftoepsonusb"><imagefile>pdftoepsonusb</imagefile><imagedescription>Filterkette PDF auf USB.</imagedescription></image>
</sect2>

<sect2>
<title>Quellen für CUPS Treiber/PPDs</title>

<para>
Im Internet finden Sie viele tausend CUPS-PPD-Dateien (mit ihren begleitenden Filtern), in vielen Landessprachen
und mit Unterstützung für über tausend nicht-PostScript-Modelle.
</para>

<itemizedlist>
<indexterm><primary>ESP</primary><secondary>Print Pro</secondary></indexterm>
<indexterm><primary>PrintPro</primary><see>ESP Print Pro</see></indexterm>
<listitem><para><ulink url="http://wwwl.easysw.com/printpro/">ESP
PrintPro</ulink> (kommerziell, nicht frei) wird mit mehr als 3000 PPDs gebündelt, fertig zur erfolgreichen
Anwendung <quote>out of the box</quote> auf Linux, Mac OS X, IBM-AIX, HP-UX, Sun-Solaris, SGI-IRIX, 
Compaq Tru64, Digital UNIX, und noch einigen kommerziellen Unices (es wurde von den CUPS-Entwicklern selbst
geschrieben und sein Verkauf hilft dabei, die weitere Entwicklung von CUPS zu finanzieren, genauso, wie es
dessen Schöpfer ernährt).</para></listitem>

<listitem><para>Das <ulink
url="http://gimp-print.sourceforge.net/">Gimp-Print-Project
</ulink> (GPL, freie Software) bietet ungefähr 140 PPDs (mit Unterstützung von fast 400 Druckern, viele davon
bis zu Foto-Qualität), zur Nutzung neben den Gimp-Print CUPS Filtern.</para></listitem>

<listitem><para><ulink url="http://www.turboprint.com/">TurboPrint
</ulink> (Shareware, nicht frei) unterstützt ungefähr die selbe Anzahl von Druckern in exzellenter Qualität.
</para></listitem>

<listitem><para><ulink
url="http://www-124.ibm.com/developerworks/oss/linux/projects/omni/">OMNI
</ulink>
(LPGL, frei) ist ein Package von IBM, das mittlerweile Unterstützung für mehr als 400 Drucker enthält,
aus dem Erbe von IBM OS/2 Know-How, portiert auf Linux (CUPS Unterstützung ist derzeit im Beta-Stadium).
</para></listitem>

<listitem><para><ulink url="http://hpinkjet.sourceforge.net/">HPIJS
</ulink> (BSD-artige Lizenz, frei) unterstützt ungefähr 150 Drucker von HP und bietet nun auch exzellente 
Druckqualität (derzeit nur über den Foomatic-Pfad verfügbar).</para></listitem>

<listitem><para><ulink url="http://www.linuxprinting.org/">Foomatic/cupsomatic
</ulink> (LPGL, frei) von Linuxprinting.org bietet PPDs für praktisch jeden auf der Welt bekannten 
Ghostscript-Filter (einschließlich Omni, Gimp-Print und HPIJS).</para></listitem>
</itemizedlist>

</sect2>

<sect2>
<title>Das Drucken mit Interface Scripts</title>

<para>
CUPS unterstützt auch die Verwendung von <quote>interface scripts</quote>, wie man sie von System V AT&amp;T 
Druck-Systemen kennt. Diese werden oft für PCL-Drucker verwendet, von Anwendungen, die PCL-Druckaufträge
erzeugen. Interface scripts sind spezifisch für einzelne Drucker-Modelle. Sie haben eine ähnliche Rolle wie
PPDs für PostScript-Drucker. Interface scripts können die benötigten Escape-Sequenzen in den Druck-Datenstrom
einfügen, wenn der Benutzer einen bestimmten Papierschacht gewählt hat, oder Landscape-Druck, oder A3-Papier,
etc. Interface scripts sind praktisch unbekannt in der Linux-Welt. Auf HP-UX Plattformen werden sie öfter
verwendet. Sie können jedes funktionierende interface script auch mit CUPS verwenden. Installieren Sie einfach
den Drucker mit der Option <command>-i</command>:
</para>

<para><screen>
&rootprompt;<userinput>lpadmin -p pclprinter -v socket://11.12.13.14:9100 \
  -i /path/to/interface-script</userinput>
</screen></para>

<para>
Interface scripts sind vielleicht das <quote>unbekannte Tier</quote> für viele. Nichtsdestotrotz bieten sie mit
CUPS den einfachsten Weg, Ihr eigenes selbstgeschriebenes Filter-Skript oder -Programm in eine bestimmte
Drucker-Queue einzufügen (einige Informationen über die herkömmliche Verwendung von Interface Scripts kann unter
<ulink noescape="1" url="http://playground.sun.com/printing/documentation/interface.html">http://playground.sun.com/printing/documentation/interface.html</ulink> gefunden werden.
</para>
</sect2>

<sect1>
	<title>Netzwerk-Druck (Ausschließlich Windows)</title>

<para>
Netzwerk-Druck umfasst ein weites Feld. Um zu verstehen, was genau mit Samba passiert, wenn es im Auftrag seiner
Windows-Clients druckt, lassen Sie uns zuerst einen Blick auf ein <quote>reines Windows</quote> Setup werfen:
Windows clients mit einem Windows NT Druck-Server.
</para>

<sect2>
<title>Von Windows Clients auf einen NT Druck-Server</title>

<para>
Windows clients, die auf einen NT-basierenden Druck-Server drucken, haben zwei Möglichkeiten. Sie können:
<indexterm><primary>GDI</primary></indexterm>
<indexterm><primary>EMF</primary></indexterm>
</para>


<itemizedlist>
	<listitem><para>den Treiber lokal ausführen und die GDI-Ausgabe (EMF) selbst im Drucker-spezifischen
			Format darstellen.
	</para></listitem>

	<listitem><para>die GDI-Ausgabe (EMF) an den Server senden, wo der Treiber ausgeführt wird, um die
			Drucker-spezifische Ausgabe darzustellen.
	</para></listitem>
</itemizedlist>

<para>
Die beiden Druck-Möglichkeiten werden in den Flußdiagrammen 
<link linkend="small11">Treiberausführung auf dem Client</link>
und <link linkend="small12">Treiberausführung auf dem Server</link> gezeigt.
</para>
</sect2>

<sect2>
<title>Treiberausführung auf dem Client</title>

<para>
Im ersten Fall muß der Druck-Server die Datei als raw behandeln, das bedeutet, es sollte die Auftragsdatei nicht
anrühren oder in irgendeiner Art zu konvertieren versuchen. Dies ist, was ein herkömmlicher UNIX-basierender
Druck-Server auch tun kann, und das bei besserer Performance und stabiler als ein NT Druck-Server. Damit
sind wohl die meisten Samba-Administratoren vertraut. Ein Vorteil dieses Setups ist, daß dieser
<quote>spooling-only</quote> Druck-Server sogar verwendet werden kann, wenn kein(e) Treiber für UNIX
verfügbar sind, es genügt, die Windows-Treiber zur Verfügung und auf den Clients installiert zu haben.
</para>

<para>
	<image id="small11"><imagedescription>Treiberausführung auf dem Client.</imagedescription>
		<imagefile>11small</imagefile>
	</image>
</para>
</sect2>

<sect2>
<title>Treiberausführung auf dem Server</title>


<para>
<indexterm><primary>PostScript</primary></indexterm>
<indexterm><primary>PCL</primary></indexterm>
<indexterm><primary>ESC/P</primary></indexterm>
<indexterm><primary>EMF</primary></indexterm>
<indexterm><primary>GDI</primary></indexterm>
Der andere Pfad führt den Drucker-Treiber auf dem Server aus. Der Client übermittelt Druckdateien im EMF-Format
an den Server. Der Server verwendet den PostScript, PCL, ESC/P oder einen anderen Treiber, um die EMF-Datei in
die drucker-spezifische Sprache zu konvertieren. Es ist UNIX nicht möglich, dasselbe zu tun. Derzeit gibt es
kein Programm und keine Methode, um die GDI-Ausgabe eines Windows-Clients auf einem UNIX-Server auf etwas zu
wandeln, das ein Drucker verstehen könnte.
</para>

<para>
	<image id="small12"><imagedescription>Treiberausführung auf dem Server.</imagedescription>
		<imagefile>12small</imagefile>
	</image>
</para>

<para>
Jedoch ist etwas Ähnliches mit CUPS möglich. Lesen Sie weiter.
</para>
</sect2>
</sect1>

<sect1>
<title>Netzwerk-Druck (Windows Clients &smbmdash; UNIX/Samba Druck-Server)</title>

<para>
Da UNIX Server den Win32 Programm-Code <emphasis>NICHT</emphasis> auf ihrer Plattform ausführen können, ist
die Sache etwas anders. Dies schränkt jedoch Ihre Möglichkeiten nicht allzu sehr ein. Im Gegenteil, Sie haben
hier die Möglichkeit, Druckoptionen zu implementieren, die anderswo nicht möglich sind.
</para>

<sect2>
<title>Von Windows Clients auf einen CUPS/Samba Druck-Server</title>

<para>
Hier ist ein einfaches Rezept, das zeigt, wie Sie Vorteile aus den mächtigen Eigenschaften von CUPS ziehen, zum
Nutzen Ihrer druckenden Windows Clients:
</para>

<itemizedlist>

<listitem><para>Lassen Sie die Windows Clients PostScript an den CUPS Server senden.</para></listitem>

<listitem><para>Lassen Sie den CUPS Server das PostScript in ein geräte-spezifisches Format wandeln.</para></listitem>
</itemizedlist>

<para>
Dies erfordert, daß die Clients einen PostScript-Treiber verwenden (sogar wenn der Drucker kein PostScript-Modell
ist). Es erfordert auch, daß Sie einen Treiber auf dem CUPS-Server haben.
</para>

<para>
Zuerst, um CUPS-basierendes Drucken per Samba zu aktivieren, sollten folgende Optionen im Abschitt
[global] Ihrer Datei &smb.conf; gesetzt werden:
</para>

<smbconfblock>
<smbconfoption><name>printing</name><value>cups</value></smbconfoption>
<smbconfoption><name>printcap</name><value>cups</value></smbconfoption>
</smbconfblock>

<para>
Wenn diese Parameter angegeben werden, werden alle manuell gesetzten Druck-Anweisungen (wie
<smbconfoption><name>print command</name></smbconfoption> oder 
<smbconfoption><name>lppause command</name></smbconfoption>) in &smb.conf; (genauso wie in Samba selbst)
ignoriert. Stattdessen arbeitet Samba direkt mit CUPS zusammen, unter Verwendung dessen 
"application program interface" (API), sofern Samba mit Unterstützung der CUPS-Bibliothek (libcups) kompiliert
wurde. Wenn Samba nicht mit CUPS-Unterstützung kompiliert wurde, und wenn keine anderen Druckbefehle gesetzt 
sind, wird der Druck den <emphasis>System V</emphasis> AT&amp;T Befehlssatz verwenden, mit der automatisch
gesetzten Option -oraw, womit Druckaufträge einfach weitergegeben werden (wenn Sie Ihre selbstdefinierten
Druckbefehle mit einem Samba-Server, der CUPS-Unterstützung einkompiliert hat, verwenden wollen, verwenden Sie
einfach <smbconfoption><name>printing</name><value>sysv</value></smbconfoption>).
</para>

<para>
<image><imagedescription>Drucken über einen CUPS/Samba Server.</imagedescription>
	<imagefile>13small</imagefile>
</image>
</para>
</sect2>

<sect2>
<title>Samba empfängt Aufträge und gibt sie an CUPS weiter</title>

<para>
Samba <emphasis>muss</emphasis> sein eigenes Spooling-Verzeichnis verwenden (es wird mit einer Zeile wie
<smbconfoption><name>path</name><value>/var/spool/samba</value></smbconfoption> im Abschnitt
<smbconfsection>[printers]</smbconfsection> oder <smbconfsection>[printername]</smbconfsection> von
&smb.conf; gesetzt). Samba empfängt den Auftrag in seinem eigenen Spooling-Verzeichnis und gibt ihn weiter ins
Spooling-Verzeichnis von CUPS (das CUPS-Spooling-Verzeichnis wird gesetzt mittels der Anweisung
<parameter>RequestRoot</parameter>, in einer Zeile die voreingestellt 
<parameter>RequestRoot /var/spool/cups</parameter> lautet). CUPS prüft die Zugriffsrechte und setzt diese auf
vernünftige Werte, bei jedem Neustart. Wir haben schon ziemlich viele Leute gesehen, die ein gemeinsames
Spooling-Verzeichnis verwendet haben, und wochenlang mit diesem <quote>Problem</quote> zu kämpfen hatten.
</para>

<para>
Ein Windows-Benutzer authentifiziert sich nur gegen Samba (mittels dessen, was konfiguriert wurde). Wenn Samba
auf demselben Host wie CUPS läuft, brauchen Sie nur dem Rechner <quote>localhost</quote> zu erlauben, zu drucken.
Wenn sie auf verschiedenen Maschinen laufen, müssen Sie sicherstellen, daß der Samba-Host Zugriff auf das Drucken
auf CUPS hat.
</para>
</sect2>
</sect1>

<sect1>
<title>Netzwerk PostScript RIP</title>

<para>
Dieser Abschnitt behandelt die Verwendung von CUPS-Filtern auf der Server &smbmdash; Konfiguration, in der
Clients einen PostScript-Treiber mit CUPS-PPDs verwenden.
</para>


<para>
<indexterm><primary>PostScript</primary></indexterm>
<indexterm><primary>PCL</primary></indexterm>
<indexterm><primary>PJL</primary></indexterm>
PPDs können alle Optionen des Drucker-Geräts kontrollieren. Sie werden üblicherweise vom Hersteller
bereitgestellt, wenn Sie einen PostScript-Drucker besitzen. PPD-Dateien ((PostScript Printer Descriptions)
sind immer Bestandteil der Druckertreiber auf MS Windows oder Apple Mac OS Systemen. Es sind ASCII-Dateien,
die vom Benutzer wählbare Druckoptionen enthalten, sowie deren Zuweisung auf die enstprechenden PostScript, PCL
oder PJL Befehle für das Ziel-Gerät. Die GUI-Dialoge der Druckertreiber übersetzen diese Optionen
<quote>on-the-fly</quote> in Schaltflächen und Auswahllisten, um dem Benutzer eine Auswahl anzubieten.
</para>

<para>
CUPS kann ohne jede Umwandlung PPD-Dateien von jedem Windows-PS-Treiber (NT wird empfohlen) und dessen Optionen
verarbeiten. Es gibt ein Web-Interface zu den Druck-Optionen (gehen Sie auf
<ulink noescape="1" url="http://localhost:631/printers/">http://localhost:631/printers/</ulink> und klicken Sie
auf eine <guibutton>Configure Printer</guibutton>-Schaltfläche) oder ein Befehlszeilen-Interface (sehen Sie dazu
<command>man lpoptions</command> oder prüfen Sie, ob Sie <command>lphelp</command> auf Ihrem System haben). Es
gibt auch ein paar verschiedene GUI Front-ends für Linux/UNIX, die PPD-Optionen darstellen können. PPD-Optionen
sind normalerweise zur Interpretation durch den PostScript RIP auf dem PostScript-Drucker gedacht.
</para>

<sect2>
<title>PPDs für Nicht-PS-Drucker auf UNIX</title>


<para>
<indexterm><primary>PPD</primary></indexterm>
CUPS beschränkt sich nicht auf <quote>wirkliche</quote> PostScript-Drucker in seiner Verwendung von PPDs. Die 
CUPS-Entwickler haben die Reichweite des PPD-Konzepts erweitert, um auch verfügbare Geräte- und Treiber-Optionen
von Nicht-PS-Druckern durch CUPS-PPDs zu beschreiben.
</para>

<para>
Dies ist nur logisch, da CUPS einen voll ausgestatteten PostScript Interpreter (RIP) umfaßt. Dieser RIP basiert
auf Ghostscript. Er kann alles empfangene PostScript (und zusätzlich viele weitere Dateiformate) verarbeiten.
Alle CUPS-PPDs für Nicht-PS-Drucker enthalten eine zusätzliche Zeile, die mit dem Schlüsselwort
<parameter>*cupsFilter</parameter> beginnt. Diese Zeile teilt dem CUPS-Druck-Systemmit, welcher 
drucker-spezifische Filter zur Interpretation der PostScript-Daten verwendet werden soll. Daher läßt CUPS
alle seine Drucker für die Clients als PostScript-Drucker erscheinen, weil es als PostScript RIP für diese
Drucker arbeiten kann.
</para>
</sect2>

<sect2>
<title>PPDs für Nicht-PS-Drucker auf Windows</title>

<para>
<indexterm><primary>PPD</primary></indexterm>
CUPS-PPDs können auch auf Windows-Clients verwendet werden, am <quote>Rücken</quote> eines <quote>core</quote>
PostScript-Treibers (derzeit wird der "CUPS PostScript Driver for Windows NT/200x/XP" empfohlen; Sie können auch
den von Adobe verwenden, mit Einschränkungen). Dieses Feature ermöglicht es CUPS, einige Tricks zu beherrschen,
die kein anderer Spooler kann:
</para>

<itemizedlist>

<listitem><para>Das Arbeiten als ein vernetzter PostScript RIP (Raster Image Processor),
der Druckdateien von allen Client-Plattformen in einer einheitlichen Weise handhabt.
</para></listitem>

<listitem><para>Das Arbeiten als zentraler Ab- und Verrechnungs-Server, da alle Dateien durch den pstops-Filter
laufen und daher in der CUPS-Datei <filename>page_log</filename> protokolliert werden.
<emphasis>Anmerkung:</emphasis>Dies kann nicht für <quote>raw</quote> Druckaufträge erfolgen, da diese ja per
definitionem ungefiltert bleiben.</para></listitem>

<listitem><para>Das Ermöglichen einer Einigung und Festlegung eines einzelnen PostScript-Treibers für die
Clients, sogar für viele verschiedene Ziel-Drucker.</para></listitem>
</itemizedlist>

<para>
Die Verwendung von CUPS PPDs auf Windows-Clients ermöglicht es diesen, alle Druckauftrags-Einstellungen so
zu kontrollieren, wie es ein UNIX-Client kann.
</para>
</sect2>
</sect1>

<sect1>
<title>Windows Terminal Server (WTS) als CUPS Clients</title>

<para>
Dieses Setup wird für diejenigen interessant sein, die grosse Probleme in WTS-Umgebungen haben. WTS braucht oft
eine Vielzahl von Nicht-PS-Treibern installiert, um die Vielfalt der verschiedenen Druckermodelle der CLients
zu unterstützen. Dies bringt oft eine stark erhöhte Instabilität mit sich.
</para>

<sect2>
<title>Drucker-Treiber, die im <quote>Kernel Modus</quote> laufen, verursachen viele Probleme</title>

<para>
In Windows NT bringen Drucker-Treiber, die im <quote>Kernel Modus</quote> laufen, ein hohes Risiko für die
Stabilität des Systems mit sich, wenn der Treiber nicht wirklich stabil und gut getestet ist. Und es gibt eine
Menge schlechte Treiber! Speziell berüchtigt ist das Beispiel des PCL-Drucker-Treibers, der ein zusätzliches
Sound-Modul ausführte, das die Benutzer via Soundkarte über ihre abgeschlossenen Druckaufträgen informierte.
Muß ich wirklich erwähnen, daß dies genauso verlässlich <quote>blue screens of death</quote> verursachte?
</para>

<para>
PostScript-Treiber sind im Allgemeinen gut getestet. Sie sind nicht dafür bekannt, irgendwelche Probleme zu
verursachen, sogar trotzdem sie auch im Kernel-Modus ausgeführt werden. Das kann daher kommen, daß es bislang
nur zwei verschiedene PostScript-Treiber gab: die von Adobe und den von Microsoft. Beide sind gut getestet und
so stabil, wie es unter Windows eben geht. Der CUPS-Treiber ist von dem MS-Treiber abgeleitet.
</para>
</sect2>

<sect2>
<title>Workarounds Impose Heavy Limitations</title>

<para>
In many cases, in an attempt to work around this problem, site
administrators have resorted to restricting the allowed drivers installed
on their WTS to one generic PCL and one PostScript driver. This,
however, restricts the clients in the number of printer options
available for them. Often they can't get out more than simplex
prints from one standard paper tray, while their devices could do much
better, if driven by a different driver!
</para>
</sect2>

<sect2>
<title>CUPS: A <quote>Magical Stone</quote>?</title>


<para>
<indexterm><primary>PPD</primary></indexterm>
<indexterm><primary>PostScript</primary></indexterm>
Using a PostScript driver, enabled with a CUPS-PPD, seems to be a very
elegant way to overcome all these shortcomings. There are, depending
on the version of Windows OS you use, up to three different PostScript
drivers available: Adobe, Microsoft and CUPS PostScript drivers. None
of them is known to cause major stability problems on WTS (even if
used with many different PPDs). The clients will be able to (again)
chose paper trays, duplex printing and other settings. However, there
is a certain price for this too: a CUPS server acting as a PostScript
RIP for its clients requires more CPU and RAM than when just acting as
a <quote>raw spooling</quote> device. Plus, this setup is not yet widely tested,
although the first feedbacks look very promising.
</para>
</sect2>

<sect2>
<title>PostScript Drivers with No Major Problems &smbmdash; Even in Kernel
Mode</title>

<para>
<indexterm><primary>DDK</primary></indexterm>
More recent printer drivers on W200x and XP no longer run in kernel mode
(unlike Windows NT). However, both operating systems can still
use the NT drivers, running in kernel mode (you can roughly tell which
is which as the drivers in subdirectory <quote>2</quote> of <quote>W32X86</quote> are <quote>old</quote>
ones). As was said before, the Adobe as well as the Microsoft
PostScript drivers are not known to cause any stability problems. The
CUPS driver is derived from the Microsoft one. There is a simple
reason for this: The MS DDK (Device Development Kit) for Windows NT (which
used to be available at no cost to licensees of Visual Studio)
includes the source code of the Microsoft driver, and licensees of
Visual Studio are allowed to use and modify it for their own driver
development efforts. This is what the CUPS people have done. The
license does not allow them to publish the whole of the source code.
However, they have released the <quote>diff</quote> under the GPL, and if you are
the owner of an <quote>MS DDK for Windows NT,</quote> you can check the driver yourself.
</para>
</sect2>
</sect1>

<sect1>
<title>Configuring CUPS for Driver Download</title>

<para>
As we have said before, all previously known methods to prepare client
printer drivers on the Samba server for download and Point'n'Print
convenience of Windows workstations are working with CUPS, too. These
methods were described in the previous chapter. In reality, this is a
pure Samba business and only relates to the Samba/Windows client
relationship.
</para>

<sect2>
<title><emphasis>cupsaddsmb</emphasis>: The Unknown Utility</title>


<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
The <command>cupsaddsmb</command> utility (shipped with all current CUPS versions) is an
alternate method to transfer printer drivers into the Samba
<smbconfsection>[print$]</smbconfsection> share. Remember, this share is where
clients expect drivers deposited and setup for download and
installation. It makes the sharing of any (or all) installed CUPS
printers quite easy. <command>cupsaddsmb</command> can use the Adobe PostScript driver as
well as the newly developed CUPS PostScript Driver for
Windows NT/200x/XP. <parameter>cupsaddsmb</parameter> does
<emphasis>not</emphasis> work with arbitrary vendor printer drivers,
but only with the <emphasis>exact</emphasis> driver files that are
named in its man page.
</para>

<para>
The CUPS printer driver is available from the CUPS download site. Its
package name is <filename>cups-samba-[version].tar.gz</filename> . It
is preferred over the Adobe drivers since it has a number of
advantages:
</para>

<itemizedlist>
<listitem><para>It supports a much more accurate page
accounting.</para></listitem>

<listitem><para>It supports banner pages, and page labels on all
printers.</para></listitem>

<listitem><para>It supports the setting of a number of job IPP
attributes (such as job-priority, page-label and
job-billing).</para></listitem>
</itemizedlist>

<para>
However, currently only Windows NT, 2000 and XP are supported by the
CUPS drivers. You will also need to get the respective part of Adobe driver
if you need to support Windows 95, 98 and ME clients.
</para>
</sect2>

<sect2>
	<title>Prepare Your &smb.conf; for <command>cupsaddsmb</command></title>

<para>
Prior to running <command>cupsaddsmb</command>, you need the settings in
&smb.conf; as shown in <link linkend="cupsadd-ex">the next example</link>:
</para>

<para><smbconfexample id="cupsadd-ex">
<title>smb.conf for cupsaddsmb usage</title>
<smbconfsection>[global]</smbconfsection>
<smbconfoption><name>load printers</name><value>yes</value></smbconfoption>
<smbconfoption><name>printing</name><value>cups</value></smbconfoption>
<smbconfoption><name>printcap name</name><value>cups</value></smbconfoption>

<smbconfsection>[printers]</smbconfsection>
<smbconfoption><name>comment</name><value>All Printers</value></smbconfoption>
<smbconfoption><name>path</name><value>/var/spool/samba</value></smbconfoption>
<smbconfoption><name>browseable</name><value>no</value></smbconfoption>
<smbconfoption><name>public</name><value>yes</value></smbconfoption>
<smbconfcomment>setting depends on your requirements</smbconfcomment>
<smbconfoption><name>guest ok</name><value>yes</value></smbconfoption>
<smbconfoption><name>writable</name><value>no</value></smbconfoption>
<smbconfoption><name>printable</name><value>yes</value></smbconfoption>
<smbconfoption><name>printer admin</name><value>root</value></smbconfoption>
 <smbconfsection>[print$]</smbconfsection>
<smbconfoption><name>comment</name><value>Printer Drivers</value></smbconfoption>
<smbconfoption><name>path</name><value>/etc/samba/drivers</value></smbconfoption>
<smbconfoption><name>browseable</name><value>yes</value></smbconfoption>
<smbconfoption><name>guest ok</name><value>no</value></smbconfoption>
<smbconfoption><name>read only</name><value>yes</value></smbconfoption>
<smbconfoption><name>write list</name><value>root</value></smbconfoption>
</smbconfexample></para>
</sect2>

<sect2>
<title>CUPS <quote>PostScript Driver for Windows NT/200x/XP</quote></title>

<para>
<indexterm><primary>PostScript</primary></indexterm>
CUPS users may get the exact same packages from <ulink
noescape="1" url="http://www.cups.org/software.html">http://www.cups.org/software.html</ulink>.
It is a separate package from the CUPS base software files, tagged as
CUPS 1.1.x Windows NT/200x/XP Printer Driver for Samba
(tar.gz, 192k). The filename to download is
<filename>cups-samba-1.1.x.tar.gz</filename>. Upon untar and unzipping,
it will reveal these files:
</para>

<para><screen>
&rootprompt;<userinput>tar xvzf cups-samba-1.1.19.tar.gz</userinput>
cups-samba.install
cups-samba.license
cups-samba.readme
cups-samba.remove
cups-samba.ss
</screen></para>

<para>
<indexterm><primary>ESP</primary><secondary>meta packager</secondary></indexterm>
<indexterm><primary>EPM</primary><see>ESP meta packager</see></indexterm>
These have been packaged with the ESP meta packager software
EPM. The <filename>*.install</filename> and
<filename>*.remove</filename> files are simple shell scripts, which
untars the <filename>*.ss</filename> (the <filename>*.ss</filename> is
nothing else but a tar-archive, which can be untarred by <quote>tar</quote>
too). Then it puts the content into
<filename>/usr/share/cups/drivers/</filename>. This content includes three
files:
</para>

<para><screen>
&rootprompt;<userinput>tar tv cups-samba.ss</userinput>
cupsdrvr.dll
cupsui.dll
cups.hlp  
</screen></para>

<para>
The <parameter>cups-samba.install</parameter> shell scripts are easy to
handle:
</para>

<para><screen>
&rootprompt;<userinput>./cups-samba.install</userinput>
[....]
Installing software...
Updating file permissions...
Running post-install commands...
Installation is complete.       
</screen></para>

<para>
The script should automatically put the driver files into the
<filename>/usr/share/cups/drivers/</filename> directory.
</para>

<warning><para>
Due to a bug, one recent CUPS release puts the
<filename>cups.hlp</filename> driver file
into<filename>/usr/share/drivers/</filename> instead of
<filename>/usr/share/cups/drivers/</filename>. To work around this,
copy/move the file (after running the
<command>./cups-samba.install</command> script) manually to the
correct place.
</para></warning>

<para><screen>
&rootprompt;<userinput>cp /usr/share/drivers/cups.hlp /usr/share/cups/drivers/</userinput>
</screen></para>


<para>
<indexterm><primary>DDK</primary></indexterm>
This new CUPS PostScript driver is currently binary-only, but free of
charge. No complete source code is provided (yet). The reason is that
it has been developed with the help of the Microsoft Driver
Developer Kit (DDK) and compiled with Microsoft Visual
Studio 6. Driver developers are not allowed to distribute the whole of
the source code as free software. However, CUPS developers released
the <quote>diff</quote> in source code under the GPL, so anybody with a license of
Visual Studio and a DDK will be able to compile for him/herself.
</para>
</sect2>

<sect2>
<title>Recognizing Different Driver Files</title>

<para>
The CUPS drivers do not support the older Windows 95/98/Me, but only
the Windows NT/2000/XP client.
</para>

<para>Windows NT, 2000 and XP are supported by:</para>

<para>
	<itemizedlist>
		<listitem>cups.hlp</listitem>
		<listitem>cupsdrvr.dll</listitem>
		<listitem>cupsui.dll</listitem>
	</itemizedlist>
</para>

<para>
Adobe drivers are available for the older Windows 95/98/Me as well as
the Windows NT/2000/XP clients. The set of files is different from the
different platforms.
</para>

<para>Windows 95, 98 and ME are supported by:</para>

<para>
	<itemizedlist>
	<listitem>ADFONTS.MFM</listitem>
	<listitem>ADOBEPS4.DRV</listitem>
	<listitem>ADOBEPS4.HLP</listitem>
	<listitem>DEFPRTR2.PPD</listitem>
	<listitem>ICONLIB.DLL</listitem>
	<listitem>PSMON.DLL</listitem>
</itemizedlist>
</para>

<para>Windows NT, 2000 and XP are supported by:</para>

<para>
<itemizedlist>
	<listitem>ADOBEPS5.DLL</listitem>
	<listitem>ADOBEPSU.DLL</listitem>
	<listitem>ADOBEPSU.HLP</listitem>
</itemizedlist>

</para>

<note><para>
If both the Adobe driver files and the CUPS driver files for the
support of Windows NT/200x/XP are present in FIXME, the Adobe ones will be ignored
and the CUPS ones will be used. If you prefer &smbmdash; for whatever reason
&smbmdash; to use Adobe-only drivers, move away the three CUPS driver files. The
Windows 9x/Me clients use the Adobe drivers in any case.
</para></note>
</sect2>

<sect2>
<title>Acquiring the Adobe Driver Files</title>

<para>
Acquiring the Adobe driver files seems to be unexpectedly difficult
for many users. They are not available on the Adobe Web site as single
files and the self-extracting and/or self-installing Windows-.exe is
not easy to locate either. Probably you need to use the included
native installer and run the installation process on one client
once. This will install the drivers (and one Generic PostScript
printer) locally on the client. When they are installed, share the
Generic PostScript printer. After this, the client's
<smbconfsection>[print$]</smbconfsection> share holds the Adobe files, from
where you can get them with smbclient from the CUPS host. 
</para>
</sect2>

<sect2>
<title>ESP Print Pro PostScript Driver for Windows NT/200x/XP</title>



<para>
<indexterm><primary>ESP</primary><secondary>Print Pro</secondary></indexterm>
Users of the ESP Print Pro software are able to install their Samba
drivers package for this purpose with no problem. Retrieve the driver
files from the normal download area of the ESP Print Pro software
at <ulink
	noescape="1" url="http://www.easysw.com/software.html">http://www.easysw.com/software.html</ulink>.
You need to locate the link labeled <quote>SAMBA</quote> among the
<guilabel>Download Printer Drivers for ESP Print Pro 4.x</guilabel>
area and download the package. Once installed, you can prepare any
driver by simply highlighting the printer in the Printer Manager GUI
and select <guilabel>Export Driver...</guilabel> from the menu. Of
course you need to have prepared Samba beforehand to handle the
driver files; i.e., setup the <smbconfsection>[print$]</smbconfsection>
share, and so on. The ESP Print Pro package includes the CUPS driver files
as well as a (licensed) set of Adobe drivers for the Windows 95/98/Me
client family.
</para>
</sect2>

<sect2>
<title>Caveats to be Considered</title>


<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
Once you have run the install script (and possibly manually
moved the <filename>cups.hlp</filename> file to
<filename>/usr/share/cups/drivers/</filename>), the driver is
ready to be put into Samba's <smbconfsection>[print$]</smbconfsection> share (which often maps to
<filename>/etc/samba/drivers/</filename> and contains a subdirectory
tree with <emphasis>WIN40</emphasis> and
<emphasis>W32X86</emphasis> branches). You do this by running
<command>cupsaddsmb</command> (see also <command>man cupsaddsmb</command> for
CUPS since release 1.1.16).
</para>

<tip><para>
<indexterm><primary>Single Sign On</primary></indexterm>
You may need to put root into the smbpasswd file by running
<command>smbpasswd</command>; this is especially important if you
should run this whole procedure for the first time, and are not
working in an environment where everything is configured for
<emphasis>single sign on</emphasis> to a Windows Domain Controller.
</para></tip>

<para>
Once the driver files are in the <smbconfsection>[print$]</smbconfsection> share
and are initialized, they are ready to be downloaded and installed by
the Windows NT/200x/XP clients.
</para>

<note><para>
Win 9x/Me clients will not work with the CUPS PostScript driver. For
these you still need to use the <filename>ADOBE*.*</filename>
drivers as previously stated.
</para></note>

<note>
<para>
It is not harmful if you still have the
<filename>ADOBE*.*</filename> driver files from previous
installations in the <filename>/usr/share/cups/drivers/</filename>
directory. The new <command>cupsaddsmb</command> (from 1.1.16) will
automatically prefer its own drivers if it finds both.
</para></note>

<note><para>
<indexterm><primary>"Printers" folder</primary></indexterm>
Should your Windows clients have had the old <filename>ADOBE*.*</filename>
files for the Adobe PostScript driver installed, the download and
installation of the new CUPS PostScript driver for Windows NT/200x/XP
will fail at first. You need to wipe the old driver from the clients
first. It is not enough to <quote>delete</quote> the printer, as the driver files
will still be kept by the clients and re-used if you try to re-install
the printer. To really get rid of the Adobe driver files on the
clients, open the <guilabel>Printers</guilabel> folder (possibly via <guilabel>Start > Settings > Control Panel > Printers</guilabel>),
right-click on the folder background and select <guimenuitem>Server
Properties</guimenuitem>. When the new dialog opens, select the
<guilabel>Drivers</guilabel> tab. On the list select the driver you
want to delete and click the <guilabel>Delete</guilabel>
button. This will only work if there is not one single printer left
that uses that particular driver. You need to <quote>delete</quote> all printers
using this driver in the <guilabel>Printers</guilabel> folder first. You will need
Administrator privileges to do this.
</para></note>

<note><para>
<indexterm><primary>rpcclient</primary><secondary>setdriver</secondary></indexterm>
Once you have successfully downloaded the CUPS PostScript driver to a
client, you can easily switch all printers to this one by proceeding
as described in <link linkend="printing">Classical Printing Support</link>. Either change
a driver for an existing printer by running the <guilabel>Printer Properties</guilabel>
dialog, or use <command>rpcclient</command> with the
<command>setdriver</command> subcommand.
</para></note>
</sect2>

<sect2>
<title>Windows CUPS PostScript Driver Versus Adobe Driver</title>

<para>
Are you interested in a comparison between the CUPS and the Adobe
PostScript drivers? For our purposes these are the most important
items that weigh in favor of the CUPS ones:
</para>

<itemizedlist>
<listitem><para>No hassle with the Adobe EULA.</para></listitem>

<listitem><para>No hassle with the question <quote>Where do I
get the ADOBE*.* driver files from?</quote></para></listitem>

<listitem><para>
<indexterm><primary>PJL</primary></indexterm>
The Adobe drivers (on request of the printer PPD
associated with them) often put a PJL header in front of the main
PostScript part of the print file. Thus, the printfile starts with
<parameter>&lt;1B &gt;%-12345X</parameter> or
<parameter>&lt;escape&gt;%-12345X</parameter> instead
of <parameter>%!PS</parameter>). This leads to the
CUPS daemon auto-typing the incoming file as a print-ready file,
not initiating a pass through the <parameter>pstops</parameter> filter (to speak more
technically, it is not regarded as the generic MIME-type 
<indexterm><primary>application/postscript</primary></indexterm>
<parameter>application/postscript</parameter>, but as
the more special MIME type
<indexterm><primary>application/cups.vnd-postscript</primary></indexterm>
<parameter>application/cups.vnd-postscript</parameter>),
which therefore also leads to the page accounting in
<parameter>/var/log/cups/page_log</parameter> not
receiving the exact number of pages; instead the dummy page number
of <quote>1</quote> is logged in a standard setup).</para></listitem>

<listitem><para>The Adobe driver has more options to mis-configure the
PostScript generated by it (like setting it inadvertently to
<guilabel>Optimize for Speed</guilabel>, instead of
<guilabel>Optimize for Portability</guilabel>, which
could lead to CUPS being unable to process it).</para></listitem>

<listitem><para>The CUPS PostScript driver output sent by Windows
clients to the CUPS server is guaranteed to auto-type 
as the generic MIME type <parameter>application/postscript</parameter>,
thus passing through the CUPS <parameter>pstops</parameter> filter and logging the
correct number of pages in the <filename>page_log</filename> for
accounting and quota purposes.</para></listitem>

<listitem><para>The CUPS PostScript driver supports the sending of
additional standard (IPP) print options by Windows NT/200x/XP clients. Such
additional print options are: naming the CUPS standard
<emphasis>banner pages</emphasis> (or the custom ones, should they be
installed at the time of driver download), using the CUPS
page-label option, setting a
job-priority, and setting the scheduled
time of printing (with the option to support additional
useful IPP job attributes in the future).</para></listitem>

<listitem><para>The CUPS PostScript driver supports the inclusion of
the new <parameter>*cupsJobTicket</parameter> comments at the
beginning of the PostScript file (which could be used in the future
for all sort of beneficial extensions on the CUPS side, but which will
not disturb any other applications as they will regard it as a comment
and simply ignore it).</para></listitem>

<listitem><para>The CUPS PostScript driver will be the heart of the
fully fledged CUPS IPP client for Windows NT/200x/XP to be released soon
(probably alongside the first beta release for CUPS
1.2).</para></listitem>
</itemizedlist>

</sect2>

<sect2>
<title>Run cupsaddsmb (Quiet Mode)</title>


<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
<indexterm><primary>point 'n' print</primary></indexterm>
The <command>cupsaddsmb</command> command copies the needed files into your
<smbconfsection>[print$]</smbconfsection> share. Additionally, the PPD
associated with this printer is copied from
<filename>/etc/cups/ppd/</filename> to
<smbconfsection>[print$]</smbconfsection>. There the files wait for convenient
Windows client installations via Point'n'Print. Before we can run the
command successfully, we need to be sure that we can authenticate
toward Samba. If you have a small network, you are probably using user-level
security (<smbconfoption><name>security</name><value>user</value></smbconfoption>). 
</para>

<para>
Here is an example of a successfully run <command>cupsaddsmb</command> command: 
</para>

<para><screen>
&rootprompt;<userinput>cupsaddsmb -U root infotec_IS2027</userinput>
Password for root required to access localhost via Samba: <userinput>['secret']</userinput>
</screen></para>

<para>
To share <emphasis>all</emphasis> printers and drivers, use the
<option>-a</option> parameter instead of a printer name. Since
<command>cupsaddsmb</command> <quote>exports</quote> the printer drivers to Samba, it should be
obvious that it only works for queues with a CUPS driver associated.
</para>
</sect2>

<sect2>
<title>Run cupsaddsmb with Verbose Output</title>


<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
Probably you want to see what's going on. Use the
<option>-v</option> parameter to get a more verbose output. The
output below was edited for better readability: all <quote>\</quote> at the end of
a line indicate that I inserted an artificial line break plus some
indentation here:
</para>

<warning><para>
You will see the root password for the Samba account printed on
screen. 
</para></warning>

<para>
	
<indexterm><primary>rpcclient</primary><secondary>adddriver</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>setdriver</secondary></indexterm>
	<screen>
&rootprompt;<userinput>cupsaddsmb -U root -v infotec_2105</userinput>
Password for root required to access localhost via &example.server.samba;:
Running command: smbclient //localhost/print\$ -N -U'root%secret' \
    -c 'mkdir W32X86; \
    put /var/spool/cups/tmp/3e98bf2d333b5 W32X86/infotec_2105.ppd; \
	put /usr/share/cups/drivers/cupsdrvr.dll W32X86/cupsdrvr.dll; \
    put /usr/share/cups/drivers/cupsui.dll W32X86/cupsui.dll; \
    put /usr/share/cups/drivers/cups.hlp W32X86/cups.hlp'
added interface ip=10.160.51.60 bcast=10.160.51.255 nmask=255.255.252.0
Domain=[CUPS-PRINT] OS=[UNIX] Server=[Samba 2.2.7a]
NT_STATUS_OBJECT_NAME_COLLISION making remote directory \W32X86
putting file /var/spool/cups/tmp/3e98bf2d333b5 as \W32X86/infotec_2105.ppd
putting file /usr/share/cups/drivers/cupsdrvr.dll as \W32X86/cupsdrvr.dll
putting file /usr/share/cups/drivers/cupsui.dll as \W32X86/cupsui.dll
putting file /usr/share/cups/drivers/cups.hlp as \W32X86/cups.hlp
  
Running command: rpcclient localhost -N -U'root%secret' 
   -c 'adddriver "Windows NT x86"   \
   "infotec_2105:cupsdrvr.dll:infotec_2105.ppd:cupsui.dll:cups.hlp:NULL: \
    RAW:NULL"'
cmd = adddriver "Windows NT x86" \
   "infotec_2105:cupsdrvr.dll:infotec_2105.ppd:cupsui.dll:cups.hlp:NULL: \
	RAW:NULL"
Printer Driver infotec_2105 successfully installed.
  
Running command: smbclient //localhost/print\$ -N -U'root%secret' \
-c 'mkdir WIN40; \
    put /var/spool/cups/tmp/3e98bf2d333b5 WIN40/infotec_2105.PPD; \
	put /usr/share/cups/drivers/ADFONTS.MFM WIN40/ADFONTS.MFM;   \
    put /usr/share/cups/drivers/ADOBEPS4.DRV WIN40/ADOBEPS4.DRV; \
    put /usr/share/cups/drivers/ADOBEPS4.HLP WIN40/ADOBEPS4.HLP; \
    put /usr/share/cups/drivers/DEFPRTR2.PPD WIN40/DEFPRTR2.PPD; \
	put /usr/share/cups/drivers/ICONLIB.DLL WIN40/ICONLIB.DLL; \
	put /usr/share/cups/drivers/PSMON.DLL WIN40/PSMON.DLL;'
  added interface ip=10.160.51.60 bcast=10.160.51.255 nmask=255.255.252.0
  Domain=[CUPS-PRINT] OS=[UNIX] Server=[Samba 2.2.7a]
  NT_STATUS_OBJECT_NAME_COLLISION making remote directory \WIN40
  putting file /var/spool/cups/tmp/3e98bf2d333b5 as \WIN40/infotec_2105.PPD
  putting file /usr/share/cups/drivers/ADFONTS.MFM as \WIN40/ADFONTS.MFM
  putting file /usr/share/cups/drivers/ADOBEPS4.DRV as \WIN40/ADOBEPS4.DRV
  putting file /usr/share/cups/drivers/ADOBEPS4.HLP as \WIN40/ADOBEPS4.HLP
  putting file /usr/share/cups/drivers/DEFPRTR2.PPD as \WIN40/DEFPRTR2.PPD
  putting file /usr/share/cups/drivers/ICONLIB.DLL as \WIN40/ICONLIB.DLL
  putting file /usr/share/cups/drivers/PSMON.DLL as \WIN40/PSMON.DLL
  
  Running command: rpcclient localhost -N -U'root%secret' \
   -c 'adddriver "Windows 4.0"      \
   "infotec_2105:ADOBEPS4.DRV:infotec_2105.PPD:NULL:ADOBEPS4.HLP: \
   PSMON.DLL:RAW:ADOBEPS4.DRV,infotec_2105.PPD,ADOBEPS4.HLP,PSMON.DLL, \
    ADFONTS.MFM,DEFPRTR2.PPD,ICONLIB.DLL"'
	cmd = adddriver "Windows 4.0" "infotec_2105:ADOBEPS4.DRV:\
	infotec_2105.PPD:NULL:ADOBEPS4.HLP:PSMON.DLL:RAW:ADOBEPS4.DRV,\
	infotec_2105.PPD,ADOBEPS4.HLP,PSMON.DLL,ADFONTS.MFM,DEFPRTR2.PPD,\
	ICONLIB.DLL"
  Printer Driver infotec_2105 successfully installed.
  
  Running command: rpcclient localhost -N -U'root%secret'  \
   -c 'setdriver infotec_2105 infotec_2105'
  cmd = setdriver infotec_2105 infotec_2105
  Successfully set infotec_2105 to driver infotec_2105.

</screen></para>

<para>
If you look closely, you'll discover your root password was transferred
unencrypted over the wire, so beware! Also, if you look further,
you'll discover error messages like <?latex \linebreak ?>NT_STATUS_OBJECT_NAME_COLLISION in between. They occur, because the directories WIN40 and W32X86 already existed in the <smbconfsection>[print$]</smbconfsection> driver download share (from a previous driver installation). They are harmless here.
</para>
</sect2>

<sect2>
<title>Understanding cupsaddsmb</title>


<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
What has happened? What did <command>cupsaddsmb</command> do? There are five stages of
the procedure:
</para>

<orderedlist>
	<listitem><para>
	<indexterm><primary>IPP</primary></indexterm>
			Call the CUPS server via IPP and request the
driver files and the PPD file for the named printer.</para></listitem>

<listitem><para>Store the files temporarily in the local
TEMPDIR (as defined in
<filename>cupsd.conf</filename>).</para></listitem>

<listitem><para>Connect via smbclient to the Samba server's
 <smbconfsection>[print$]</smbconfsection> share and put the files into the
 share's WIN40 (for Windows 9x/Me) and W32X86/ (for Windows NT/200x/XP) subdirectories.</para></listitem>

<listitem><para>
<indexterm><primary>rpcclient</primary><secondary>adddriver</secondary></indexterm>
		Connect via rpcclient to the Samba server and
execute the <command>adddriver</command> command with the correct
parameters.</para></listitem>

<listitem><para>
<indexterm><primary>rpcclient</primary><secondary>setdriver</secondary></indexterm>
		Connect via rpcclient to the Samba server a second
time and execute the <command>setdriver</command> command.</para></listitem>
</orderedlist>

<note>
<para>
You can run the <command>cupsaddsmb</command> utility with parameters to
specify one remote host as Samba host and a second remote host as CUPS
host. Especially if you want to get a deeper understanding, it is a
good idea to try it and see more clearly what is going on (though in real
life most people will have their CUPS and Samba servers run on the
same host):
</para>

<para><screen>
&rootprompt;<userinput>cupsaddsmb -H sambaserver -h cupsserver -v printer</userinput>
</screen></para>
</note>
</sect2>

<sect2>
<title>How to Recognize If cupsaddsmb Completed Successfully</title>

<para>
You <emphasis>must</emphasis> always check if the utility completed
successfully in all fields. You need as a minimum these three messages
among the output:
</para>

<orderedlist>

<listitem><para><emphasis>Printer Driver infotec_2105 successfully
installed.</emphasis> # (for the W32X86 == Windows NT/200x/XP
architecture).</para></listitem>

<listitem><para><emphasis>Printer Driver infotec_2105 successfully
installed.</emphasis> # (for the WIN40 == Windows 9x/Me
architecture).</para></listitem>

<listitem><para><emphasis>Successfully set [printerXPZ] to driver
[printerXYZ].</emphasis></para></listitem>
</orderedlist>

<para>
These messages are probably not easily recognized in the general
output. If you run <command>cupsaddsmb</command> with the <option>-a</option>
parameter (which tries to prepare <emphasis>all</emphasis> active CUPS
printer drivers for download), you might miss if individual printers
drivers had problems installing properly. Here a redirection of the
output will help you analyze the results in retrospective.
</para>

<para>
If you get:
<screen>
SetPrinter call failed!
result was WERR_ACCESS_DENIED
</screen>
It means that you might have set <smbconfoption><name>use client driver</name><value>yes</value></smbconfoption> for this printer. 
Set it to <quote>no</quote> will solve the problem. Refer to man samba(5) for explanantion on 
<parameter>use client driver</parameter>.
</para>

<note><para>
It is impossible to see any diagnostic output if you do not run
<command>cupsaddsmb</command> in verbose mode. Therefore, we strongly recommend to not
use the default quiet mode. It will hide any problems from you that
might occur.
</para></note>
</sect2>

<sect2>
<title>cupsaddsmb with a Samba PDC</title>


<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
Can't get the standard <command>cupsaddsmb</command> command to run on a Samba PDC?
Are you asked for the password credential all over again and again and
the command just will not take off at all? Try one of these
variations:
</para>

<para><screen>
&rootprompt;<userinput>cupsaddsmb -U &example.workgroup;\\root -v printername</userinput>
&rootprompt;<userinput>cupsaddsmb -H &example.pdc.samba; -U &example.workgroup;\\root -v printername</userinput>
&rootprompt;<userinput>cupsaddsmb -H &example.pdc.samba; -U &example.workgroup;\\root -h cups-server -v printername</userinput>
</screen></para>

<para>
(Note the two backslashes: the first one is required to
<quote>escape</quote> the second one).
</para>
</sect2>

<sect2>
<title>cupsaddsmb Flowchart</title>

<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
<link linkend="small14">cupsaddsmb flowchart</link> shows a chart about the procedures, command-flows and
data-flows of the <command>cupaddsmb</command> command. Note again: cupsaddsmb is
not intended to, and does not work with, raw queues!
</para>

<para>
	<image id="small14"><imagedescription>cupsaddsmb flowchart.</imagedescription>
		<imagefile>14small</imagefile></image>
</para>
</sect2>

<sect2>
<title>Installing the PostScript Driver on a Client</title>

<para>
<indexterm><primary>point 'n' print</primary></indexterm>
After <command>cupsaddsmb</command> is completed, your driver is prepared for the clients to
use. Here are the steps you must perform to download and install it
via Point'n'Print. From a Windows client, browse to the CUPS/Samba
server:
</para>

<itemizedlist>


<listitem><para>
<indexterm><primary>"Printers" folder</primary></indexterm>
Open the <guilabel>Printers</guilabel>
share of Samba in Network Neighborhood.</para></listitem>

<listitem><para>Right-click on the printer in
question.</para></listitem>

<listitem><para>From the opening context-menu select
<guimenuitem>Install...</guimenuitem> or 
<guimenuitem>Connect...</guimenuitem> (depending on the Windows version you
use).</para></listitem>
</itemizedlist>

<para>
After a few seconds, there should be a new printer in your
client's <emphasis>local</emphasis> <guilabel>Printers</guilabel> folder. On Windows
XP it will follow a naming convention of <emphasis>PrinterName on
SambaServer</emphasis>. (In my current case it is "infotec_2105 on
kde-bitshop"). If you want to test it and send your first job from
an application like Winword, the new printer appears in a
<filename>\\SambaServer\PrinterName</filename> entry in the
drop-down list of available printers.
</para>

<para>
<indexterm><primary>PPD</primary></indexterm>
<command>cupsaddsmb</command> will only reliably work with CUPS version 1.1.15 or higher
and Samba from 2.2.4. If it does not work, or if the automatic printer
driver download to the clients does not succeed, you can still manually
install the CUPS printer PPD on top of the Adobe PostScript driver on
clients. Then point the client's printer queue to the Samba printer
share for a UNC type of connection:
</para>

<para><screen>
&dosprompt;<userinput>net use lpt1: \\sambaserver\printershare /user:ntadmin</userinput>
</screen></para>

<para>
should you desire to use the CUPS networked PostScript RIP
functions. (Note that user <quote>ntadmin</quote> needs to be a valid Samba user
with the required privileges to access the printershare.) This
sets up the printer connection in the traditional
<emphasis>LanMan</emphasis> way (not using MS-RPC).
</para>
</sect2>

<sect2>
<title>Avoiding Critical PostScript Driver Settings on the Client</title>

<para>
Printing works, but there are still problems. Most jobs print
well, some do not print at all. Some jobs have problems with fonts,
which do not look very good. Some jobs print fast and some are
dead-slow. Many of these problems can be greatly reduced or even
completely eliminated if you follow a few guidelines. Remember, if
your print device is not PostScript-enabled, you are treating your
Ghostscript installation on your CUPS host with the output your client
driver settings produce. Treat it well:
</para>

<itemizedlist>
<listitem><para>Avoid the PostScript Output Option: Optimize
for Speed setting. Use the Optimize for
Portability instead (Adobe PostScript
driver).</para></listitem>

<listitem><para>Don't use the Page Independence:
NO setting. Instead, use Page Independence
YES (CUPS PostScript Driver).</para></listitem>

<listitem><para>Recommended is the True Type Font
Downloading Option: Native True Type over
Automatic and Outline; you
should by all means avoid Bitmap (Adobe
PostScript Driver).</para></listitem>

<listitem><para>Choose True Type Font: Download as Softfont
into Printer over the default Replace by Device
Font (for exotic fonts, you may need to change it back to
get a printout at all) (Adobe).</para></listitem>

<listitem><para>Sometimes you can choose PostScript Language
Level: In case of problems try 2
instead of 3 (the latest ESP Ghostscript package
handles Level 3 PostScript very well) (Adobe).</para></listitem>

<listitem><para>Say Yes to PostScript
Error Handler (Adobe).</para></listitem>
</itemizedlist>
</sect2>
</sect1>

<sect1>
<title>Installing PostScript Driver Files Manually Using rpcclient</title>

<para>
Of course, you can run all the commands that are embedded into the
cupsaddsmb convenience utility yourself, one by one, and hereby upload
and prepare the driver files for future client downloads.
</para>

<orderedlist>
<listitem><para>Prepare Samba (A CUPS print queue with the name of the
printer should be there. We are providing the driver
now).</para></listitem>

<listitem><para>Copy all files to
		<smbconfsection>[print$]</smbconfsection>.</para></listitem>

<listitem><para>
<indexterm><primary>rpcclient</primary><secondary>adddriver</secondary></indexterm>
Run <command>rpcclient adddriver</command>
(for each client architecture you want to support).</para></listitem>

<listitem><para>
<indexterm><primary>rpcclient</primary><secondary>setdriver</secondary></indexterm>
Run <command>rpcclient
setdriver.</command></para></listitem>
</orderedlist>

<para>
<indexterm><primary>rpcclient</primary><secondary>enumports</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>enumprinters</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>enumdrivers</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>setdriver</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>adddriver</secondary></indexterm>
We are going to do this now. First, read the man page on <parameter>rpcclient</parameter>
to get a first idea. Look at all the printing related
subcommands. <command>enumprinters</command>,
<command>enumdrivers</command>, <command>enumports</command>,
<command>adddriver</command>, <command>setdriver</command> are among
the most interesting ones. <parameter>rpcclient</parameter> implements an important part of
the MS-RPC protocol. You can use it to query (and command) a Windows NT
(or 200x/XP) PC, too. MS-RPC is used by Windows clients, among other
things, to benefit from the Point'n'Print features. Samba can now
mimic this as well.
</para>

<sect2>
<title>A Check of the rpcclient man Page</title>

<para>
	First let's check the <parameter>rpcclient</parameter> man page. Here are
two relevant passages:
</para>

<para>
<command>adddriver &lt;arch&gt; &lt;config&gt;</command> Execute an
<command>AddPrinterDriver()</command> RPC to install the printer driver information on
the server. The driver files should already exist in the
directory returned by <command>getdriverdir</command>. Possible
values for <parameter>arch</parameter> are the same as those for the
<command>getdriverdir</command> command. The
<parameter>config</parameter> parameter is defined as follows:
</para>
		
<para><screen>
Long Printer Name:\
Driver File Name:\
Data File Name:\
Config File Name:\
Help File Name:\
Language Monitor Name:\
Default Data Type:\
Comma Separated list of Files
</screen></para>

<para>Any empty fields should be enter as the string <quote>NULL</quote>. </para>

<para>Samba does not need to support the concept of Print Monitors
since these only apply to local printers whose driver can make use of
a bi-directional link for communication. This field should be <quote>NULL</quote>.
On a remote NT print server, the Print Monitor for a driver must
already be installed prior to adding the driver or else the RPC will
fail.
</para>

<para>
<command>setdriver &lt;printername&gt; &lt;drivername&gt;</command>
Execute a <command>SetPrinter()</command> command to update the
printer driver associated with an installed printer. The printer
driver must already be correctly installed on the print server.
</para>

<para>See also the <command>enumprinters</command> and <command>enumdrivers</command> commands for
obtaining a list of installed printers and drivers.
</para>

</sect2>

<sect2>
<title>Understanding the rpcclient man Page</title>

<para>
The <emphasis>exact</emphasis> format isn't made too clear by the man
page, since you have to deal with some parameters containing
spaces. Here is a better description for it. We have line-broken the
command and indicated the breaks with <quote>\</quote>. Usually you would type the
command in one line without the line-breaks:
<indexterm><primary>rpcclient</primary><secondary>adddriver</secondary></indexterm>
</para>

<para><screen>
 adddriver "Architecture" \
           "LongPrinterName:DriverFile:DataFile:ConfigFile:HelpFile:\
           LanguageMonitorFile:DataType:ListOfFiles,Comma-separated"
</screen></para>

<para>
What the man pages denote as a simple <parameter>&lt;config&gt;</parameter>
keyword, in reality consists of eight colon-separated fields. The
last field may take multiple (in some very insane cases, even
20 different additional) files. This might sound confusing at first.
What the man pages names the <quote>LongPrinterName</quote> in
reality should be called the <quote>Driver Name</quote>. You can name it
anything you want, as long as you use this name later in the
<command>rpcclient ... setdriver</command> command. For
practical reasons, many name the driver the same as the
printer.
</para>

<para>
It isn't simple at all. I hear you asking:
<quote>How do I know which files are "Driver
File</quote>, <quote>Data File</quote>, <quote>Config File</quote>, <quote>Help File</quote> and <quote>Language
Monitor File" in each case?</quote> &smbmdash; For an answer, you may
want to have a look at how a Windows NT box with a shared printer
presents the files to us. Remember, that this whole procedure has
to be developed by the Samba team by overhearing the traffic caused
by Windows computers on the wire. We may as well turn to a Windows
box now and access it from a UNIX workstation. We will query it
with <command>rpcclient</command> to see what it tells us and
try to understand the man page more clearly that we've read just
now.
</para>
</sect2>

<sect2>
<title>Producing an Example by Querying a Windows Box</title>

<para>
	<indexterm><primary>rpcclient</primary><secondary>getdriver</secondary></indexterm>
	<indexterm><primary>rpcclient</primary><secondary>getprinter</secondary></indexterm>
We could run <command>rpcclient</command> with a
<command>getdriver</command> or a <command>getprinter</command>
subcommand (in level 3 verbosity) against it. Just sit down at a UNIX or
Linux workstation with the Samba utilities installed, then type the
following command:
</para>

<para><screen>
&rootprompt;<userinput>rpcclient -U'user%secret' NT-SERVER -c 'getdriver printername 3'</userinput>
</screen></para>

<para>
From the result it should become clear which is which. Here is an example from my installation:
</para>

<para>
<indexterm><primary>rpcclient</primary><secondary>getdriver</secondary></indexterm>
	<screen>
&rootprompt;<userinput>rpcclient -U'Danka%xxxx' W200xSERVER \
	-c'getdriver "DANKA InfoStream Virtual Printer" 3'</userinput>
 cmd = getdriver "DANKA InfoStream Virtual Printer" 3

 [Windows NT x86]
 Printer Driver Info 3:
         Version: [2]
         Driver Name: [DANKA InfoStream]
         Architecture: [Windows NT x86]
         Driver Path: [C:\WINNT\System32\spool\DRIVERS\W32X86\2\PSCRIPT.DLL]
         Datafile: [C:\WINNT\System32\spool\DRIVERS\W32X86\2\INFOSTRM.PPD]
         Configfile: [C:\WINNT\System32\spool\DRIVERS\W32X86\2\PSCRPTUI.DLL]
         Helpfile: [C:\WINNT\System32\spool\DRIVERS\W32X86\2\PSCRIPT.HLP]
 
         Dependentfiles: []
         Dependentfiles: []
         Dependentfiles: []
         Dependentfiles: []
         Dependentfiles: []
         Dependentfiles: []
         Dependentfiles: []
 
         Monitorname: []
         Defaultdatatype: []

</screen></para>

<para>
Some printer drivers list additional files under the label
<parameter>Dependentfiles</parameter> and these would go into the last field
<parameter>ListOfFiles,Comma-separated</parameter>. For the CUPS
PostScript drivers, we do not need any (nor would we for the Adobe
PostScript driver), therefore, the field will get a <quote>NULL</quote> entry.
</para>
</sect2>

<sect2>
<title>Requirements for adddriver and setdriver to Succeed</title>

<para>
>From the man page (and from the quoted output
of <command>cupsaddsmb</command> above) it becomes clear that you
need to have certain conditions in order to make the manual uploading
and initializing of the driver files succeed. The two <command>rpcclient</command>
<indexterm><primary>rpcclient</primary><secondary>adddriver</secondary></indexterm>
subcommands (<command>adddriver</command> and
<command>setdriver</command>) need to encounter the following
preconditions to complete successfully:
</para>
<itemizedlist>

<listitem><para>You are connected as <smbconfoption><name>printer admin</name></smbconfoption> or root (this is <emphasis>not</emphasis> the <quote>Printer Operators</quote> group in
NT, but the <emphasis>printer admin</emphasis> group as defined in
the <smbconfsection>[global]</smbconfsection> section of
&smb.conf;).</para></listitem>

<listitem><para>Copy all required driver files to
<filename>\\SAMBA\print$\w32x86</filename> and
<filename>\\SAMBA\print$\win40</filename> as appropriate. They
will end up in the <quote>0</quote> respective <quote>2</quote> subdirectories later. For now,
<emphasis>do not</emphasis> put them there, they'll be automatically
used by the <command>adddriver</command> subcommand. (If you use
<command>smbclient</command> to put the driver files into the share, note that you need
to escape the <quote>$</quote>: <command>smbclient //sambaserver/print\$ -U
root.</command>)</para></listitem>

<listitem><para>The user you're connecting as must be able to write to
the <smbconfsection>[print$]</smbconfsection> share and create
subdirectories.</para></listitem>

<listitem><para>The printer you are going to setup for the Windows
clients needs to be installed in CUPS already.</para></listitem>

<listitem><para>
	<indexterm><primary>rpcclient</primary><secondary>setdriver</secondary></indexterm>
	<indexterm><primary>rpcclient</primary><secondary>enumprinters</secondary></indexterm>
		The CUPS printer must be known to Samba, otherwise the
<command>setdriver</command> subcommand fails with an
NT_STATUS_UNSUCCESSFUL error. To check if the printer is known by
Samba, you may use the <command>enumprinters</command> subcommand to
<command>rpcclient</command>. A long-standing bug prevented a proper update of the
printer list until every smbd process had received a SIGHUP or was
restarted. Remember this in case you've created the CUPS printer just
recently and encounter problems: try restarting
Samba.</para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>Manual Driver Installation in 15 Steps</title>

<para>
We are going to install a printer driver now by manually executing all
required commands. As this may seem a rather complicated process at
first, we go through the procedure step by step, explaining every
single action item as it comes up.
</para>

<procedure>
	<title>Manual Driver Installation</title>

<step>
<title>Install the printer on CUPS.</title>

<para><screen>
&rootprompt;<userinput>lpadmin -p mysmbtstprn -v socket://10.160.51.131:9100 -E \
			-P canonIR85.ppd</userinput>
</screen></para>

<para>
This installs a printer with the name <parameter>mysmbtstprn</parameter>
to the CUPS system. The printer is accessed via a socket
(a.k.a. JetDirect or Direct TCP/IP) connection. You need to be root
for this step.
</para>
</step>

<step>
<title>(Optional) Check if the printer is recognized by Samba.</title>

<para>
<indexterm><primary>rpcclient</primary><secondary>enumprinters</secondary></indexterm>
<screen>
	&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'enumprinters' localhost \
  | grep -C2 mysmbtstprn</userinput>
flags:[0x800000]
name:[\\kde-bitshop\mysmbtstprn]
description:[\\kde-bitshop\mysmbtstprn,,mysmbtstprn]
comment:[mysmbtstprn]
</screen></para>

<para>
This should show the printer in the list. If not, stop and restart
the Samba daemon (smbd), or send a HUP signal: 
<screen>
&rootprompt;<userinput>kill -HUP `pidof smbd`</userinput>
</screen>Check again. Troubleshoot and repeat until
successful. Note the <quote>empty</quote> field between the two commas in the
<quote>description</quote> line. The driver name would appear here if there was one already. You need to know root's Samba password (as set by the
<command>smbpasswd</command> command) for this step and most of the
following steps. Alternately, you can authenticate as one of the
users from the <quote>write list</quote> as defined in &smb.conf; for
<smbconfsection>[print$]</smbconfsection>.
</para>
</step>

<step>
<title>(Optional) Check if Samba knows a driver for the printer.</title>

<para>
	<indexterm><primary>rpcclient</primary><secondary>getprinter</secondary></indexterm>
	<indexterm><primary>rpcclient</primary><secondary>getdriver</secondary></indexterm>
	<screen>
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'getprinter mysmbtstprn 2' localhost \
			| grep driver </userinput>
drivername:[]

&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'getprinter mysmbtstprn 2' localhost \
	| grep -C4 driv</userinput>
servername:[\\kde-bitshop]
printername:[\\kde-bitshop\mysmbtstprn]
sharename:[mysmbtstprn]
portname:[Samba Printer Port]
drivername:[]
comment:[mysmbtstprn]
location:[]
sepfile:[]
printprocessor:[winprint]
 
&rootprompt;<userinput>rpcclient -U root%xxxx -c 'getdriver mysmbtstprn' localhost</userinput>
 result was WERR_UNKNOWN_PRINTER_DRIVER

</screen></para>

<para>
None of the three commands shown above should show a driver.
This step was done for the purpose of demonstrating this condition. An
attempt to connect to the printer at this stage will prompt the
message along the lines of: <quote>The server does not have the required printer
driver installed.</quote>
</para>
</step>

<step>
<title>Put all required driver files into Samba's
[print$].</title>

<para><screen>
&rootprompt;<userinput>smbclient //localhost/print\$ -U 'root%xxxx' \
	-c 'cd W32X86; \
	put /etc/cups/ppd/mysmbtstprn.ppd mysmbtstprn.PPD; \ 
	put /usr/share/cups/drivers/cupsui.dll cupsui.dll; \
	put /usr/share/cups/drivers/cupsdrvr.dll cupsdrvr.dll; \
	put /usr/share/cups/drivers/cups.hlp cups.hlp'</userinput>
</screen></para>

<para>
(This command should be entered in one long single
line. Line-breaks and the line-end indicated by <quote>\</quote> have been inserted
for readability reasons.) This step is <emphasis>required</emphasis>
for the next one to succeed. It makes the driver files physically
present in the <smbconfsection>[print$]</smbconfsection> share. However, clients
would still not be able to install them, because Samba does not yet
treat them as driver files. A client asking for the driver would still
be presented with a <quote>not installed here</quote> message.
</para>
</step>

<step>
<title>Verify where the driver files are now.</title>

<para><screen>
&rootprompt;<userinput>ls -l /etc/samba/drivers/W32X86/</userinput>
total 669
drwxr-sr-x    2 root     ntadmin       532 May 25 23:08 2
drwxr-sr-x    2 root     ntadmin       670 May 16 03:15 3
-rwxr--r--    1 root     ntadmin     14234 May 25 23:21 cups.hlp
-rwxr--r--    1 root     ntadmin    278380 May 25 23:21 cupsdrvr.dll
-rwxr--r--    1 root     ntadmin    215848 May 25 23:21 cupsui.dll
-rwxr--r--    1 root     ntadmin    169458 May 25 23:21 mysmbtstprn.PPD
</screen></para>

<para>
The driver files now are in the W32X86 architecture <quote>root</quote> of
<smbconfsection>[print$]</smbconfsection>.
</para>
</step>

<step>
<title>Tell Samba that these are driver files (<command>adddriver</command>).</title>

<para>
<indexterm><primary>rpcclient</primary><secondary>adddriver</secondary></indexterm>
<screen>
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'adddriver "Windows NT x86" \
	"mydrivername:cupsdrvr.dll:mysmbtstprn.PPD: \
  cupsui.dll:cups.hlp:NULL:RAW:NULL"' \
  localhost</userinput>
Printer Driver mydrivername successfully installed.
</screen></para>

<para>
You cannot repeat this step if it fails. It could fail even
as a result of a simple typo. It will most likely have moved a part of
the driver files into the <quote>2</quote> subdirectory. If this step fails, you
need to go back to the fourth step and repeat it before you can try
this one again. In this step, you need to choose a name for your
driver. It is normally a good idea to use the same name as is used for
the printer name; however, in big installations you may use this driver
for a number of printers that obviously have different names, so the
name of the driver is not fixed.
</para>
</step>

<step>
<title>Verify where the driver files are now.</title>

<para><screen>
&rootprompt;<userinput>ls -l /etc/samba/drivers/W32X86/</userinput>
total 1
drwxr-sr-x    2 root     ntadmin       532 May 25 23:22 2
drwxr-sr-x    2 root     ntadmin       670 May 16 03:15 3

&rootprompt;<userinput>ls -l /etc/samba/drivers/W32X86/2</userinput>
total 5039
[....]
-rwxr--r--    1 root     ntadmin     14234 May 25 23:21 cups.hlp
-rwxr--r--    1 root     ntadmin    278380 May 13 13:53 cupsdrvr.dll
-rwxr--r--    1 root     ntadmin    215848 May 13 13:53 cupsui.dll
-rwxr--r--    1 root     ntadmin    169458 May 25 23:21 mysmbtstprn.PPD
</screen></para>

<para>
Notice how step 6 also moved the driver files to the appropriate
subdirectory. Compare this with the situation after step 5.
</para>
</step>

<step>
<title>(Optional) Verify if Samba now recognizes the driver.</title>

<para>
<indexterm><primary>rpcclient</primary><secondary>enumdrivers</secondary></indexterm>
<screen>
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'enumdrivers 3' \
	localhost | grep -B2 -A5 mydrivername</userinput>
Printer Driver Info 3:
Version: [2]
Driver Name: [mydrivername]
Architecture: [Windows NT x86]
Driver Path: [\\kde-bitshop\print$\W32X86\2\cupsdrvr.dll]
Datafile: [\\kde-bitshop\print$\W32X86\2\mysmbtstprn.PPD]
Configfile: [\\kde-bitshop\print$\W32X86\2\cupsui.dll]
Helpfile: [\\kde-bitshop\print$\W32X86\2\cups.hlp]
</screen></para>

<para>
Remember, this command greps for the name you chose for the
driver in step 6. This command must succeed before you can proceed.
</para>
</step>

<step>
<para>Tell Samba which printer should use these driver files (<command>setdriver</command>).</para>


<para>
<indexterm><primary>rpcclient</primary><secondary>setdriver</secondary></indexterm>
<screen>
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'setdriver mysmbtstprn mydrivername' \
	localhost</userinput>
Successfully set mysmbtstprn to driver mydrivername
</screen></para>

<para>
Since you can bind any printername (print queue) to any driver, this
is a convenient way to setup many queues that use the same
driver. You do not need to repeat all the previous steps for the
setdriver command to succeed. The only preconditions are:
<command>enumdrivers</command> must find the driver and
<command>enumprinters</command> must find the printer.
</para>
</step>

<step>
	<title>(Optional) Verify if Samba has recognized this association.</title>

<para>
<indexterm><primary>rpcclient</primary><secondary>getprinter</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>getdriver</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>enumprinters</secondary></indexterm>
<screen>
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'getprinter mysmbtstprn 2' localhost \
  | grep driver</userinput>
drivername:[mydrivername]
 
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'getprinter mysmbtstprn 2' localhost \
  | grep -C4 driv</userinput>
servername:[\\kde-bitshop]
printername:[\\kde-bitshop\mysmbtstprn]
sharename:[mysmbtstprn]
portname:[Done]
drivername:[mydrivername]
comment:[mysmbtstprn]
location:[]
sepfile:[]
printprocessor:[winprint]
 
&rootprompt;<userinput>rpcclient -U root%xxxx -c 'getdriver mysmbtstprn' localhost</userinput>
[Windows NT x86]
Printer Driver Info 3:
     Version: [2]
     Driver Name: [mydrivername]
     Architecture: [Windows NT x86]
     Driver Path: [\\kde-bitshop\print$\W32X86\2\cupsdrvr.dll]
     Datafile: [\\kde-bitshop\print$\W32X86\2\mysmbtstprn.PPD]
     Configfile: [\\kde-bitshop\print$\W32X86\2\cupsui.dll]
     Helpfile: [\\kde-bitshop\print$\W32X86\2\cups.hlp]
     Monitorname: []
     Defaultdatatype: [RAW]
     Monitorname: []
     Defaultdatatype: [RAW]
 
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'enumprinters' localhost \
	| grep mysmbtstprn</userinput>
     name:[\\kde-bitshop\mysmbtstprn]
     description:[\\kde-bitshop\mysmbtstprn,mydrivername,mysmbtstprn]
     comment:[mysmbtstprn]

</screen></para>

<para>
<indexterm><primary>rpcclient</primary><secondary>enumprinters</secondary></indexterm>
Compare these results with the ones from steps 2 and 3. Every one of these commands show the driver is installed. Even
the <command>enumprinters</command> command now lists the driver
on the <quote>description</quote> line.
</para>
</step>

<step>
<title>(Optional) Tickle the driver into a correct
device mode.</title>

<para>
<indexterm><primary>"Printers" folder</primary></indexterm>
You certainly know how to install the driver on the client. In case
you are not particularly familiar with Windows, here is a short
recipe: Browse the Network Neighborhood, go to the Samba server, and look
for the shares. You should see all shared Samba printers.
Double-click on the one in question. The driver should get
installed and the network connection set up. An alternate way is to
open the <guilabel>Printers (and Faxes)</guilabel> folder, right-click on the printer in
question and select <guilabel>Connect</guilabel> or <guilabel>Install</guilabel>. As a result, a new printer
should have appeared in your client's local <guilabel>Printers (and Faxes)</guilabel>
folder, named something like <guilabel>printersharename on Sambahostname</guilabel>.
</para>

<para>
It is important that you execute this step as a Samba printer admin
(as defined in &smb.conf;). Here is another method
to do this on Windows XP. It uses a command line, which you may type
into the <quote>DOS box</quote> (type root's smbpassword when prompted):
</para>

<para><screen>
&dosprompt;<userinput>runas /netonly /user:root "rundll32 printui.dll,PrintUIEntry \
	/in /n \\sambaserver\mysmbtstprn"</userinput>
</screen></para>

<para>
Change any printer setting once (like changing <emphasis><guilabel>portrait</guilabel> to
	<guilabel>landscape</guilabel></emphasis>), click on <guibutton>Apply</guibutton>; change the setting
back.
</para>
</step>

<step>
<title>Install the printer on a client
(Point'n'Print).</title>


<para>
<indexterm significance="preferred"><primary>point 'n' print</primary></indexterm>
	<screen>
&dosprompt;<userinput>rundll32 printui.dll,PrintUIEntry /in /n <quote>\\sambaserver\mysmbtstprn</quote></userinput>
</screen></para>

<para>
If it does not work it could be a permission problem with the
<smbconfsection>[print$]</smbconfsection> share.
</para>
</step>

<step>
<title>(Optional) Print a test page.</title>

<para><screen>
&dosprompt;<userinput>rundll32 printui.dll,PrintUIEntry /p /n "\\sambaserver\mysmbtstprn"</userinput>
</screen></para>

<para>
Then hit [TAB] five times, [ENTER] twice, [TAB] once and [ENTER] again
and march to the printer.
</para>
</step>

<step>
<title>(Recommended) Study the test page.</title>

<para>
Hmmm.... just kidding! By now you know everything about printer
installations and you do not need to read a word. Just put it in a
frame and bolt it to the wall with the heading "MY FIRST
RPCCLIENT-INSTALLED PRINTER" &smbmdash; why not just throw it away!
</para>
</step>

<step>
<title>(Obligatory) Enjoy. Jump. Celebrate your
success.</title>

<para><screen>
&rootprompt;<userinput>echo "Cheeeeerioooooo! Success..." &gt;&gt; /var/log/samba/log.smbd</userinput>
</screen></para>
</step>
</procedure>
</sect2>

<sect2>
<title>Troubleshooting Revisited</title>

<para>
The setdriver command will fail, if in Samba's mind the queue is not
already there. You had promising messages about the:
</para>

<para><screen>
 Printer Driver ABC successfully installed.
</screen></para>

<para>
after the <command>adddriver</command> parts of the procedure?  But you are also seeing
a disappointing message like this one?
</para>

<para><computeroutput>
 result was NT_STATUS_UNSUCCESSFUL
</computeroutput></para>

<para>
<indexterm><primary>lpstat</primary></indexterm>
It is not good enough that you
can see the queue in CUPS, using
the <command>lpstat -p ir85wm</command> command. A
bug in most recent versions of Samba prevents the proper update of
the queue-list. The recognition of newly installed CUPS printers
fails unless you restart Samba or send a HUP to all smbd
processes. To verify if this is the reason why Samba does not
execute the <command>setdriver</command> command successfully, check if Samba <quote>sees</quote>
the printer: 
</para>

<para>
<indexterm><primary>rpcclient</primary><secondary>enumprinters</secondary></indexterm>
	<screen>
&rootprompt;<userinput>rpcclient transmeta -N -U'root%xxxx' -c 'enumprinters 0'|grep ir85wm</userinput>
        printername:[ir85wm]
</screen></para>

<para>
An alternate command could be this: 
</para>

<para>
<indexterm><primary>rpcclient</primary><secondary>getprinter</secondary></indexterm>
	<screen>
&rootprompt;<userinput>rpcclient transmeta -N -U'root%secret' -c 'getprinter ir85wm' </userinput>
        cmd = getprinter ir85wm
        flags:[0x800000]
        name:[\\transmeta\ir85wm]
        description:[\\transmeta\ir85wm,ir85wm,DPD]
        comment:[CUPS PostScript-Treiber for Windows NT/200x/XP]
</screen></para>

<para>
By the way, you can use these commands, plus a few more, of course,
to install drivers on remote Windows NT print servers too!
</para>
</sect2>
</sect1>

<sect1>
<title>The Printing <filename>*.tdb</filename> Files</title>

<para>
<indexterm><primary>TDB</primary></indexterm>
<indexterm><primary>connections.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>printing.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>share_info.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>ntdrivers.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>unexpected.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>brlock.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>locking.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>ntforms.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>messages.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>ntprinters.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>sessionid.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>secrets.tdb</primary><seealso>TDB</seealso></indexterm>
Some mystery is associated with the series of files with a
tdb suffix appearing in every Samba installation. They are
<filename>connections.tdb</filename>,
<filename>printing.tdb</filename>,
<filename>share_info.tdb</filename>,
<filename>ntdrivers.tdb</filename>,
<filename>unexpected.tdb</filename>,
<filename>brlock.tdb</filename>,
<filename>locking.tdb</filename>,
<filename>ntforms.tdb</filename>,
<filename>messages.tdb</filename> ,
<filename>ntprinters.tdb</filename>,
<filename>sessionid.tdb</filename> and
<filename>secrets.tdb</filename>. What is their purpose?
</para>

<sect2>
<title>Trivial Database Files</title>

<para>
<indexterm><primary>TDB</primary></indexterm>
A Windows NT (print) server keeps track of all information needed to serve
its duty toward its clients by storing entries in the Windows
registry. Client queries are answered by reading from the registry,
Administrator or user configuration settings that are saved by writing into
the registry. Samba and UNIX obviously do not have such a
Registry. Samba instead keeps track of all client related information in a
series of <filename>*.tdb</filename> files. (TDB = Trivial Data
Base). These are often located in <filename>/var/lib/samba/</filename>
or <filename>/var/lock/samba/</filename>. The printing related files
are <filename>ntprinters.tdb</filename>,
<filename>printing.tdb</filename>,<filename>ntforms.tdb</filename> and
<filename>ntdrivers.tdb</filename>.
</para>
</sect2>

<sect2>
<title>Binary Format</title>

<para>
<filename>*.tdb</filename> files are not human readable. They are
written in a binary format. <quote>Why not ASCII?</quote>, you may ask. <quote>After all,
ASCII configuration files are a good and proven tradition on UNIX.</quote>
The reason for this design decision by the Samba team is mainly
performance. Samba needs to be fast; it runs a separate
<command>smbd</command> process for each client connection, in some
environments many thousands of them. Some of these smbds might need to
write-access the same <filename>*.tdb</filename> file <emphasis>at the
same time</emphasis>. The file format of Samba's
<filename>*.tdb</filename> files allows for this provision. Many smbd
processes may write to the same <filename>*.tdb</filename> file at the
same time. This wouldn't be possible with pure ASCII files.
</para>
</sect2>

<sect2>
<title>Losing <filename>*.tdb</filename> Files</title>

<para>
It is very important that all <filename>*.tdb</filename> files remain
consistent over all write and read accesses. However, it may happen
that these files <emphasis>do</emphasis> get corrupted. (A
<command>kill -9 `pidof smbd'</command> while a write access is in
progress could do the damage as well as a power interruption,
etc.). In cases of trouble, a deletion of the old printing-related
<filename>*.tdb</filename> files may be the only option. After that you need to
re-create all print-related setup or you have made a
backup of the <filename>*.tdb</filename> files in time.
</para>
</sect2>

<sect2>
<title>Using <command>tdbbackup</command></title>


<para>
<indexterm><primary>TDB</primary><secondary>backing up</secondary><see>tdbbackup</see></indexterm>
<indexterm><primary>tdbbackup</primary></indexterm>
Samba ships with a little utility that helps the root user of your
system to backup your <filename>*.tdb</filename> files. If you run it
with no argument, it prints a usage message:
</para>

<para><screen>
&rootprompt;<userinput>tdbbackup</userinput>
 Usage: tdbbackup [options] &lt;fname...&gt;
 
 Version:3.0a
   -h            this help message
   -s suffix     set the backup suffix
   -v            verify mode (restore if corrupt)

</screen></para>

<para>
Here is how I backed up my <filename>printing.tdb</filename> file:
</para>

<para><screen>
&rootprompt;<userinput>ls</userinput>
.              browse.dat     locking.tdb     ntdrivers.tdb printing.tdb
..             share_info.tdb connections.tdb messages.tdb  ntforms.tdb
printing.tdbkp unexpected.tdb brlock.tdb      gmon.out      namelist.debug  
ntprinters.tdb sessionid.tdb
 
&rootprompt;<userinput>tdbbackup -s .bak printing.tdb</userinput>
 printing.tdb : 135 records
 
&rootprompt;<userinput>ls -l printing.tdb*</userinput>
 -rw-------    1 root     root        40960 May  2 03:44 printing.tdb
 -rw-------    1 root     root        40960 May  2 03:44 printing.tdb.bak

</screen></para>
</sect2>
</sect1>

<sect1>
<title>CUPS Print Drivers from Linuxprinting.org</title>


<para>
<indexterm><primary>Linuxprinting.org</primary></indexterm>
CUPS ships with good support for HP LaserJet-type printers. You can
install the generic driver as follows:
</para>


<para>
<indexterm><primary>lpadmin</primary></indexterm>
	<screen>
&rootprompt;<userinput>lpadmin -p laserjet4plus -v parallel:/dev/lp0 -E -m laserjet.ppd</userinput>
</screen></para>

<para>
The <option>-m</option> switch will retrieve the
<filename>laserjet.ppd</filename> from the standard repository for
not-yet-installed-PPDs, which CUPS typically stores in
<filename>/usr/share/cups/model</filename>. Alternately, you may use
<option>-P /path/to/your.ppd</option>.
</para>

<para>
The generic <filename>laserjet.ppd,</filename> however, does not support every special option
for every LaserJet-compatible model. It constitutes a sort of <quote>least common
denominator</quote> of all the models. If for some reason
you must pay for the commercially available ESP Print Pro drivers, your
first move should be to consult the database on the
<ulink noescape="1" url="http://www.linuxprinting.org/printer_list.cgi">Linuxprinting</ulink> web site.
Linuxprinting.org has excellent recommendations about which driver is
best used for each printer. Its database is kept current by the
tireless work of Till Kamppeter from MandrakeSoft, who is also the
principal author of the <command>foomatic-rip</command> utility.
</para>

<note><para>
<indexterm><primary>foomatic-rip</primary></indexterm>
The former <command>cupsomatic</command> concept is now being replaced by the new
successor, a much
more powerful <command>foomatic-rip</command>.
<command>cupsomatic</command> is no longer maintained. Here is the new URL
to the <ulink noescape="1" url="http://www.linuxprinting.org/driver_list.cgi">Foomatic-3.0</ulink> database.
If you upgrade to <command>foomatic-rip</command>, remember to also upgrade to the
new-style PPDs for your Foomatic-driven printers. foomatic-rip will
not work with PPDs generated for the old <command>cupsomatic</command>. The new-style
PPDs are 100% compliant to the Adobe PPD specification. They are
also intended to be used by Samba and the cupsaddsmb utility, to
provide the driver files for the Windows clients!
</para></note>

<sect2>
<title>foomatic-rip and Foomatic Explained</title>


<para>
<indexterm significance="preferred"><primary>foomatic</primary></indexterm>
<indexterm significance="preferred"><primary>foomatic-rip</primary></indexterm>
Nowadays, most Linux distributions rely on the utilities of Linuxprinting.org
to create their printing-related software (which, by the way, works on all
UNIXes and on Mac OS X or Darwin, too). It is not known as well as it
should be, that it also has a very end-user-friendly interface that
allows for an easy update of drivers and PPDs for all supported
models, all spoolers, all operating systems, and all package formats
(because there is none). Its history goes back a few years.
</para>

<para>
Recently, Foomatic has achieved the astonishing milestone of <ulink
url="http://www.linuxprinting.org/printer_list.cgi?make=Anyone">1000
listed</ulink> printer models. Linuxprinting.org keeps all the
important facts about printer drivers, supported models and which
options are available for the various driver/printer combinations in
its <ulink
url="http://www.linuxprinting.org/foomatic.html">Foomatic</ulink>
database. Currently there are <ulink
url="http://www.linuxprinting.org/driver_list.cgi">245 drivers</ulink>
in the database. Many drivers support various models, and many models
may be driven by different drivers &smbmdash; its your choice!
</para>

<sect3>
<title>690 <quote>Perfect</quote> Printers</title>

<para>
At present, there are 690 devices dubbed as working perfectly, 181
mostly, 96 partially, and 46 are paperweights. Keeping in mind
that most of these are non-PostScript models (PostScript printers are
automatically supported by CUPS to perfection, by using
their own manufacturer-provided Windows-PPD), and that a
multi-functional device never qualifies as working perfectly if it
does not also scan and copy and fax under GNU/Linux &smbmdash; then this is a
truly astonishing achievement! Three years ago the number was not
more than 500, and Linux or UNIX printing at the time wasn't
anywhere near the quality it is today.
</para>
</sect3>

<sect3>
<title>How the Printing HOWTO Started It All</title>

<para>
A few years ago <ulink url="http://www2.picante.com:81/~gtaylor/">Grant Taylor</ulink>
started it all. The roots of today's Linuxprinting.org are in the
first <ulink url="http://www.linuxprinting.org/foomatic2.9/howto/">Linux Printing
HOWTO</ulink> that he authored. As a side-project to this document,
which served many Linux users and Admins to guide their first steps in
this complicated and delicate setup (to a scientist, printing is
<quote>applying a structured deposition of distinct patterns of ink or toner
particles on paper substrates</quote>, he started to
build in a little Postgres database with information about the
hardware and driver zoo that made up Linux printing of the time. This
database became the core component of today's Foomatic collection of
tools and data. In the meantime, it has moved to an XML representation
of the data.
</para>
</sect3>

<sect3>
<title>Foomatic's Strange Name</title>


<para>
<indexterm><primary>foomatic</primary></indexterm>
<quote>Why the funny name?</quote> you ask. When it really took off, around spring
2000, CUPS was far less popular than today, and most systems used LPD,
LPRng or even PDQ to print. CUPS shipped with a few generic drivers
(good for a few hundred different printer models). These didn't
support many device-specific options. CUPS also shipped with its own
built-in rasterization filter (<parameter>pstoraster</parameter>, derived from
Ghostscript). On the other hand, CUPS provided brilliant support for
<emphasis>controlling</emphasis> all printer options through
standardized and well-defined PPD files (PostScript Printers
Description files). Plus, CUPS was designed to be easily extensible.
</para>

<para>
Taylor already had in his database a respectable compilation
of facts about many more printers and the Ghostscript <quote>drivers</quote>
they run with. His idea, to generate PPDs from the database information
and use them to make standard Ghostscript filters work within CUPS,
proved to work very well. It also killed several birds with one
stone:
</para>

<itemizedlist>
<listitem><para>It made all current and future Ghostscript filter
developments available for CUPS.</para></listitem>

<listitem><para>It made available a lot of additional printer models
to CUPS users (because often the traditional Ghostscript way of
printing was the only one available).</para></listitem>

<listitem><para>It gave all the advanced CUPS options (Web interface,
GUI driver configurations) to users wanting (or needing) to use
Ghostscript filters.</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>cupsomatic, pdqomatic, lpdomatic, directomatic</title>


<para>
<indexterm><primary>cupsomatic</primary></indexterm>
<indexterm><primary>CUPS-PPD</primary></indexterm>
<indexterm><primary>PPD</primary><secondary>CUPS</secondary><see>CUPS-PPD</see></indexterm>
CUPS worked through a quickly-hacked up filter script named <ulink
url="http://www.linuxprinting.org/download.cgi?filename=cupsomatic&amp;show=0">cupsomatic.</ulink>
cupsomatic ran the printfile through Ghostscript, constructing
automatically the rather complicated command line needed. It just
needed to be copied into the CUPS system to make it work. To
configure the way cupsomatic controls the Ghostscript rendering
process, it needs a CUPS-PPD. This PPD is generated directly from the
contents of the database. For CUPS and the respective printer/filter
combo, another Perl script named CUPS-O-Matic did the PPD
generation. After that was working, Taylor implemented within a few
days a similar thing for two other spoolers. Names chosen for the
config-generator scripts were <ulink
url="http://www.linuxprinting.org/download.cgi?filename=lpdomatic&amp;show=0">PDQ-O-Matic</ulink>
(for PDQ) and <ulink
url="http://www.linuxprinting.org/download.cgi?filename=lpdomatic&amp;show=0">LPD-O-Matic</ulink>
(for &smbmdash; you guessed it &smbmdash; LPD); the configuration here didn't use PPDs
but other spooler-specific files.
</para>

<para>
From late summer of that year, <ulink url="http://www.linuxprinting.org/till/">Till Kamppeter</ulink>
started to put work into the database. Kamppeter had been newly employed by
<ulink url="http://www.mandrakesoft.com/">MandrakeSoft</ulink> to
convert its printing system over to CUPS, after they had seen his
<ulink url="http://www.fltk.org/">FLTK</ulink>-based <ulink
url="http://cups.sourceforge.net/xpp/">XPP</ulink> (a GUI front-end to
the CUPS lp-command). He added a huge amount of new information and new
printers. He also developed the support for other spoolers, like
<ulink url="http://ppr.sourceforge.net/">PPR</ulink> (via ppromatic),
<ulink url="http://sourceforge.net/projects/lpr/">GNUlpr</ulink> and
<ulink url="http://www.lprng.org/">LPRng</ulink> (both via an extended
lpdomatic) and spooler-less printing (<ulink
url="http://www.linuxprinting.org/download.cgi?filename=directomatic&amp;show=0">directomatic</ulink>).
</para>

<para>
So, to answer your question: <quote>Foomatic</quote> is the general name for all
the overlapping code and data behind the <quote>*omatic</quote> scripts.
Foomatic, up to versions 2.0.x, required (ugly) Perl data structures
attached to Linuxprinting.org PPDs for CUPS. It had a different
<quote>*omatic</quote> script for every spooler, as well as different printer
configuration files.
</para>
</sect3>

<sect3>
<title>The <emphasis>Grand Unification</emphasis> Achieved</title>


<para>
<indexterm><primary>foomatic-rip</primary></indexterm>
This has all changed in Foomatic versions 2.9 (beta) and released as
<quote>stable</quote> 3.0. It has now achieved the convergence of all *omatic
scripts and is called the <ulink
url="http://www.linuxprinting.org/foomatic2.9/download.cgi?filename=foomatic-rip&amp;show=0">foomatic-rip.</ulink>
This single script is the unification of the previously different
spooler-specific *omatic scripts. foomatic-rip is used by all the
different spoolers alike and because it can read PPDs (both the
original PostScript printer PPDs and the Linuxprinting.org-generated
ones), all of a sudden all supported spoolers can have the power of
PPDs at their disposal. Users only need to plug foomatic-rip into
their system. For users there is improved media type and source
support &smbmdash; paper sizes and trays are easier to configure.
</para>

<para>
Also, the New Generation of Linuxprinting.org PPDs no longer contains
Perl data structures. If you are a distro maintainer and have
used the previous version of Foomatic, you may want to give the new
one a spin, but remember to generate a new-version set of PPDs
via the new <ulink
url="http://www.linuxprinting.org/download/foomatic/foomatic-db-engine-3.0.0beta1.tar.gz">foomatic-db-engine!</ulink>
Individual users just need to generate a single new PPD specific to
their model by <ulink
url="http://www.linuxprinting.org/kpfeifle/LinuxKongress2002/Tutorial/II.Foomatic-User/II.tutorial-handout-foomatic-user.html">following
the steps</ulink> outlined in the Foomatic tutorial or in this chapter. This new development is truly amazing.
</para>

<para>
foomatic-rip is a very clever wrapper around the need to run
Ghostscript with a different syntax, options, device selections, and/or filters for each different printer
or spooler. At the same time it can read the PPD associated
with a print queue and modify the print job according to the user
selections. Together with this comes the 100% compliance of the new
Foomatic PPDs with the Adobe spec. Some innovative features of
the Foomatic concept may surprise users. It will support custom paper
sizes for many printers and will support printing on media drawn
from different paper trays within the same job (in both cases, even
where there is no support for this from Windows-based vendor printer
drivers).
</para>
</sect3>

<sect3>
<title>Driver Development Outside</title>

<para>
Most driver development itself does not happen within
Linuxprinting.org. Drivers are written by independent maintainers.
Linuxprinting.org just pools all the information and stores it in its
database. In addition, it also provides the Foomatic glue to integrate
the many drivers into any modern (or legacy) printing system known to
the world.
</para>

<para>
Speaking of the different driver development groups, most of
the work is currently done in three projects. These are:
</para>

<itemizedlist>
<listitem><para><ulink
url="http://www-124.ibm.com/developerworks/oss/linux/projects/omni/">Omni</ulink>
&smbmdash; a free software project by IBM that tries to convert their printer
driver knowledge from good-ol' OS/2 times into a modern, modular,
universal driver architecture for Linux/UNIX (still beta). This
currently supports 437 models.</para></listitem>

<listitem><para><ulink url="http://hpinkjet.sf.net/">HPIJS</ulink> &smbmdash;
a free software project by HP to provide the support for their own
range of models (very mature, printing in most cases is perfect and
provides true photo quality). This currently supports 369
models.</para></listitem>

<listitem><para><ulink
url="http://gimp-print.sf.net/">Gimp-Print</ulink> &smbmdash; a free software
effort, started by Michael Sweet (also lead developer for CUPS), now
directed by Robert Krawitz, which has achieved an amazing level of
photo print quality (many Epson users swear that its quality is
better than the vendor drivers provided by Epson for the Microsoft
platforms). This currently supports 522 models.</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Forums, Downloads, Tutorials, Howtos &smbmdash; also for Mac OS X and Commercial UNIX</title>

<para>
Linuxprinting.org today is the one-stop shop to download printer
drivers. Look for printer information and <ulink
url="http://www.linuxprinting.org//kpfeifle/LinuxKongress2002/Tutorial/">tutorials</ulink>
or solve printing problems in its popular <ulink
url="http://www.linuxprinting.org/newsportal/">forums.</ulink> This forum 
it's not just for GNU/Linux users, but admins of <ulink
url="http://www.linuxprinting.org/macosx/">commercial UNIX
systems</ulink> are also going there, and the relatively new <ulink
url="http://www.linuxprinting.org/newsportal/thread.php3?name=linuxprinting.macosx.general">Mac
OS X forum</ulink> has turned out to be one of the most frequented
forums after only a few weeks.
</para>

<para>
Linuxprinting.org and the Foomatic driver wrappers around Ghostscript
are now a standard tool-chain for printing on all the important
distros. Most of them also have CUPS underneath. While in recent years
most printer data had been added by Kamppeter (who works at Mandrake), many
additional contributions came from engineers with SuSE, Red Hat,
Conectiva, Debian, and others. Vendor-neutrality is an important goal
of the Foomatic project.
</para>

<note><para>
Till Kamppeter from MandrakeSoft is doing an excellent job in his
spare time to maintain Linuxprinting.org and Foomatic. So if you use
it often, please send him a note showing your appreciation.
</para></note>
</sect3>

<sect3>
<title>Foomatic Database-Generated PPDs</title>

<para>
The Foomatic database is an amazing piece of ingenuity in itself. Not
only does it keep the printer and driver information, but it is
organized in a way that it can generate PPD files on the fly from
its internal XML-based datasets. While these PPDs are modeled to the
Adobe specification of PostScript Printer Descriptions (PPDs), the
Linuxprinting.org/Foomatic-PPDs do not normally drive PostScript
printers. They are used to describe all the bells and whistles you
could ring or blow on an Epson Stylus inkjet, or a HP Photosmart, or
what-have-you. The main trick is one little additional line, not
envisaged by the PPD specification, starting with the <parameter>*cupsFilter</parameter>
keyword. It tells the CUPS daemon how to proceed with the PostScript
print file (old-style Foomatic-PPDs named the
cupsomatic filter script, while the new-style
PPDs are now call foomatic-rip). This filter
script calls Ghostscript on the host system (the recommended variant
is ESP Ghostscript) to do the rendering work. foomatic-rip knows which
filter or internal device setting it should ask from Ghostscript to
convert the PostScript print job into a raster format ready for the
target device. This usage of PPDs to describe the options of non-PS
printers was the invention of the CUPS developers. The rest is easy.
GUI tools (like KDE's marvelous <ulink
url="http://printing.kde.org/overview/kprinter.phtml">kprinter,</ulink>
or the GNOME <ulink
url="http://gtklp.sourceforge.net/">gtklp,</ulink> xpp and the CUPS
Web interface) read the PPD as well and use this information to present
the available settings to the user as an intuitive menu selection.
</para>
</sect3>
</sect2>

<sect2>
<title>foomatic-rip and Foomatic-PPD Download and Installation</title>

<para>
Here are the steps to install a foomatic-rip driven LaserJet 4 Plus-compatible
printer in CUPS (note that recent distributions of SuSE, UnitedLinux and
Mandrake may ship with a complete package of Foomatic-PPDs plus the
<command>foomatic-rip</command> utility. Going directly to
Linuxprinting.org ensures that you get the latest driver/PPD files):
</para>

<itemizedlist>
<listitem><para>Open your browser at the Linuxprinting.org printer list<ulink url="http://www.linuxprinting.org/printer_list.cgi">page.</ulink>
</para></listitem>

<listitem><para>Check the complete list of printers in the 
<ulink url="http://www.linuxprinting.org/printer_list.cgi?make=Anyone">database.</ulink>.
</para></listitem>

<listitem><para>Select your model and click on the link.
</para></listitem>

<listitem><para>You'll arrive at a page listing all drivers working with this
model (for all printers, there will always be <emphasis>one</emphasis>
recommended driver. Try this one first).
</para></listitem>

<listitem><para>In our case (HP LaserJet 4 Plus), we'll arrive at the default driver for the
<ulink url="http://www.linuxprinting.org/show_printer.cgi?recnum=HP-LaserJet_4_Plus">HP-LaserJet 4 Plus.</ulink>
</para></listitem>

<listitem><para>The recommended driver is ljet4.</para></listitem>

<listitem><para>Several links are provided here. You should visit them all if you
are not familiar with the Linuxprinting.org database.
</para></listitem>

<listitem><para>There is a link to the database page for the
<ulink url="http://www.linuxprinting.org/show_driver.cgi?driver=ljet4">ljet4.</ulink>
On the driver's page, you'll find important and detailed information
about how to use that driver within the various available
spoolers.</para></listitem>

<listitem><para>Another link may lead you to the home-page of the
driver author or the driver.</para></listitem>

<listitem><para>Important links are the ones that provide hints with
setup instructions for <ulink noescape="1" url="http://www.linuxprinting.org/cups-doc.html">CUPS</ulink>,
<ulink url="http://www.linuxprinting.org/pdq-doc.html">PDQ</ulink>,
<ulink url="http://www.linuxprinting.org/lpd-doc.html">LPD, LPRng and GNUlpr</ulink>)
as well as <ulink url="http://www.linuxprinting.org/ppr-doc.html">PPR</ulink>
or <quote>spooler-less</quote> <ulink url="http://www.linuxprinting.org/direct-doc.html">printing.</ulink>
</para></listitem>

<listitem><para>You can view the PPD in your browser through this link:
<ulink noescape="1" url="http://www.linuxprinting.org/ppd-o-matic.cgi?driver=ljet4&amp;printer=HP-LaserJet_4_Plus&amp;show=1">http://www.linuxprinting.org/ppd-o-matic.cgi?driver=ljet4&amp;printer=HP-LaserJet_4_Plus&amp;show=1</ulink>
</para></listitem> <listitem><para>Most importantly, you can also generate and download
the <ulink url="http://www.linuxprinting.org/ppd-o-matic.cgi?driver=ljet4&amp;printer=HP-LaserJet_4_Plus&amp;show=0">PPD.</ulink>
</para></listitem>

<listitem><para>The PPD contains all the information needed to use our
model and the driver; once installed, this works transparently
for the user. Later you'll only need to choose resolution, paper size,
and so on from the Web-based menu, or from the print dialog GUI, or from
the command line.</para></listitem>

<listitem><para>If you ended up on the drivers
<ulink url="http://www.linuxprinting.org/show_driver.cgi?driver=ljet4">page</ulink>
you can choose to use the <quote>PPD-O-Matic</quote> online PPD generator
program.</para></listitem>

<listitem><para>Select the exact model and check either <guilabel>Download</guilabel> or
<guilabel>Display PPD file</guilabel> and click <guilabel>Generate PPD file</guilabel>.</para></listitem>

<listitem><para>If you save the PPD file from the browser view, please
do not use cut and paste (since it could possibly damage line endings
and tabs, which makes the PPD likely to fail its duty), but use <guimenuitem>Save
as...</guimenuitem> in your browsers menu. (It is best to use the <guilabel>Download</guilabel> option
directly from the Web page).</para></listitem>

<listitem><para>Another interesting part on each driver page is
the <guimenuitem>Show execution details</guimenuitem> button. If you
select your printer model and click on that button,
a complete Ghostscript command line will be displayed, enumerating all options
available for that combination of driver and printer model. This is a great way to
<quote>learn Ghostscript by doing</quote>. It is also an excellent cheat sheet
for all experienced users who need to re-construct a good command line
for that damn printing script, but can't remember the exact
syntax. </para></listitem>

<listitem><para>Some time during your visit to Linuxprinting.org, save
the PPD to a suitable place on your hard-disk, say
<filename>/path/to/my-printer.ppd</filename> (if you prefer to install
your printers with the help of the CUPS Web interface, save the PPD to
the <filename>/usr/share/cups/model/</filename> path and restart
cupsd).</para></listitem>

<listitem><para>Then install the printer with a suitable command line,
like this: 
</para>

<para><screen>
&rootprompt;<userinput>lpadmin -p laserjet4plus -v parallel:/dev/lp0 -E \
	-P path/to/my-printer.ppd</userinput>
</screen></para></listitem>

<listitem><para>For all the new-style <quote>Foomatic-PPDs</quote>
from Linuxprinting.org, you also need a special CUPS filter named
foomatic-rip. 
</para></listitem>

<listitem><para>The foomatic-rip Perl script itself also makes some
interesting <ulink url="http://www.linuxprinting.org/foomatic2.9/download.cgi?filename=foomatic-rip&amp;show=1">reading</ulink>
because it is well documented by Kamppeter's in-line comments (even
non-Perl hackers will learn quite a bit about printing by reading
it).</para></listitem>

<listitem><para>Save foomatic-rip either directly in
<filename>/usr/lib/cups/filter/foomatic-rip</filename> or somewhere in
your $PATH (and remember to make it world-executable). Again,
do not save by copy and paste but use the appropriate link or the
<guimenuitem>Save as...</guimenuitem>  menu item in your browser.</para></listitem>

<listitem><para>If you save foomatic-rip in your $PATH, create a symlink:
<screen>
&rootprompt;<userinput>cd /usr/lib/cups/filter/ ; ln -s `which foomatic-rip'</userinput>
</screen>
</para>

<para>
CUPS will discover this new available filter at startup after restarting
cupsd.</para></listitem>
</itemizedlist>

<para>
Once you print to a print queue set up with the Foomatic-PPD, CUPS will
insert the appropriate commands and comments into the resulting
PostScript jobfile. foomatic-rip is able to read and act upon
these and uses some specially encoded Foomatic comments
embedded in the jobfile. These in turn are used to construct
(transparently for you, the user) the complicated Ghostscript command
line telling the printer driver exactly how the resulting raster
data should look and which printer commands to embed into the
data stream. You need:
</para>

<itemizedlist>

<listitem><para>A <quote>foomatic+something</quote> PPD &smbmdash; but this is not enough
to print with CUPS (it is only <emphasis>one</emphasis> important
component).</para></listitem>

<listitem><para>The <parameter>foomatic-rip</parameter> filter script (Perl) in
<filename>/usr/lib/cups/filters/</filename>.</para></listitem>

<listitem><para>Perl to make foomatic-rip run.</para></listitem>

<listitem><para>Ghostscript (because it is doing the main work,
controlled by the PPD/foomatic-rip combo) to produce the raster data
fit for your printer model's consumption.</para></listitem>

<listitem><para>Ghostscript <emphasis>must</emphasis> (depending on
the driver/model) contain support for a certain device representing
the selected driver for your model (as shown by <command>gs
	-h</command>).</para></listitem>

<listitem><para>foomatic-rip needs a new version of PPDs (PPD versions
produced for cupsomatic do not work with
foomatic-rip).</para></listitem>
</itemizedlist>
</sect2>
</sect1>

<sect1>
<title>Page Accounting with CUPS</title>


<para>
<indexterm><primary>CUPS</primary><secondary>Page Accounting</secondary></indexterm>
Often there are questions regarding print quotas where Samba users
(that is, Windows clients) should not be able to print beyond a
certain number of pages or data volume per day, week or month. This
feature is dependent on the real print subsystem you're using.
Samba's part is always to receive the job files from the clients
(filtered <emphasis>or</emphasis> unfiltered) and hand it over to this
printing subsystem.
</para>

<para>
Of course one could hack things with one's own scripts. But then
there is CUPS. CUPS supports quotas that can be based on the size of
jobs or on the number of pages or both, and span any time
period you want.
</para>

<sect2>
<title>Setting Up Quotas</title>

<para>
<indexterm><primary>CUPS</primary><secondary>quotas</secondary></indexterm>
This is an example command of how root would set a print quota in CUPS,
assuming an existing printer named <quote>quotaprinter</quote>:
</para>


<para>
<indexterm><primary>lpadmin</primary></indexterm>
	<screen>
&rootprompt;<userinput>lpadmin -p quotaprinter -o job-quota-period=604800 \
	-o job-k-limit=1024 -o job-page-limit=100</userinput>
</screen></para>

<para>
This would limit every single user to print 100 pages or 1024 KB of
data (whichever comes first) within the last 604,800 seconds ( = 1
week).
</para>
</sect2>

<sect2>
<title>Correct and Incorrect Accounting</title>

<para>
For CUPS to count correctly, the printfile needs to pass the CUPS
pstops filter, otherwise it uses a dummy count of <quote>one</quote>. Some
print files do not pass it (e.g., image files) but then those are mostly one-
page jobs anyway. This also means that proprietary drivers for the
target printer running on the client computers and CUPS/Samba, which
then spool these files as <quote>raw</quote> (i.e., leaving them untouched, not
filtering them), will be counted as one-pagers too!
</para>

<para>
You need to send PostScript from the clients (i.e., run a PostScript
driver there) to have the chance to get accounting done. If the
printer is a non-PostScript model, you need to let CUPS do the job to
convert the file to a print-ready format for the target printer. This
is currently working for about a thousand different printer models.
Linuxprinting has a driver
<ulink url="http://www.linuxprinting.org/printer_list.cgi">list.</ulink>
</para>
</sect2>

<sect2>
<title>Adobe and CUPS PostScript Drivers for Windows Clients</title>

<para>
Before CUPS 1.1.16, your only option was to use the Adobe PostScript
Driver on the Windows clients. The output of this driver was not
always passed through the <command>pstops</command> filter on the CUPS/Samba side, and
therefore was not counted correctly (the reason is that it often,
depending on the PPD being used, wrote a PJL-header in front of
the real PostScript which caused CUPS to skip <command>pstops</command> and go directly
to the <command>pstoraster</command> stage).
</para>

<para>
From CUPS 1.1.16 onward, you can use the CUPS PostScript Driver for
Windows <?latex \linebreak ?>NT/200x/XP clients (which is tagged in the download area of
<filename>http://www.cups.org/</filename> as the <filename>cups-samba-1.1.16.tar.gz</filename>
package). It does <emphasis>not</emphasis> work for Windows 9x/ME clients, but it guarantees:
</para>

<itemizedlist>

<listitem><para> <indexterm><primary>PJL</primary></indexterm> To not write a PJL-header.</para></listitem>

<listitem><para>To still read and support all PJL-options named in the
driver PPD with its own means.</para></listitem>

<listitem><para>That the file will pass through the <command>pstops</command> filter
on the CUPS/Samba server.</para></listitem>

<listitem><para>To page-count correctly the print file.</para></listitem>
</itemizedlist>

<para>
You can read more about the setup of this combination in the man page
for <command>cupsaddsmb</command> (which is only present with CUPS installed, and only
current from CUPS 1.1.16).
</para>
</sect2>

<sect2>
<title>The page_log File Syntax</title>

<para>
<indexterm><primary>page_log</primary></indexterm>
These are the items CUPS logs in the <filename>page_log</filename> for every
page of a job:
</para>

<itemizedlist>
<listitem><para>Printer name</para></listitem>

<listitem><para>User name</para></listitem>

<listitem><para>Job ID</para></listitem>

<listitem><para>Time of printing</para></listitem>

<listitem><para>The page number</para></listitem>

<listitem><para>The number of copies</para></listitem>

<listitem><para>A billing information string (optional)</para></listitem>

<listitem><para>The host that sent the job (included since version 1.1.19)</para></listitem>
</itemizedlist>

<para>
Here is an extract of my CUPS server's <filename>page_log</filename> file to illustrate the
format and included items:
</para>

<para><screen>
tec_IS2027 kurt 401 [22/Apr/2003:10:28:43 +0100] 1 3 #marketing 10.160.50.13
tec_IS2027 kurt 401 [22/Apr/2003:10:28:43 +0100] 2 3 #marketing 10.160.50.13
tec_IS2027 kurt 401 [22/Apr/2003:10:28:43 +0100] 3 3 #marketing 10.160.50.13
tec_IS2027 kurt 401 [22/Apr/2003:10:28:43 +0100] 4 3 #marketing 10.160.50.13
Dig9110 boss 402 [22/Apr/2003:10:33:22 +0100] 1 440 finance-dep 10.160.51.33
</screen></para>

<para>
This was job ID <parameter>401</parameter>, printed on <parameter>tec_IS2027</parameter>
by user <parameter>kurt</parameter>, a 64-page job printed in three copies and billed to
<parameter>#marketing</parameter>, sent from IP address <constant>10.160.50.13.</constant>
 The next job had ID <parameter>402</parameter>, was sent by user <parameter>boss</parameter>
from IP address <constant>10.160.51.33</constant>, printed from one page 440 copies and
is set to be billed to <parameter>finance-dep</parameter>.
</para>
</sect2>

<sect2>
<title>Possible Shortcomings</title>

<para>
What flaws or shortcomings are there with this quota system?
</para>

<itemizedlist>
<listitem><para>The ones named above (wrongly logged job in case of
printer hardware failure, and so on).</para></listitem>

<listitem><para>In reality, CUPS counts the job pages that are being
processed in <emphasis>software</emphasis> (that is, going through the
RIP) rather than the physical sheets successfully leaving the
printing device. Thus if there is a jam while printing the fifth sheet out
of a thousand and the job is aborted by the printer, the page count will
still show the figure of a thousand for that job.</para></listitem>

<listitem><para>All quotas are the same for all users (no flexibility
to give the boss a higher quota than the clerk) and no support for
groups.</para></listitem>

<listitem><para>No means to read out the current balance or the
<quote>used-up</quote> number of current quota.</para></listitem>

<listitem><para>A user having used up 99 sheets of a 100 quota will
still be able to send and print a thousand sheet job.</para></listitem>

<listitem><para>A user being denied a job because of a filled-up quota
does not get a meaningful error message from CUPS other than
<quote>client-error-not-possible</quote>.</para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>Future Developments</title>

<para>
This is the best system currently available, and there are huge
improvements under development for CUPS 1.2:
</para>

<itemizedlist>
<listitem><para>Page counting will go into the backends (these talk
directly to the printer and will increase the count in sync with the
actual printing process; thus, a jam at the fifth sheet will lead to a
stop in the counting).</para></listitem>

<listitem><para>Quotas will be handled more flexibly.</para></listitem>

<listitem><para>Probably there will be support for users to inquire
about their accounts in advance.</para></listitem>

<listitem><para>Probably there will be support for some other tools
around this topic.</para></listitem>
</itemizedlist>
</sect2>

<!-- FIXME
<sect2>
<title>Other Accounting Tools</title>

<para>
PrintAnalyzer, pyKota, printbill, LogReport.
</para>
</sect2>
-->
</sect1>

<sect1>
<title>Additional Material</title>

<para>
A printer queue with <emphasis>no</emphasis> PPD associated to it is a
<quote>raw</quote> printer and all files will go directly there as received by the
spooler. The exceptions are file types <parameter>application/octet-stream</parameter>
that need pass-through feature enabled. <quote>Raw</quote> queues do not do any
filtering at all, they hand the file directly to the CUPS backend.
This backend is responsible for sending the data to the device
(as in the <quote>device URI</quote> notation: <filename>lpd://, socket://,
smb://, ipp://, http://, parallel:/, serial:/, usb:/</filename>, and so on).
</para>

<para>
cupsomatic/Foomatic are <emphasis>not</emphasis> native CUPS drivers
and they do not ship with CUPS. They are a third party add-on
developed at Linuxprinting.org. As such, they are a brilliant hack to
make all models (driven by Ghostscript drivers/filters in traditional
spoolers) also work via CUPS, with the same (good or bad!) quality as
in these other spoolers. <parameter>cupsomatic</parameter> is only a vehicle to execute a
Ghostscript command-line at that stage in the CUPS filtering chain,
where normally the native CUPS <parameter>pstoraster</parameter> filter would kick
in. cupsomatic bypasses pstoraster, kidnaps the printfile from CUPS
away and redirects it to go through Ghostscript. CUPS accepts this,
because the associated cupsomatic/foomatic-PPD specifies:

<filterline>
  *cupsFilter:  "application/vnd.cups-postscript 0 cupsomatic"
</filterline>

This line persuades CUPS to hand the file to cupsomatic, once it has
successfully converted it to the MIME type
<parameter>application/vnd.cups-postscript</parameter>. This conversion will not happen for
Jobs arriving from Windows that are auto-typed
<parameter>application/octet-stream</parameter>, with the according changes in
<filename>/etc/cups/mime.types</filename> in place.
</para>

<para>
CUPS is widely configurable and flexible, even regarding its filtering
mechanism. Another workaround in some situations would be to have in
<filename>/etc/cups/mime.types</filename> entries as follows:

<filterline>
 application/postscript           application/vnd.cups-raw  0  -
 application/vnd.cups-postscript  application/vnd.cups-raw  0  -
</filterline>

This would prevent all PostScript files from being filtered (rather,
they will through the virtual <emphasis>nullfilter</emphasis>
denoted with <quote>-</quote>). This could only be useful for PS printers. If you
want to print PS code on non-PS printers (provided they support ASCII
text printing), an entry as follows could be useful:

<filterline>
 */*           application/vnd.cups-raw  0  -
</filterline>

and would effectively send <emphasis>all</emphasis> files to the
backend without further processing.
</para>

<para>
You could have the following entry:

<filterline>
application/vnd.cups-postscript application/vnd.cups-raw 0 \
	my_PJL_stripping_filter
</filterline>

You will need to write a <parameter>my_PJL_stripping_filter</parameter>
(which could be a shell script) that parses the PostScript and removes the
unwanted PJL. This needs to conform to CUPS filter design
(mainly, receive and pass the parameters printername, job-id,
username, jobtitle, copies, print options and possibly the
filename). It is installed as world executable into
<filename>/usr/lib/cups/filters/</filename> and is called by CUPS
if it encounters a MIME type <parameter>application/vnd.cups-postscript</parameter>.
</para>

<para>
CUPS can handle <parameter>-o job-hold-until=indefinite</parameter>.
This keeps the job in the queue on hold. It will only be printed
upon manual release by the printer operator. This is a requirement in
many central reproduction departments, where a few operators manage
the jobs of hundreds of users on some big machine, where no user is
allowed to have direct access (such as when the operators often need
to load the proper paper type before running the 10,000 page job
requested by marketing for the mailing, and so on).
</para>
</sect1>

<sect1>
<title>Auto-Deletion or Preservation of CUPS Spool Files</title>

<para>
Samba print files pass through two spool directories. One is the
incoming directory managed by Samba, (set in the
<smbconfoption><name>path</name><value>/var/spool/samba</value></smbconfoption>
directive in the <smbconfsection>[printers]</smbconfsection> section of
&smb.conf;). The other is the spool directory of
your UNIX print subsystem. For CUPS it is normally
<filename>/var/spool/cups/</filename>, as set by the <filename>cupsd.conf</filename>
directive <filename>RequestRoot /var/spool/cups</filename>.
</para>

<sect2>
<title>CUPS Configuration Settings Explained</title>

<para>
Some important parameter settings in the CUPS configuration file
<filename>cupsd.conf</filename> are:
</para>

<variablelist>

<varlistentry><term>PreserveJobHistory Yes</term>
<listitem><para>
This keeps some details of jobs in cupsd's mind (well it keeps the
c12345, c12346, and so on, files in the CUPS spool directory, which do a
similar job as the old-fashioned BSD-LPD control files). This is set
to <quote>Yes</quote> as a default.
</para></listitem></varlistentry>

<varlistentry><term>PreserveJobFiles Yes</term>
<listitem><para>
This keeps the job files themselves in cupsd's mind
(it keeps the d12345, d12346 etc. files in the CUPS spool
directory). This is set to <quote>No</quote> as the CUPS
default.
</para></listitem></varlistentry>

<varlistentry><term><emphasis><quote>MaxJobs 500</quote></emphasis></term>
<listitem><para>
This directive controls the maximum number of jobs
that are kept in memory. Once the number of jobs reaches the limit,
the oldest completed job is automatically purged from the system to
make room for the new one. If all of the known jobs are still
pending or active, then the new job will be rejected. Setting the
maximum to 0 disables this functionality. The default setting is
0.
</para></listitem></varlistentry>
</variablelist>

<para>
(There are also additional settings for <parameter>MaxJobsPerUser</parameter> and
<parameter>MaxJobsPerPrinter</parameter>...)
</para>
</sect2>

<sect2>
<title>Pre-Conditions</title>

<para>
For everything to work as announced, you need to have three
things:
</para>

<itemizedlist>
<listitem><para>A Samba-smbd that is compiled against <filename>libcups</filename> (check
on Linux by running <userinput>ldd `which smbd'</userinput>).</para></listitem>

<listitem><para>A Samba-&smb.conf; setting of
		<smbconfoption><name>printing</name><value>cups</value></smbconfoption>.</para></listitem>

<listitem><para>Another Samba-&smb.conf; setting of
		<smbconfoption><name>printcap</name><value>cups</value></smbconfoption>.</para></listitem>
</itemizedlist>

<note><para>
In this case, all other manually set printing-related commands (like
<smbconfoption><name>print command</name></smbconfoption>, 
<smbconfoption><name>lpq command</name></smbconfoption>, 
<smbconfoption><name>lprm command</name></smbconfoption>, 
<smbconfoption><name>lppause command</name></smbconfoption> or
<smbconfoption><name>lpresume command</name></smbconfoption>) are ignored and they should normally have no
influence whatsoever on your printing.
</para></note>
</sect2>

<sect2>
<title>Manual Configuration</title>

<para>
If you want to do things manually, replace the <smbconfoption><name>printing</name><value>cups</value></smbconfoption>
by <smbconfoption><name>printing</name><value>bsd</value></smbconfoption>. Then your manually set commands may work
(I haven't tested this), and a <smbconfoption><name>print command</name><value>lp -d %P %s; rm %s"</value></smbconfoption>
may do what you need.
</para>
</sect2>
</sect1>

<sect1>
<title>Printing from CUPS to Windows Attached Printers</title>

<para>
>From time to time the question arises, how can you print
<emphasis>to</emphasis> a Windows attached printer
<emphasis>from</emphasis> Samba? Normally the local connection
from Windows host to printer would be done by USB or parallel
cable, but this does not matter to Samba. From here only an SMB
connection needs to be opened to the Windows host. Of course, this
printer must be shared first. As you have learned by now, CUPS uses
<emphasis>backends</emphasis> to talk to printers and other
servers. To talk to Windows shared printers, you need to use the
<filename>smb</filename> (surprise, surprise!) backend. Check if this
is in the CUPS backend directory. This usually resides in
<filename>/usr/lib/cups/backend/</filename>. You need to find an <filename>smb</filename>
file there. It should be a symlink to <filename>smbspool</filename>
and the file must exist and be executable:
</para>

<para><screen>
&rootprompt;<userinput>ls -l /usr/lib/cups/backend/</userinput>
total 253
drwxr-xr-x    3 root   root     720 Apr 30 19:04 .
drwxr-xr-x    6 root   root     125 Dec 19 17:13 ..
-rwxr-xr-x    1 root   root   10692 Feb 16 21:29 canon
-rwxr-xr-x    1 root   root   10692 Feb 16 21:29 epson
lrwxrwxrwx    1 root   root       3 Apr 17 22:50 http -&gt; ipp
-rwxr-xr-x    1 root   root   17316 Apr 17 22:50 ipp
-rwxr-xr-x    1 root   root   15420 Apr 20 17:01 lpd
-rwxr-xr-x    1 root   root    8656 Apr 20 17:01 parallel
-rwxr-xr-x    1 root   root    2162 Mar 31 23:15 pdfdistiller
lrwxrwxrwx    1 root   root      25 Apr 30 19:04 ptal -&gt; /usr/sbin/ptal-cups
-rwxr-xr-x    1 root   root    6284 Apr 20 17:01 scsi
lrwxrwxrwx    1 root   root      17 Apr  2 03:11 smb -&gt; /usr/bin/smbspool
-rwxr-xr-x    1 root   root    7912 Apr 20 17:01 socket
-rwxr-xr-x    1 root   root    9012 Apr 20 17:01 usb

&rootprompt;<userinput>ls -l `which smbspool`</userinput>
-rwxr-xr-x    1 root   root  563245 Dec 28 14:49 /usr/bin/smbspool
</screen></para>

<para>
If this symlink does not exist, create it:
</para>

<para><screen>
&rootprompt;<userinput>ln -s `which smbspool` /usr/lib/cups/backend/smb</userinput>
</screen></para>

<para>
<command>smbspool</command> has been written by Mike Sweet from the CUPS folks. It is
included and ships with Samba. It may also be used with print
subsystems other than CUPS, to spool jobs to Windows printer shares. To
set up printer <replaceable>winprinter</replaceable> on CUPS, you need to have a driver for
it. Essentially this means to convert the print data on the CUPS/Samba
host to a format that the printer can digest (the Windows host is
unable to convert any files you may send). This also means you should
be able to print to the printer if it were hooked directly at your
Samba/CUPS host. For troubleshooting purposes, this is what you
should do to determine if that part of the process chain is in
order. Then proceed to fix the network connection/authentication to
the Windows host, and so on.
</para>

<para>
To install a printer with the <parameter>smb</parameter> backend on CUPS, use this command:
</para>

<para><screen>
&rootprompt;<userinput>lpadmin -p winprinter -v smb://WINDOWSNETBIOSNAME/printersharename \
  -P /path/to/PPD</userinput>
</screen></para>

<para>
The PPD must be able to direct CUPS to generate
the print data for the target model. For PostScript printers, just use
the PPD that would be used with the Windows NT PostScript driver. But
what can you do if the printer is only accessible with a password? Or
if the printer's host is part of another workgroup? This is provided
for: You can include the required parameters as part of the
<filename>smb://</filename> device-URI like this:
</para>

<itemizedlist>
	<listitem><filename>smb://WORKGROUP/WINDOWSNETBIOSNAME/printersharename</filename></listitem>
	<listitem><filename>smb://username:password@WORKGROUP/WINDOWSNETBIOSNAME/printersharename</filename></listitem>
	<listitem><filename>smb://username:password@WINDOWSNETBIOSNAME/printersharename</filename></listitem>
</itemizedlist>

<para>
Note that the device-URI will be visible in the process list of the
Samba server (e.g., when someone uses the <command>ps -aux</command>
command on Linux), even if the username and passwords are sanitized
before they get written into the log files. So this is an inherently
insecure option, however, it is the only one. Don't use it if you want
to protect your passwords. Better share the printer in a way that
does not require a password! Printing will only work if you have a
working netbios name resolution up and running. Note that this is a
feature of CUPS and you do not necessarily need to have smbd running.

</para>
</sect1>

<sect1>
<title>More CUPS-Filtering Chains</title>

<para>
The following diagrams reveal how CUPS handles print jobs.
</para>

<image id="cups1"><imagefile>cups1</imagefile><imagedescription>Filtering chain 1.</imagedescription></image>

<image id="cups2"><imagefile>cups2</imagefile><imagedescription>Filtering chain with cupsomatic</imagedescription></image>

</sect1>

<sect1>
	<title>Common Errors</title>

	<sect2>
		<title>Windows 9x/ME Client Can't Install Driver</title>

		<para>For Windows 9x/ME, clients require the printer names to be eight
characters (or <quote>8 plus 3 chars suffix</quote>) max; otherwise, the driver files
will not get transferred when you want to download them from
Samba.</para>

	</sect2>

	<sect2>
		<title><quote>cupsaddsmb</quote> Keeps Asking for Root Password in Never-ending Loop</title>

		<para>Have you <smbconfoption><name>security</name><value>user</value></smbconfoption>? Have
		you used <command>smbpasswd</command> to give root a Samba account?
		You can do two things: open another terminal and execute
		<command>smbpasswd -a root</command> to create the account and
		continue entering the password into the first terminal. Or break
		out of the loop by pressing ENTER twice (without trying to type a
		password).</para>

		<para>
		If the error is: <quote>tree connect failed: NT_STATUS_BAD_NETWORK_NAME</quote>, 
		you may have forgotten to create the <filename>/etc/samba/drivers</filename> directory.
		</para>

	</sect2>

	<sect2>
		<title><quote>cupsaddsmb</quote> Errors</title>

		<para>
		The use of <quote>cupsaddsmb</quote> gives <quote>No PPD file for printer...</quote> 
		Message While PPD File Is Present.  What might the problem be?
		</para>

		<para>Have you enabled printer sharing on CUPS? This means:
		Do you have a <parameter>&lt;Location
		/printers&gt;....&lt;/Location&gt;</parameter> section in CUPS
		server's <filename>cupsd.conf</filename> that does not deny access to
		the host you run <quote>cupsaddsmb</quote> from?  It <emphasis>could</emphasis> be
		an issue if you use cupsaddsmb remotely, or if you use it with a
		<option>-h</option> parameter: <userinput>cupsaddsmb -H
		sambaserver -h cupsserver -v printername</userinput>.
		</para>

		<para>Is your <parameter>TempDir</parameter> directive in
		<filename>cupsd.conf</filename> set to a valid value and is it writable?
		</para>

	</sect2>

	<sect2>
		<title>Client Can't Connect to Samba Printer</title>

	<para>Use <command>smbstatus</command> to check which user
	you are from Samba's point of view. Do you have the privileges to
	write into the <smbconfsection>[print$]</smbconfsection>
	share?</para>

	</sect2>

	<sect2>
	<title>New Account Reconnection from Windows 200x/XP Troubles</title>

<para>Once you are connected as the wrong user (for
example, as <constant>nobody</constant>, which often occurs if you have 
<smbconfoption><name>map to guest</name><value>bad user</value></smbconfoption>), Windows Explorer will not accept an
attempt to connect again as a different user. There will not be any byte
transfered on the wire to Samba, but still you'll see a stupid error
message that makes you think Samba has denied access. Use
<command>smbstatus</command> to check for active connections. Kill the
PIDs. You still can't re-connect and you get the dreaded
<computeroutput>You can't connect with a second account from the same
machine</computeroutput> message, as soon as you are trying. And you
do not see any single byte arriving at Samba (see logs; use <quote>ethereal</quote>)
indicating a renewed connection attempt. Shut all Explorer Windows.
This makes Windows forget what it has cached in its memory as
established connections. Then reconnect as the right user. The best
method is to use a DOS terminal window and <emphasis>first</emphasis>
do <userinput>net use z: \\&example.server.samba;\print$ /user:root</userinput>. Check
with <command>smbstatus</command> that you are connected under a
different account. Now open the <guilabel>Printers</guilabel> folder (on the Samba server
in the <guilabel>Network Neighborhood</guilabel>), right-click on the
printer in question and select
<guibutton>Connect...</guibutton></para></sect2>

<sect2>
<title>Avoid Being Connected to the Samba Server as the Wrong User</title>
	
<para>You see per <command>smbstatus</command> that you are
connected as user nobody; while you want to be root or
printer admin. This is probably due to 
<smbconfoption><name>map to guest</name><value>bad user</value></smbconfoption>, which silently connects you under the guest account
when you gave (maybe by accident) an incorrect username. Remove
<smbconfoption><name>map to guest</name></smbconfoption>, if you want to prevent
this.</para></sect2>

<sect2>
<title>Upgrading to CUPS Drivers from Adobe Drivers</title>

<para>
This information came from a mailing list posting regarding problems experienced when
upgrading from Adobe drivers to CUPS drivers on Microsoft Windows NT/200x/XP Clients.
</para>

<para>First delete all old Adobe-using printers. Then
delete all old Adobe drivers. (On Windows 200x/XP, right-click in
the background of <guilabel>Printers</guilabel> folder, select <guimenuitem>Server Properties...</guimenuitem>, select
tab <guilabel>Drivers</guilabel> and delete here).</para></sect2>

<sect2><title>Can't Use <quote>cupsaddsmb</quote> on Samba Server Which Is a PDC</title>
<para>Do you use the <quote>naked</quote> root user name? Try to do it
this way: <userinput>cupsaddsmb -U <replaceable>DOMAINNAME</replaceable>\\root -v
<replaceable>printername</replaceable></userinput>> (note the two backslashes: the first one is
required to <quote>escape</quote> the second one).</para></sect2>

<sect2><title>Deleted Windows 200x Printer Driver Is Still Shown</title>
<para>Deleting a printer on the client will not delete the
driver too (to verify, right-click on the white background of the
<guilabel>Printers</guilabel> folder, select <guimenuitem>Server Properties</guimenuitem> and click on the
<guilabel>Drivers</guilabel> tab). These same old drivers will be re-used when you try to
install a printer with the same name. If you want to update to a new
driver, delete the old ones first. Deletion is only possible if no
other printer uses the same driver.</para></sect2>

<sect2><title>Windows 200x/XP "Local Security Policies"</title>
<para>Local Security Policies may not
allow the installation of unsigned drivers. <quote>Local Security Policies</quote>
may not allow the installation of printer drivers at
all.</para></sect2>

<sect2><title>Administrator Cannot Install Printers for All Local Users</title>
<para>Windows XP handles SMB printers on a <quote>per-user</quote> basis.
This means every user needs to install the printer himself. To have a
printer available for everybody, you might want to use the built-in
IPP client capabilities of Win XP. Add a printer with the print path of
<parameter>http://cupsserver:631/printers/printername</parameter>.
We're still looking into this one. Maybe a logon script could
automatically install printers for all
users.</para></sect2>

<sect2><title>Print Change Notify Functions on NT-clients</title>
<para>For print change, notify functions on NT++ clients.
These need to run the <command>Server</command> service first (renamed to
<command>File &amp; Print Sharing for MS Networks</command> in
XP).</para></sect2>

<sect2>
<title>Win XP-SP1</title>

<para>Win XP-SP1 introduced a Point and Print Restriction Policy (this restriction does not apply to
<quote>Administrator</quote> or <quote>Power User</quote> groups of users). In Group Policy
Object Editor, go to <guimenu>User Configuration -> Administrative Templates ->
 Control Panel -> Printers</guimenu>. The policy is automatically set to
<constant>Enabled</constant> and the <constant>Users can only Point
and Print to machines in their Forest</constant> . You probably need
to change it to <constant>Disabled</constant> or <constant>Users can
only Point and Print to these servers</constant> to make
driver downloads from Samba possible.
</para>
</sect2>

<sect2>
<title>Print Options for All Users Can't Be Set on Windows 200x/XP</title>

<para>How are you doing it? I bet the wrong way (it is not
easy to find out, though). There are three different ways to bring
you to a dialog that <emphasis>seems</emphasis> to set everything. All
three dialogs <emphasis>look</emphasis> the same, yet only one of them
does what you intend. You need to be
Administrator or Print Administrator to do this for all users. Here
is how I do in on XP:
</para>

<orderedlist numeration="upperalpha">

<listitem><para>The first wrong way:

<orderedlist>
<listitem><para>Open the <guilabel>Printers</guilabel>
folder.</para></listitem>

<listitem><para>Right-click on the printer
(<guilabel>remoteprinter on cupshost</guilabel>) and
select in context menu <guimenuitem>Printing
Preferences...</guimenuitem></para></listitem>

<listitem><para>Look at this dialog closely and remember what it looks
like.</para></listitem>
</orderedlist>
</para>
</listitem>

<listitem><para>The second wrong way:

<orderedlist>
<listitem><para>Open the <guilabel>Printers</guilabel>
folder.</para></listitem>

<listitem><para>Right-click on the printer (<guilabel>remoteprinter on
cupshost</guilabel>) and select the context menu
<guimenuitem>Properties</guimenuitem>.</para></listitem>

<listitem><para>Click on the <guilabel>General</guilabel>
tab.</para></listitem>

<listitem><para>Click on the button <guibutton>Printing
Preferences...</guibutton></para></listitem>

<listitem><para>A new dialog opens. Keep this dialog open and go back
to the parent dialog.</para></listitem>
</orderedlist>
</para>
</listitem>

<listitem><para>The third, and the correct way: 

<orderedlist>

<listitem><para>Open the <guilabel>Printers</guilabel>
folder.</para></listitem>

<listitem><para>Click on the <guilabel>Advanced</guilabel>
tab. (If everything is <quote>grayed out,</quote> then you are not logged
in as a user with enough privileges).</para></listitem>

<listitem><para>Click on the <guibutton>Printing
Defaults...</guibutton> button.</para></listitem>

<listitem><para>On any of the two new tabs, click on the
<guibutton>Advanced...</guibutton>
button.</para></listitem>

<listitem><para>A new dialog opens. Compare this one to the other
identical looking one from <quote>B.5</quote> or A.3".</para></listitem>
</orderedlist>
</para>
</listitem>
</orderedlist>

<para>
Do you see any difference? I don't either. However, only the last
one, which you arrived at with steps <quote>C.1.-6.</quote>, will save any settings
permanently and be the defaults for new users. If you want all clients
to get the same defaults, you need to conduct these steps <emphasis>as
Administrator</emphasis> (<smbconfoption><name>printer admin</name></smbconfoption> in
&smb.conf;) <emphasis>before</emphasis> a client
downloads the driver (the clients can later set their own
<emphasis>per-user defaults</emphasis> by following the
procedures <emphasis>A</emphasis> or <emphasis>B</emphasis>
above).</para></sect2>

<sect2><title>Most Common Blunders in Driver Settings on Windows Clients</title>
<para>Don't use <parameter>Optimize for
Speed</parameter>, but use <parameter>Optimize for
Portability</parameter> instead (Adobe PS Driver). Don't use
<parameter>Page Independence: No</parameter>: always
settle with  <parameter>Page Independence:
Yes</parameter> (Microsoft PS Driver and CUPS PS Driver for
Windows NT/200x/XP). If there are problems with fonts, use
<parameter>Download as Softfont into
printer</parameter> (Adobe PS Driver). For
<guilabel>TrueType Download Options</guilabel>
choose <constant>Outline</constant>. Use PostScript
Level 2, if you are having trouble with a non-PS printer and if
there is a choice.</para></sect2>

<sect2><title><command>cupsaddsmb</command> Does Not Work with Newly Installed Printer</title>
<para>Symptom: The last command of
<command>cupsaddsmb</command> does not complete successfully:
<command>cmd = setdriver printername printername</command> result was
NT_STATUS_UNSUCCESSFUL then possibly the printer was not yet
recognized by Samba. Did it show up in Network
Neighborhood? Did it show up i n <command>rpcclient
hostname -c `enumprinters'</command>? Restart smbd (or send a
<command>kill -HUP</command> to all processes listed by
<command>smbstatus</command> and try
again.</para></sect2>

<sect2>
<title>Permissions on <filename>/var/spool/samba/</filename> Get Reset After Each Reboot</title>
<para>Have you ever by accident set the CUPS spool directory to
the same location? (<parameter>RequestRoot /var/spool/samba/</parameter> in <filename>cupsd.conf</filename> or
the other way round: <filename>/var/spool/cups/</filename> is set as
<smbconfoption><name>path</name></smbconfoption>> in the <smbconfsection>[printers]</smbconfsection>
section). These <parameter>must</parameter> be different. Set
<!--FIXME-->
<parameter>RequestRoot /var/spool/cups/</parameter> in
<filename>cupsd.conf</filename> and <smbconfoption><name>path</name><value>
/var/spool/samba</value></smbconfoption> in the <smbconfsection>[printers]</smbconfsection>
section of &smb.conf;. Otherwise cupsd will
sanitize permissions to its spool directory with each restart and
printing will not work reliably.</para></sect2>

<sect2>
<title>Print Queue Called <quote>lp</quote> Mis-handles Print Jobs</title>

<para>
In this case a print queue called <quote>lp</quote> intermittently swallows jobs and
spits out completely different ones from what was sent.
</para>

<para>It is a bad idea to name any printer <quote>lp</quote>. This
is the traditional UNIX name for the default printer. CUPS may be set
up to do an automatic creation of Implicit Classes. This means, to
group all printers with the same name to a pool of devices, and
load-balancing the jobs across them in a round-robin fashion. Chances
are high that someone else has a printer named <quote>lp</quote> too. You may
receive his jobs and send your own to his device unwittingly. To have
tight control over the printer names, set <parameter>BrowseShortNames
No</parameter>. It will present any printer as <replaceable>printername@cupshost</replaceable>
and then gives you better control over what may happen in a large
networked environment.</para></sect2>

<sect2><title>Location of Adobe PostScript Driver Files for <quote>cupsaddsmb</quote></title>
<para>Use <command>smbclient</command> to connect to any
Windows box with a shared PostScript printer: <command>smbclient
//windowsbox/print\$ -U guest</command>. You can navigate to the
<filename>W32X86/2</filename> subdir to <command>mget ADOBE*</command>
and other files or to <filename>WIN40/0</filename> to do the same.
Another option is to download the <filename>*.exe</filename> packaged
files from the Adobe Web site.</para></sect2>

</sect1>

<sect1>
<title>Overview of the CUPS Printing Processes</title>

<para>A complete overview of the CUPS printing processes can be found in <link linkend="a_small">the next flowchart</link>.</para>

<image id="a_small"><imagedescription>CUPS printing overview.</imagedescription>
	<imagefile>a_small</imagefile>
</image>
</sect1>

</chapter>












