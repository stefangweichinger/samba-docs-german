<?xml version="1.0" encoding="ISO-8859-1"?>
<chapter id="locking">
<chapterinfo>
	&author.jeremy;
	&author.jelmer;
	&author.jht;
	&author.eroseme;
	<author>&person.luft;<contrib>Deutsche Übersetzung</contrib></author>
	<author>&person.sgw;<contrib>Deutsche Übersetzung</contrib></author>
</chapterinfo>
<title>Datei- und Satzsperren</title>

<para>
Ein Bereich, der vielen Netzwerkadministratoren Probleme verursacht, sind Sperren.
Das Ausmaß des Problems ist bereits durch Recherchen über das Internet bewiesen.
</para>

<sect1>
<title>Eigenschaften und Vorzüge</title>

<para>
Samba bietet alle Sperrsemantiken, die MS Windows Clients erwarten und
die MS Windows NT/200x Server auch zur Verfügung stellen.
</para>

<para>
Der Ausdruck <emphasis>Sperren</emphasis> 
(entsprechend dem etwas treffenderen englischen Begriff <emphasis>Locking</emphasis>, Anm. d. Übers.)
hat grundsätzlich weitläufige Bedeutung und
deckt eine Vielzahl von Funktionen ab, die alle unter diesem einen Begriff zusammengefasst sind.
</para>

<para>
Opportunistisches Sperren ist ein wünschenswertes Feature, wenn es die wahrnehmbare Geschwindigkeit von 
Anwendungen auf einem Netzwerkclient beschleunigen kann. Jedoch ist das opportunistische Sperrprotokoll
nicht robust und deshalb können Probleme entstehen, wenn es von einer einfachen Konfiguration
oder in einem sehr langsamen oder fehlerhaften Netzwerk aufgerufen wird. 
In diesen Fällen kann der Aufwand zur Verwaltung der opportunistischen Sperren, der vom
Betriebssystem vorgenommen, und das Wiederherstellen nach Fehlern den erzielten Performance-Zuwachs
wieder zunichte machen.
</para>

<para>
Der MS Windows Netzwerkadministrator muss sich darüber im Klaren sein, dass Datei- und Satzsperren-
Semantiken (Verhalten) entweder in Samba kontrolliert werden können oder durch Registry-Einstellungen
auf einem MS Windows Client.
</para>

<note>
<para>
Manchmal ist es sogar notwendig, Einstellungen zu Sperrkontrollen sowohl auf dem Samba-Server
wie auch auf dem MS Windows Client abzuschalten !
</para>
</note>

</sect1>

<sect1>
<title>Erörterung</title>

<para>
Es gibt 2 Arten von Sperren, die durch einen SMB Server durchgeführt werden müssen.
Die erste ist die <emphasis>Satzsperre</emphasis>, die einem Client das Sperren eines
Bereiches von Bytes innerhalb einer geöffneten Datei erlaubt. Die zweite sind die 
<emphasis>Verbotszustände (deny modes)</emphasis>, die spezifiziert werden, wenn eine Datei
geöffnet ist.
</para>

<para>
Satzsperren-Semantiken unter UNIX sind vollkommen verschieden zu Satzsperren unter
Windows. Sambaversionen vor 2.2 hatten versucht, den nativen UNIX-Systemaufruf fcntl()
zu nutzen, um saubere Satzsperren zwischen den verschiedenen Samba-Clients zu implementieren.
Dies kann allerdings aus mehreren Gründen nicht vollständig richtig sein. Der einfachste ist die 
Tatsache, dass ein Windows-Client einen Bytebereich von bis zu 2^32 oder 2^64,
abhängig vom Client-Betriebssystem, sperren darf. Die UNIX-Sperren unterstützen nur einen
Bytebereich bis zu 2^31.
So ist es nicht möglich, eine Sperranfrage oberhalb von 2^31 sauber zu ermöglichen. Es gibt noch
wesentlich mehr Unterschiede, zu viele, um hier alle aufzuführen.
</para>

<para>
Samba 2.2 und darüber implementiert Satzsperren völlig unabhängig vom darunterliegenden
UNIX-System. Wenn eine Bytebereichs-Sperre, die ein Client anfordert, in den Bereich von 0-2^31
fällt, gibt Samba diese Anfrage an das UNIX-System weiter. Alle anderen Sperren können von UNIX
jedoch nicht gesehen werden.
</para>

<para>
Vereinfacht ausgedrückt sollte ein SMB-Server vor jedem Lese- und Schreibzugriff auf eine Datei
auf Sperren prüfen. Unglücklicherweise kann dies durch die Art und Weise, wie fcntl() arbeitet, langsam sein 
und den <command>rpc.lockd</command> überbeanspruchen. Dies ist fast immer unnötig, von den Clients erwartet
wird, daß sie unabhängig Sperr-Aufrufe vor Lese- und Schreibzugriffen absetzen, wenn das Sperren für sie
wichtig ist. In der Voreinstellung setzt Samba nur dann Sperr-Aufrufe, wenn es explizit von einem Client
danach gefragt wird, aber wenn Sie die Option 
<smbconfoption><name>strict locking</name><value>yes</value></smbconfoption> setzen, wird es diese Aufrufe
bei <emphasis>jedem</emphasis> Lese- und Schreibzugriff ausführen.
</para>

<para>
Sie können das Sperren von Byte-Bereichen auch komplett abschalten, indem Sie
<smbconfoption><name>locking</name><value>no</value></smbconfoption> setzen.
Das ist hilfreich für jene Freigaben, die die Sperren nicht unterstützen oder sie nicht brauchen (wie CDROMs).
In diesem Fall bildet Samba die Antwort-Codes von Sperr-Aufrufen nach, um den Clients mitzuteilen, daß alles
in Ordnung ist.
</para>

<para>
Die zweite Klasse der Sperren sind die sogenannten <emphasis>deny modes</emphasis>. Diese werden von einer
Applikation gesetzt, wenn diese eine Datei öffnet, um zu bestimmen, welche Zugriffsarten gleichzeitig mit
dieser Öffnung zu erlauben sind. Ein Client könnte nach
<constant>DENY_NONE</constant>, <constant>DENY_READ</constant>, 
<constant>DENY_WRITE</constant>, oder <constant>DENY_ALL</constant> fragen.
Es gibt auch spezielle Kompatibilitäts-Modii namens <constant>DENY_FCB</constant>
und <constant>DENY_DOS</constant>.
</para>

<sect2>
<title>Überblick über oppurtunistische Sperren</title>

<para>
Opportunistisches Sperren, auch bezeichnet als <quote>Oplocks</quote> 
(entspricht <quote>Opportunistic locking</quote>) wird vom Windows-Dateisystem über Registrierungs-Einträge
aufgerufen (im Gegensatz zu einer API) um die Netzwerk-Performance zu erhöhen, wenn auf eine Datei auf einem
Server zugegriffen wird. Die Performance wird lokales Puffern der Datei auf dem Client erhöht, was
folgendes erlaubt:
</para>

<variablelist>
	<varlistentry><term>Read-ahead:</term>
		<listitem><para>
		Der Client liest die lokale Kopie der Datei, dadurch wird die Netzwerk-Latenz eliminiert.
		</para></listitem>
	</varlistentry>

	<varlistentry><term>Write caching:</term>
		<listitem><para>
		Der Client schreibt in die lokale Kopie der Datei, dadurch wird die Netzwerk-Latenz eliminiert.	
		</para></listitem>
	</varlistentry>

        <varlistentry><term>Lock caching:</term>
        <listitem><para>
		Der Client puffert die Sperren der Anwendung lokal, wieder wird die Netzwerk-Latenz eliminiert.
		</para></listitem>
        </varlistentry>
</variablelist>

<para>
Die Performance-Steigerung von Oplocks kommt von der Möglichkeit des exklusiven Zugriffs auf die Datei &smbmdash;
sogar wenn sie über <constant>DENY_NONE</constant> geöffnet ist &smbmdash; da Windows den Status der Datei
auf konkurrierende Zugriffe von anderen Prozessen überwacht.
</para>

<variablelist>
<title>Windows definiert 4 Arten von Oplocks:</title>

	<varlistentry><term>Level1 Oplock</term>
                <listitem><para>
		Der Redirektor sieht, daß die Datei mit DENY_NONE geöffnet wurde (was konkurrierende
		Zugriffe erlaubt), prüft, ob auch kein anderer Prozess auf die Datei zugreift, prüft, daß
		Oplocks aktiviert sind, dann gewährt er DENY_ALL/R+W/Exklusiv-Zugriff auf die Datei. Der
		Client führt seine Operationen nun auf die gepufferte Datei durch.
		</para>

		<para>
		Wenn ein zweiter Prozess nun versucht, die Datei zu öffnen, wird das Öffnen verzögert, während
		der Redirektor den originalen Oplock <quote>aufbricht</quote>. Dieser Bruch des Oplocks
		signalisiert dem puffernden Client, die gepufferte Datei zurück auf den Server zu schreiben,
		die lokalen Sperren zu löschen und die Read-Ahead-Daten zu verwerfen. Der Bruch ist dann
		komplett, die verzögerte Öffnung wird gewährt, und mehrere Prozesse können konkurrierenden
		Dateizugriff geniessen, wie er von den Byte-Bereichs- oder den zwingenden Sperren diktiert wird.
		Wenn jedoch der originale öffnende Prozess die Datei in einem anderen Modus als DENY_NONE
		geöffnet hat, wird dem zweiten Prozess nur eingeschränkter oder gar kein Zugriff gewährt,
		trotz des Bruchs des Oplocks.
                </para></listitem>
        </varlistentry>

        <varlistentry><term>Level2 Oplock</term>
                <listitem><para>
		Arbeitet wie ein Level1 Oplock, außer daß nur Lesezugriffe gepuffert werden. Alle anderen
		Operationen werden auf der Server-Kopie der Datei durchgeführt.		
                </para></listitem>
        </varlistentry>

        <varlistentry><term>Filter Oplock</term>
                <listitem><para>
		Erlaubt keinen Schreib- oder Löschzugriff auf Dateien.		
                </para></listitem>
        </varlistentry>

        <varlistentry><term>Batch Oplock</term>
                <listitem><para>
		Manipuliert Datei-Öffnungen und -Schliessungen, und erlaubt das Puffern von Dateiattributen.
                </para></listitem>
        </varlistentry>
</variablelist>

<para>
Ein wichtiges Detail ist, daß Oplocks vom Dateisystem aufgerufen werden, nicht von einer Anwendungs-API. Daher
kann eine Applikation eine opportunistisch gesperrte Datei schliessen, aber das Dateisystem gibt den Oplock
nicht auf. Wenn der Bruch des Oplocks durchgeführt wird, schließt das Dateisystem einfach die Datei, in
Vorbereitung auf das folgende Öffnen der Datei durch den zweiten Prozess.
</para>

<para>
<emphasis>Opportunistisches Sperren</emphasis> ist eigentlich ein unpassender Name für dieses Feature.
Der wirkliche Nutzen dieses Features ist das Puffern von Daten (<quote>Cachen</quote>) auf Client-Seite, 
und die Oplocks sind nur
ein Mitteilungs-Mechanismus für das Zurückschreiben von Daten auf die Platte des Netzwerk-Servers. Die
Einschränkung der Oplocks ist die Zuverlässigkeit des Mechanismus, einen Oplock-Bruch (Mitteilung) zwischen
dem Server und dem puffernden Client auszuführen. Wenn dieser Austausch fehlerhaft abläuft (üblicherweise
wegen einem Timeout aus irgendwelchen Gründen), dann geht der Nutzen des Client-seitigen Pufferns verloren.
</para>

<para>
Die tatsächliche Entscheidung, die ein Anwender oder Administrator erwägen sollte, ist, ob es vernünftig ist,
Daten unter mehreren Anwendern zu teilen, die lokal auf den Clients gepuffert werden. In vielen Fällen ist
die Antwort <quote>Nein</quote>. Zu entscheiden, wann Daten gepuffert werden und wann nicht, das ist hier
die Frage, und daher sollte <quote>opportunistisches Sperren</quote> als Schalter für Client-seitiges Puffern
behandelt werden. Schalten Sie es <quote>on</quote>, wenn Client-seitiges Puffern erwünscht und zuverlässig ist.
Schalten Sie es <quote>off</quote>, wenn Client-seitiges Puffern redundant, unzuverlässig oder kontra-produktiv 
ist.
</para>

<para>
Opportunistisches Sperren wird von Samba standardmässig für alle Freigaben auf <quote>on</quote> gesetzt,
also sollte in jedem Fall vorsichtig vorgegangen werden, um zu bestimmen, ob der potentielle Nutzen die
potentiellen Verzögerungen wert ist. Die folgenden Empfehlungen sollen dabei helfen, eine Umgebung zu
charakterisieren, in der opportunistisches Sperren effektiv eingerichtet werden können.
</para>

<para>
Die Windows-Oplocks sind ein leichtgewichtiges Performance-steigerndes Feature. Sie sind kein robustes
und zuverlässiges Protokoll. Jede Implementierung von Oplocks sollte als Kompromiß zwischen Performance und
Zuverlässigkeit geprüft werden. Die Zuverlässigkeit sinkt mit jeder oben genannten Regel, die nicht erzwungen
wird. Stellen Sie sich eine Freigabe mit aktivierten Oplocks vor, über ein WAN, freigegeben an einen Client
auf einem Atoll im Südpazifik, auf einem Hochverfügbarkeits-Server, der auf dieser Freigabe eine
<quote>mission-critical</quote> Multi-User-Firmen-Datenbank bereitstellt, während eines tropischen Sturms.
Diese Konfiguration wird sehr wahrscheinlich Probleme mit Oplocks erfahren.
</para>

<para>
Oplocks können sehr wirksam die Client-Performance steigern, wenn sie als Konfigurations-Schalter
für Client-seitiges Daten-Puffern behandelt werden. Wenn das Puffern der Daten wahrscheinlich unterbrochen 
werden könnte, sollte der Einsatz von Oplocks nochmals überdacht werden. Samba aktiviert standardmässig die
Verwendung von Oplocks auf allen Freigaben. Die Client-seitige Verwendung von Daten auf dem Server,
die Zuverlässigkeit des Servers im Netzwerk und die Oplock-Konfiguration jeder Freigabe sollten 
mit besonderer Aufmerksamkeit bedacht und konfiguriert werden. In Hochverfügbarkeits-Umgebungen ist die
Integrität der Daten oft von hoher Priorität. Komplexe und teure Konfigurationen werden implementiert, um zu
gewährleisten, daß wenn ein Client die Verbindung zum Dateiserver verliert, sofort ein Ersatz verfügbar ist,
um durchgehende Verfügbarkeit der Daten zu gewährleisten.
</para>

<para>
Das Verhalten von Windows Clients bei Ausfällen birgt ein höheres Risiko von Anwendungsunterbrechungen als
andere Plattformen, da es von einer aufgebauten TCP-Transport-Verbindung abhängt. Wenn die Verbindung 
unterbrochen wird 
&smbmdash; wie bei einem Datei-Server-Ausfall und dessen Ersatz durch einen Failover-Server &smbmdash;
muß eine neue Verbindung aufgebaut werden. Es ist selten, daß eine Windows-Client-Applikation so programmiert 
ist, daß sie sich korrekt von einer unterbrochenen Transport-Verbindung erholt, daher werden die meisten
Applikationen in irgendeiner Art unterbrochen &smbmdash; im schlimmsten Fall abgebrochen, und erfordern
einen Neustart.
</para>

<para>
Wenn eine Client-Session Schreib- und Lese-Vorgänge mittels Oplocks lokal gepuffert hat, ist es wahrscheinlich,
daß die Daten verloren gehen, wenn die Applikation neu startet, oder sich nach der TCP-Unterbrechung wieder
verbindet. Wenn die TCP-Verbindung ausfällt, ist der Status des Clients verloren. Wenn der Server die
Verbindung wiederherstellt, wird keine Aufforderung zum Brechen des Oplocks an den Client gesandt. In diesem
Fall ist die Arbeit aus der vorangehenden Session verloren. Durch Echtzeit-Überwachung dieses Szenarios mit
deaktivierten Oplocks und des Clients, der Daten auf den Datei-Server schreibt, wird die
Ausfallssicherung die Daten auf der Platte so bewahren, wie sie zum Zeitpunkt des Verbindungsabbruchs existiert
haben.
</para>

<para>
In <quote>mission-critical</quote> Hochverfügbarkeits-Umgebungen, sollte grosse Vorsicht im Umgang mit
Oplocks geübt werden. Idealerweise sollten umfassende Tests mit allen betroffenen Applikationen erfolgen, sowohl
mit wie auch ohne aktivierten Oplocks. 
</para>

<sect3>
<title>Exklusive Freigaben</title>

<para>
Opportunistische Sperren sind am effektivsten, wenn sie auf Freigaben beschränkt sind, auf die ausschließlich
von einem einzelnen Anwender zugegriffen wird, oder nur von einem Anwender gleichzeitig. Da der eigentliche
Wert der Oplocks das client-seitige Puffern von Daten ist, verursacht jede Operation, die den Puffer-Mechanismus
unterbricht, eine Verzögerung.
</para>

<para>
Home-Verzeichnisse sind die offensichtlichsten Beispiele für das sichere Realisieren von Performanc-Steigerungen
mit Oplocks.
</para>

</sect3>

<sect3>
<title>Freigaben oder Dateien, auf die von mehreren zugegriffen wird</title>

<para>
Mit jedem weiteren Anwender, der auf eine Datei auf einer Freigabe mit aktiven Oplocks zugreift, erhöht sich
das Potential für Verzögerungen und daraus resultierende Performance-Verschlechterung. Wenn mehrere Anwender
auf eine Datei auf einer Freigabe mit aktiven Oplocks zugreifen, übersteigt der Verwaltungsaufwand für das
Senden und Empfangen der Oplock-Breaks und die resultierende Latenz, während die anderen Clients auf den
momentan puffernden Client warten (bis er seine Puffer geleert hat), den Performance-Gewinn des
puffernden Clients.
</para>

<para>
Mit jedem weiteren Client, der auf eine Datei mit gesetzten Oplocks zugreift, wird der potentielle
Performance-Zuwachs negiert, und es ergibt sich eventuell sogar ein Flaschenhals.
</para>

</sect3>

<sect3>
<title>Dateien, auf die von UNIX- oder NFS-Clients aus zugegriffen wird</title>

<para>
Lokale UNIX- oder NFS-Clients greifen ohne einen zwingenden Datei-Sperren-Mechanismus auf Dateien zu.
Daher sind diese Client-Plattformen nicht imstande, vom Server aus einen Oplock-Bruch am Client zu erfragen, der
gerade eine Datei puffert. Lokaler UNIX- oder NFS-Dateizugriff kann daher in eine Datei schreiben, die von einem
Windows-Client gepuffert wurde, was diese Datei sehr wahrscheinlich unbrauchbar macht.
</para>

<para>
Wenn Dateien sowohl an Windows-Clients, wie auch an lokale UNIX- oder NFS-Benutzer freigegeben werden, schalten
Sie das opportunistische Sperren ab.
</para>

</sect3>

<sect3>
<title>Langsame und/oder unzuverlässige Netzwerke</title>

<para>
Der größtmögliche Performance-Gewinn für Oplocks wird dann erzielt, wenn das client-seitige Puffern der
Lese- und Schreib-Vorgänge den größten Unterschied zum Senden dieser Vorgänge über das Netzwerk liefert.
Dies passiert am wahrscheinlichsten dann, wenn das Netzwerk extrem langsam ist, verstopft, oder weitreichend
verteilt (wie in einem WAN). Die Netzwerk-Latenz hat jedoch auch einen grossen Einfluß auf die Zuverlässigkeit
des Oplock-Bruch-Mechanismus, und erhöht daher die Wahrscheinlichkeit, Oplock-Probleme zu bekommen, die die
potentiellen Performance-Gewinne mehr als zunichte machen. Wenn natürlich niemals ein Oplock-Bruch gesendet
werden müßte, wäre dies das vorteilhafteste Szenario, um Oplocks einzusetzen.
</para>

<para>
Wenn das Netzwerk langsam, unzuverlässig, oder ein WAN ist, konfigurieren Sie keine Oplocks, wenn irgendeine
Möglichkeit besteht, daß mehrere Benutzer regelmässig die selbe Datei öffnen.
</para>

</sect3>

<sect3>
<title>Mehrbenutzer-Datenbanken</title>

<para>
Mehrbenutzer-Datenbanken stellen klarerweise durch ihre grundlegende Natur ein Risiko dar &smbmdash;
auf sie wird üblicherweise massiv von vielen Anwendern zugegriffen, in zufälligen Intervallen. Das Plazieren
einer Mehrbenutzer-Datenbank auf einer Freigabe mit aktivierten Oplocks wird wahrscheinlich in einem Flaschenhals
auf dem Samba-Server resultieren, durch die notwendige Verwaltung der Sperren. Egal, ob eine Datenbank eine
Eigenentwicklung ist, oder ein kommerzielles Produkt, stellen Sie sicher, daß die entsprechende Freigabe
deaktivierte Oplocks hat.
</para>

</sect3>

<sect3>
<title>PDM Daten-Freigaben</title>

<para>
Process Data Management (PDM)-Applikationen wie IMAN, Enovia und Clearcase finden immer mehr Verwendung mit
Windows-Client-Plattformen, und daher auch mit SMB-Daten-Servern. PDM-Applikationen verwalten 
Mehrbenutzer-Umgebungen für Sicherheit von und Zugriff auf kritische Daten. Die typische PDM-Umgebung ist
üblicherweise verbunden mit ausgeklügelt entworfenen Client-Anwendungen, die Daten lokal laden, wenn 
erforderlich. Zusätzlich überwacht die PDM-Applikation üblicherweise den Daten-Status jeden Clients. In diesem
Fall wird das client-seitige Puffern am besten der lokalen Applikation und dem PDM-Server überlassen. Es ist
angemessen, das Client-OS von jeglichen Puffer-Aufgaben zu befreien, und auch den Server von der Verwaltung
der Oplocks, indem man Oplocks auf der Freigabe deaktiviert. 
</para>

</sect3>

<sect3>
<title>Vorsicht vor Force User</title>

<para>
Samba enthält einen Parameter in &smb.conf; namens
<smbconfoption><name>force user</name></smbconfoption>, der den Benutzer, der auf eine Freigabe zugreift, vom
tatsächlich zugreifenden Benutzer auf den in diesem Parameter angegebenen ändert. Wenn Oplocks auf einer
Freigabe aktiviert sind, verursacht die Änderung des Benutzers, daß ein Bruch des Oplocks an den Client
gesendet wird, sogar wenn der Benutzer gar nicht explizit eine Datei geladen hat. In den Fällen, wo das Netzwerk
langsam oder unzuverlässig ist, kann ein Oplock-Bruch verloren gehen, ohne daß der Benutzer auch nur auf eine
Datei zugreift. Das kann sichtbare Performance-Einbrüche verursachen, wenn der Client wiederholt neu verbindet,
um den verlorenen Oplock-Bruch <quote>zu überwinden</quote>.
</para>

<para>
Vermeiden Sie die folgende Kombination:
</para>

<itemizedlist>
	<listitem><para>
	<smbconfoption><name>force user</name></smbconfoption> in der &smb.conf; Freigaben-Konfiguration.
	</para></listitem>

	<listitem><para>
	Langsames oder unzuverlässiges Netzwerk.
	</para></listitem>

	<listitem><para>
	Opportunistisches Sperren aktiviert.
	</para></listitem>
</itemizedlist>

</sect3>

<sect3>
<title>Erweiterte Samba Oplock-Parameter</title>

<para>
Samba bietet Oplock-Parameter, die es dem Administrator erlauben, verschiedene Eigenschaften des 
Oplock-Mechanismus anzupassen, an Timing- und Benutzungs-Level. Diese Parameter bieten hohe Flexibilität zum
Implementieren von Oplocks in Umgebungen, wo Sie sehr wahrscheinlich Probleme verursachen würden.
Die Parameter sind:
<smbconfoption><name>oplock break wait time</name></smbconfoption>,
<smbconfoption><name>oplock contention limit</name></smbconfoption>.
</para>

<para>
Falls diese Parameter benötigt werden, ist es für die meisten Anwender, Administratoren und Umgebungen die
bessere Wahl, die Oplocks einfach abzuschalten. Der Samba-SWAT-Hilfetext für diese beiden Parameter sagt:
<quote>Do not change
this parameter unless you have read and understood the Samba oplock code.</quote>
Dies ist ein guter Rat.
</para>

</sect3>

<sect3>
<title>Missions-kritische Hochverfügbarkeit</title>

<para>
In Hochverfügbarkeits-Umgebungen ist die
Integrität der Daten oft von hoher Priorität. Komplexe und teure Konfigurationen werden implementiert, um zu
gewährleisten, daß wenn ein Client die Verbindung zum Dateiserver verliert, sofort ein Ersatz verfügbar ist,
um durchgehende Verfügbarkeit der Daten zu gewährleisten.
</para>

<para>
Das Verhalten von Windows Clients bei Ausfällen birgt ein höheres Risiko von Anwendungsunterbrechungen als
andere Plattformen, da es von einer aufgebauten TCP-Transport-Verbindung abhängt. Wenn die Verbindung
unterbrochen wird
&smbmdash; wie bei einem Datei-Server-Ausfall und dessen Ersatz durch einen Failover-Server &smbmdash;
muß eine neue Verbindung aufgebaut werden. Es ist selten, daß eine Windows-Client-Applikation so programmiert
ist, daß sie sich korrekt von einer unterbrochenen Transport-Verbindung erholt, daher werden die meisten
Applikationen in irgendeiner Art unterbrochen &smbmdash; im schlimmsten Fall abgebrochen, und erfordern
einen Neustart.
</para>

<para>
Wenn eine Client-Session Schreib- und Lese-Vorgänge mittels Oplocks lokal gepuffert hat, ist es wahrscheinlich,
daß die Daten verloren gehen, wenn die Applikation neu startet, oder sich nach der TCP-Unterbrechung wieder
verbindet. Wenn die TCP-Verbindung ausfällt, ist der Status des Clients verloren. Wenn der Server die
Verbindung wiederherstellt, wird keine Aufforderung zum Brechen des Oplocks an den Client gesandt. In diesem
Fall ist die Arbeit aus der vorangehenden Session verloren. Durch Echtzeit-Überwachung dieses Szenarios mit
deaktivierten Oplocks und des Clients, der Daten auf den Datei-Server schreibt, wird die
Ausfallssicherung die Daten auf der Platte so bewahren, wie sie zum Zeitpunkt des Verbindungsabbruchs existiert
haben.
</para>

<para>
In <quote>mission-critical</quote> Hochverfügbarkeits-Umgebungen, sollte grosse Vorsicht im Umgang mit
Oplocks geübt werden. Idealerweise sollten umfassende Tests mit allen betroffenen Applikationen erfolgen, sowohl
mit wie auch ohne aktivierten Oplocks.
</para>

</sect3>
</sect2>
</sect1>

<sect1>
<title>Samba Oplock Kontrolle</title>

<para>
Oplocks sind ein einzigartiges Datei-Sperr-Feature von Windows. Sie sind keine richtigen Dateisperren, werden
aber in den meisten Diskussionen über Windows-Dateisperren miteinbezogen, also de facto als Sperr-Feature
betrachtet. Oplocks sind tatsächlich Teil des Windows-Client-Datei-Caching-Mechanismus. Sie sind kein speziell
robustes oder zuverlässiges Feature, wenn sie in der Vielzahl von angepassten Netzwerken implementiert werden,
die es in Unternehmens-Umgebungen gibt.
</para>

<para>
Wie Windows implementiert Samba Oplocks als eine server-seitige Komponente des client-seitigen Cache-Mechanismus.
Wegen der leichtgewichtigen Entwurfs des Windows-Features erfordert die effektive Konfiguration von Oplocks
ein tieferes Verständnis ihrer Einschränkungen, und das Anwenden dieses Verständnisses beim Konfigurieren
des Datenzugriffs für jeden einzelnen Zustand von Netzwerk- und Client-Verwendung.
</para>

<para>
Opportunistisches Sperren bedeutet grundsätzlich, daß es dem Client erlaubt wird, eine Datei herunterzuladen, und
sie lokal auf seiner Platte zu puffern, während er Veränderungen daran vornimmt; wenn ein zweiter Client auf
die Datei zugreifen will, erhält der erste Client ein Signal zum Bruch des Oplocks und muß die Datei wieder
zurück auf den Server synchronisieren. Dies kann in einigen Fällen deutliche Performance-Steigerungen
verursachen; manche Programme bestehen auf der Synchronisation der gesamten Datei mit dem Server, nur für
eine einzelne Veränderung.
</para>

<para>
Level1 Oplocks (auch bekannt als einfache <quote>oplocks</quote>) sind ein anderer Begriff für
Opportunistisches Sperren.
</para>

<para>
Level2 Oplocks bieten Opportunistisches Sperren für eine Datei, die als <emphasis>read only</emphasis>
behandelt wird. Dies wird typischerweise für Dateien verwendet, die read-only sind, oder für Dateien, für die
beim Öffnen der Datei keine Absicht besteht, darauf zu schreiben.
</para>

<para>
Kernel Oplocks sind grundsätzlich eine Methode, die es dem Linux-Kernel erlaubt, mit Samba's opportunistisch
gesperrten Dateien zu koexistieren, obwohl dies bessere Integration von MS-Windows-Netzwerk-Dateisperren
mit dem darunterliegenden Betriebssystem gebracht hat; SGI IRIX und Linux sind derzeit die einzigen 
oplock-fähigen Betriebssysteme.
</para>

<para>
Sie sollten Oplocks deaktivieren, wenn Sie auf die selben
Dateien sowohl von UNIX/Linux- und SMB-Clients zugreifen, außer wenn Ihr System Kernel-Oplocks unterstützt.



Unless your system supports kernel oplocks, you should disable oplocks if you are
accessing the same files from both UNIX/Linux and SMB clients. Regardless, oplocks should
always be disabled if you are sharing a database file (e.g., Microsoft Access) between
multiple clients, as any break the first client receives will affect synchronization of
the entire file (not just the single record), which will result in a noticeable performance
impairment and, more likely, problems accessing the database in the first place. Notably,
Microsoft Outlook's personal folders (*.pst) react quite badly to oplocks. If in doubt,
disable oplocks and tune your system from that point.
</para>

<para>
If client-side caching is desirable and reliable on your network, you will benefit from
turning on oplocks. If your network is slow and/or unreliable, or you are sharing your
files among other file sharing mechanisms (e.g., NFS) or across a WAN, or multiple people
will be accessing the same files frequently, you probably will not benefit from the overhead
of your client sending oplock breaks and will instead want to disable oplocks for the share.
</para>

<para>
Another factor to consider is the perceived performance of file access. If oplocks provide no
measurable speed benefit on your network, it might not be worth the hassle of dealing with them.
</para>

<sect2>
<title>Example Configuration</title>

<para>
In the following section we examine two distinct aspects of Samba locking controls.
</para>

<sect3>
<title>Disabling Oplocks</title>

<para>
You can disable oplocks on a per-share basis with the following:
</para>

<para>
<smbconfblock>
<smbconfsection>[acctdata]</smbconfsection>
<smbconfoption><name>oplocks</name><value>False</value></smbconfoption>
<smbconfoption><name>level2 oplocks</name><value>False</value></smbconfoption>
</smbconfblock>
</para>

<para>
The default oplock type is Level1. Level2 oplocks are enabled on a per-share basis
in the &smb.conf; file.
</para>

<para>
Alternately, you could disable oplocks on a per-file basis within the share:
</para>

<para>
	<smbconfblock>
<smbconfoption><name>veto oplock files</name><value>/*.mdb/*.MDB/*.dbf/*.DBF/</value></smbconfoption>
</smbconfblock>
</para>

<para>
If you are experiencing problems with oplocks as apparent from Samba's log entries,
you may want to play it safe and disable oplocks and Level2 oplocks.
</para>

</sect3>

<sect3>
<title>Disabling Kernel Oplocks</title>

<para>
Kernel oplocks is an &smb.conf; parameter that notifies Samba (if
the UNIX kernel has the capability to send a Windows client an oplock
break) when a UNIX process is attempting to open the file that is
cached. This parameter addresses sharing files between UNIX and
Windows with oplocks enabled on the Samba server: the UNIX process
can open the file that is Oplocked (cached) by the Windows client and
the smbd process will not send an oplock break, which exposes the file
to the risk of data corruption. If the UNIX kernel has the ability to
send an oplock break, then the kernel oplocks parameter enables Samba
to send the oplock break. Kernel oplocks are enabled on a per-server
basis in the &smb.conf; file.
</para>

<para>
<smbconfblock>
<smbconfoption><name>kernel oplocks</name><value>yes</value></smbconfoption>
</smbconfblock>
The default is no.
</para>

<para>
Veto opLocks is an &smb.conf; parameter that identifies specific files for
which oplocks are disabled. When a Windows client opens a file that
has been configured for veto oplocks, the client will not be granted
the oplock, and all operations will be executed on the original file on
disk instead of a client-cached file copy. By explicitly identifying
files that are shared with UNIX processes and disabling oplocks for
those files, the server-wide Oplock configuration can be enabled to
allow Windows clients to utilize the performance benefit of file
caching without the risk of data corruption. Veto Oplocks can be
enabled on a per-share basis, or globally for the entire server, in the
&smb.conf; file as shown in <link linkend="far1"/>.
</para>

<para>
<smbconfexample id="far1">
<title>Share with some files oplocked</title>
<smbconfsection>[global]</smbconfsection>
<smbconfoption><name>veto oplock files</name><value>/filename.htm/*.txt/</value></smbconfoption>

<smbconfsection>[share_name]</smbconfsection>
<smbconfoption><name>veto oplock files</name><value>/*.exe/filename.ext/</value></smbconfoption>
</smbconfexample>
</para>

<para>
<smbconfoption><name>oplock break wait time</name></smbconfoption> is an &smb.conf; parameter
that adjusts the time interval for Samba to reply to an oplock break request. Samba recommends:
<quote>Do not change this parameter unless you have read and understood the Samba oplock code.</quote>
Oplock break Wait Time can only be configured globally in the &smb.conf; file as shown below.
</para>

<para>
	<smbconfblock>
<smbconfoption><name>oplock break wait time</name><value> 0 (default)</value></smbconfoption>
</smbconfblock>
</para>

<para>
<emphasis>Oplock break contention limit</emphasis> is an &smb.conf; parameter that limits the
response of the Samba server to grant an oplock if the configured
number of contending clients reaches the limit specified by the parameter. Samba recommends
<quote>Do not change this parameter unless you have read and understood the Samba oplock code.</quote>
Oplock break Contention Limit can be enable on a per-share basis, or globally for
the entire server, in the &smb.conf; file as shown in <link linkend="far3"/>.
</para>

<para>
<smbconfexample id="far3">
	<title>Configuration with oplock break contention limit</title>
<smbconfsection>[global]</smbconfsection>
<smbconfoption><name>oplock break contention limit</name><value> 2 (default)</value></smbconfoption>

<smbconfsection>[share_name]</smbconfsection>
<smbconfoption><name>oplock break contention limit</name><value> 2 (default)</value></smbconfoption>
</smbconfexample>
</para>

</sect3>
</sect2>

</sect1>

<sect1>
<title>MS Windows Opportunistic Locking and Caching Controls</title>

<para>
There is a known issue when running applications (like Norton Anti-Virus) on a Windows 2000/ XP
workstation computer that can affect any application attempting to access shared database files
across a network. This is a result of a default setting configured in the Windows 2000/XP
operating system known as <emphasis>opportunistic locking</emphasis>. When a workstation
attempts to access shared data files located on another Windows 2000/XP computer,
the Windows 2000/XP operating system will attempt to increase performance by locking the
files and caching information locally. When this occurs, the application is unable to
properly function, which results in an <quote>Access Denied</quote>
 error message being displayed during network operations.
</para>

<para>
All Windows operating systems in the NT family that act as database servers for data files
(meaning that data files are stored there and accessed by other Windows PCs) may need to
have opportunistic locking disabled in order to minimize the risk of data file corruption.
This includes Windows 9x/Me, Windows NT, Windows 200x, and Windows XP.
<footnote><para>Microsoft has documented this in Knowledge Base article 300216.</para></footnote>
</para>

<para>
If you are using a Windows NT family workstation in place of a server, you must also
disable opportunistic locking (oplocks) on that workstation. For example, if you use a
PC with the Windows NT Workstation operating system instead of Windows NT Server, and you
have data files located on it that are accessed from other Windows PCs, you may need to
disable oplocks on that system.
</para>

<para>
The major difference is the location in the Windows registry where the values for disabling
oplocks are entered. Instead of the LanManServer location, the LanManWorkstation location
may be used.
</para>

<para>
You can verify (change or add, if necessary) this registry value using the Windows
Registry Editor. When you change this registry value, you will have to reboot the PC
to ensure that the new setting goes into effect.
</para>

<para>
The location of the client registry entry for opportunistic locking has changed in
Windows 2000 from the earlier location in Microsoft Windows NT.
</para>

<note><para>
Windows 2000 will still respect the EnableOplocks registry value used to disable oplocks
in earlier versions of Windows.
</para></note>

<para>
You can also deny the granting of opportunistic locks by changing the following registry entries:
</para>

<para>
<programlisting>
	HKEY_LOCAL_MACHINE\System\
		CurrentControlSet\Services\MRXSmb\Parameters\

		OplocksDisabled REG_DWORD 0 or 1
		Default: 0 (not disabled)
</programlisting>
</para>

<note><para>
The OplocksDisabled registry value configures Windows clients to either request or not
request opportunistic locks on a remote file. To disable oplocks, the value of
 OplocksDisabled must be set to 1.
</para></note>

<para>
<programlisting>
	HKEY_LOCAL_MACHINE\System\
		CurrentControlSet\Services\LanmanServer\Parameters

		EnableOplocks REG_DWORD 0 or 1
		Default: 1 (Enabled by Default)

		EnableOpLockForceClose REG_DWORD 0 or 1
		Default: 0 (Disabled by Default)
</programlisting>
</para>

<note><para>
The EnableOplocks value configures Windows-based servers (including Workstations sharing
files) to allow or deny opportunistic locks on local files.
</para></note>

<para>
To force closure of open oplocks on close or program exit, EnableOpLockForceClose must be set to 1.
</para>

<para>
An illustration of how Level2 oplocks work:
</para>

<itemizedlist>
	<listitem><para>
	Station 1 opens the file requesting oplock.
	</para></listitem>
	<listitem><para>
	Since no other station has the file open, the server grants station 1 exclusive oplock.
	</para></listitem>
	<listitem><para>
	Station 2 opens the file requesting oplock.
	</para></listitem>
	<listitem><para>
	Since station 1 has not yet written to the file, the server asks station 1 to break
	to Level2 oplock.
	</para></listitem>
	<listitem><para>
	Station 1 complies by flushing locally buffered lock information to the server.
	</para></listitem>
	<listitem><para>
	Station 1 informs the server that it has Broken to Level2 Oplock (alternately,
	station 1 could have closed the file).
	</para></listitem>
	<listitem><para>
	The server responds to station 2's open request, granting it Level2 oplock.
	Other stations can likewise open the file and obtain Level2 oplock.
	</para></listitem>
	<listitem><para>
	Station 2 (or any station that has the file open) sends a write request SMB.
	The server returns the write response.
	</para></listitem>
	<listitem><para>
	The server asks all stations that have the file open to break to none, meaning no
	station holds any oplock on the file. Because the workstations can have no cached
	writes or locks at this point, they need not respond to the break-to-none advisory;
	all they need do is invalidate locally cashed read-ahead data.
	</para></listitem>
</itemizedlist>

<sect2>
<title>Workstation Service Entries</title>

<para><programlisting>
	\HKEY_LOCAL_MACHINE\System\
		CurrentControlSet\Services\LanmanWorkstation\Parameters

	UseOpportunisticLocking   REG_DWORD   0 or 1
	Default: 1 (true)
</programlisting></para>

<para>
This indicates whether the redirector should use opportunistic-locking (oplock) performance
enhancement. This parameter should be disabled only to isolate problems.
</para>

</sect2>
<sect2>
<title>Server Service Entries</title>

<para><programlisting>
	\HKEY_LOCAL_MACHINE\System\
		CurrentControlSet\Services\LanmanServer\Parameters

	EnableOplocks   REG_DWORD   0 or 1
	Default: 1 (true)
</programlisting></para>

<para>
This specifies whether the server allows clients to use oplocks on files. Oplocks are a
significant performance enhancement, but have the potential to cause lost cached
data on some networks, particularly wide area networks.
</para>

<para><programlisting>
	MinLinkThroughput   REG_DWORD   0 to infinite bytes per second
	Default: 0
</programlisting></para>

<para>
This specifies the minimum link throughput allowed by the server before it disables
raw and opportunistic locks for this connection.
</para>

<para><programlisting>
	MaxLinkDelay   REG_DWORD   0 to 100,000 seconds
	Default: 60
</programlisting></para>

<para>
This specifies the maximum time allowed for a link delay. If delays exceed this number,
the server disables raw I/O and opportunistic locking for this connection.
</para>

<para><programlisting>
	OplockBreakWait   REG_DWORD   10 to 180 seconds
	Default: 35
</programlisting></para>

<para>
This specifies the time that the server waits for a client to respond to an oplock break
request. Smaller values can allow detection of crashed clients more quickly but can
potentially cause loss of cached data.
</para>

</sect2>
</sect1>

<sect1>
<title>Persistent Data Corruption</title>

<para>
If you have applied all of the settings discussed in this chapter but data corruption problems
and other symptoms persist, here are some additional things to check out.
</para>

<para>
We have credible reports from developers that faulty network hardware, such as a single
faulty network card, can cause symptoms similar to read caching and data corruption.
If you see persistent data corruption even after repeated reindexing, you may have to
rebuild the data files in question. This involves creating a new data file with the
same definition as the file to be rebuilt and transferring the data from the old file
to the new one. There are several known methods for doing this that can be found in
our Knowledge Base.
</para>

</sect1>

<sect1>
<title>Common Errors</title>

<para>
In some sites, locking problems surface as soon as a server is installed; in other sites
locking problems may not surface for a long time. Almost without exception, when a locking
problem does surface it will cause embarrassment and potential data corruption.
</para>

<para>
Over the past few years there have been a number of complaints on the Samba mailing lists
that have claimed that Samba caused data corruption. Three causes have been identified
so far:
</para>

<itemizedlist>
	<listitem><para>
	Incorrect configuration of opportunistic locking (incompatible with the application
	being used. This is a common problem even where MS Windows NT4 or MS Windows
	200x-based servers were in use. It is imperative that the software application vendors'
	instructions for configuration of file locking should be followed. If in doubt,
	disable oplocks on both the server and the client. Disabling of all forms of file
	caching on the MS Windows client may be necessary also.
	</para></listitem>

	<listitem><para>
	Defective network cards, cables, or HUBs/Switched. This is generally a more
	prevalent factor with low cost networking hardware, although occasionally there
	have also been problems with incompatibilities in more up-market hardware.
	</para></listitem>

	<listitem><para>
	There have been some random reports of Samba log files being written over data
	files. This has been reported by very few sites (about five in the past three years)
	and all attempts to reproduce the problem have failed. The Samba Team has been
	unable to catch this happening and thus has not been able to isolate any particular
	cause. Considering the millions of systems that use Samba, for the sites that have
	been affected by this as well as for the Samba Team this is a frustrating and
	a vexing challenge. If you see this type of thing happening, please create a bug
	report on Samba <ulink url="https://bugzilla.samba.org">Bugzilla</ulink> without delay.
	Make sure that you give as much information as you possibly can help isolate the
	cause and to allow replication of the problem (an essential step in problem isolation and correction).
	</para></listitem>
</itemizedlist>

	<sect2>
	<title>locking.tdb Error Messages</title>

	<para>
	<quote>
	We are seeing lots of errors in the Samba logs, like:
<programlisting>
tdb(/usr/local/samba_2.2.7/var/locks/locking.tdb): rec_read bad magic
 0x4d6f4b61 at offset=36116
</programlisting>

	What do these mean?
	</quote>
	</para>

	<para>
	This error indicated a corrupted tdb. Stop all instances of smbd, delete locking.tdb, and restart smbd.
	</para>

	</sect2>

	<sect2>
		<title>Problems Saving Files in MS Office on Windows XP</title>

		<para>This is a bug in Windows XP. More information can be 
		found in <ulink url="http://support.microsoft.com/?id=812937">Microsoft Knowledge Base article 812937.</ulink></para>

	</sect2>

	<sect2>

		<title>Long Delays Deleting Files Over Network with XP SP1</title>
		
		<para><quote>It sometimes takes approximately 35 seconds to delete files over the network after XP SP1 has been applied.</quote></para>

		<para>This is a bug in Windows XP. More information can be found in <ulink url="http://support.microsoft.com/?id=811492">
				Microsoft Knowledge Base article 811492.</ulink></para>
	</sect2>

</sect1>

<sect1>
<title>Additional Reading</title>

<para>
You may want to check for an updated version of this white paper on our Web site from
time to time. Many of our white papers are updated as information changes. For those papers,
the last edited date is always at the top of the paper.
</para>

<para>
Section of the Microsoft MSDN Library on opportunistic locking: 
</para>

<para>
Opportunistic Locks, Microsoft Developer Network (MSDN), Windows Development &gt;
Windows Base Services &gt; Files and I/O &gt; SDK Documentation &gt; File Storage &gt; File Systems
&gt; About File Systems &gt; Opportunistic Locks, Microsoft Corporation.
<ulink noescape="1" url="http://msdn.microsoft.com/library/en-us/fileio/storage_5yk3.asp">http://msdn.microsoft.com/library/en-us/fileio/storage_5yk3.asp</ulink>
</para>

<para>
	Microsoft Knowledge Base Article Q224992 <?latex \linebreak ?><quote>Maintaining Transactional Integrity 
with OPLOCKS</quote>,
Microsoft Corporation, April 1999, <ulink noescape="1" url="http://support.microsoft.com/default.aspx?scid=kb;en-us;Q224992">http://support.microsoft.com/default.aspx?scid=kb;en-us;Q224992</ulink>.
</para>

<para>
Microsoft Knowledge Base Article Q296264 <quote>Configuring Opportunistic Locking in Windows 2000</quote>,
Microsoft Corporation, April 2001, <ulink noescape="1" url="http://support.microsoft.com/default.aspx?scid=kb;en-us;Q296264">http://support.microsoft.com/default.aspx?scid=kb;en-us;Q296264</ulink>.
</para>

<para>
Microsoft Knowledge Base Article Q129202 <quote>PC Ext: Explanation of Opportunistic Locking on Windows NT</quote>,
Microsoft Corporation, April 1995, <ulink noescape="1" url="http://support.microsoft.com/default.aspx?scid=kb;en-us;Q129202">http://support.microsoft.com/default.aspx?scid=kb;en-us;Q129202</ulink>.
</para>

</sect1>
</chapter>
