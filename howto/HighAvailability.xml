<?xml version="1.0" encoding="ISO-8859-1"?>
<chapter id="SambaHA">
<chapterinfo>
	&author.jht;
	&author.jeremy;
	<pubdate>April 3 2003</pubdate>
        <author>&person.luft;<contrib>Deutsche Übersetzung</contrib></author>
</chapterinfo>

<title>Hochverfügbarkeit</title>

<sect1>
<title>Eigenschaften und Vorzüge</title>

<para>
Netzwerkadministratoren sind oft besorgt über die Verfügbarkeit von Datei- und Druck-Diensten.
Netzwerkbenutzer sind geneigt, intolerant gegenüber den Diensten zu sein, von denen sie,
was ihre Aufgabenstellungen anbelangt, abhängig sind.
</para>

<para>
Ein Schild in einem Computerraum diente dazu, das Personal an seine Verantwortung zu erinnern.
Es lautete:
</para>

<blockquote>
<para>
Alle Menschen scheitern; sowohl im Großen wie im Kleinen scheitern wir fortwährend.
Maschinen sind ebenfalls fehlerhaft. Computer sind Maschinen, die von Menschen verwaltet werden, und
das Ergebnis eines Fehlers kann spektakulär sein. Ihre Verantwortung ist es, mit 
dem Scheitern umzugehen, es vorwegzunehmen und auszuschließen, so weit es menschlich und
ökonomisch sinnvoll ist.
Sind Ihre Handlungen Teil des Problems oder Teil der Lösung?
</para>
</blockquote>

<para>
Wenn wir also mit Fehlern in geplanter und produktiver Art und Weise zu tun haben, dann müssen
wir zuerst einmal das Problem verstehen. Dies ist die Zielsetzung dieses Kapitels.
</para>

<para>
In der folgenden Betrachtung sind unter anderem Informationen eingestreut, wie man
Vorsorge gegen Fehler in Netzwerkinfrastrukturen trifft. Unsere Absicht ist hier 
keine langatmige Dissertation über die Hochverfügbarkeit selbst. Zusätzlich haben wir die 
bewusste Entscheidung getroffen, keine detaillierten Arbeitsbeispiele von
Hochverfügbarkeitslösungen
zur Verfügung zu stellen. Stattdessen zeigen wir einen Überblick über die Thematik
in der Hoffnung, dass sich jemand der Herausforderung stellt, ein detailliertes Dokument zur
Verfügung zu stellen, das sich ausschließlich auf die Präsentation des gegenwärtigen
Wissensstandes und der Praktiken im Bereich der Hochverfügbarkeit beschränkt, soweit sie den Einsatz 
von Samba und anderen CIFS/SMB-Technologien betreffen.
</para>

</sect1>

<sect1>
<title>Technische Beschreibung</title>

<para>
Die folgende Zusammenfassung war Teil einer Präsentation von Jeremy Allison auf der SambaXP 2003-Konferenz, die im April 2003 in Göttingen abgehalten wurde. Es wurden Zusatzinformationen
aus anderen Quellen hinzugefügt, aber Jeremy war es, der die folgende Struktur vorgab.
</para>

	<sect2>
	<title>Das ultimative Ziel</title>

	<para>
	Alle Cluster-Technologien zielen auf einen oder mehrere der folgenden Punkte ab:
	</para>

	<itemizedlist>
		<listitem><para>Sich die maximal erschwingliche rechnerische Power zu verschaffen</para></listitem>
		<listitem><para>Sich eine schnellere Programmausführung zu verschaffen</para></listitem>
		<listitem><para>Dienste zur Verfügung zu stellen, die nicht einfach stoppen</para></listitem>
		<listitem><para>Fehler zu verhindern</para></listitem>
		<listitem><para>Die genaue und höchsteffiziente Nutzung von Ressourcen</para></listitem>
	</itemizedlist>

	<para>
	Ein geclusterter Dateiserver hat also idealerweise folgende Eigenschaften:
	</para>

	<itemizedlist>
		<listitem><para>Alle Clients können sich transparent an jeden Server verbinden.</para></listitem>
		<listitem><para>Ein Server kann ausfallen, und die Clients werden transparent wieder auf einen anderen Server verbunden.</para></listitem>
		<listitem><para>Alle Server halten denselben Satz von Dateien bereit.</para></listitem>
		<listitem><para>Alle Dateiänderungen sind sofort auf allen Servern zu sehen.</para>
			<itemizedlist><listitem><para>Das setzt ein verteiltes Dateisystem voraus.</para></listitem></itemizedlist></listitem>
		<listitem><para>Grenzenlose Fähigkeit zu skalieren durch Hinzufügen zusätzlicher Server oder Festplatten.</para></listitem>
	</itemizedlist>

	</sect2>

	<sect2>
	<title>Warum ist dies so schwer?</title>

	<para>
	Kurz gesagt, das Problem ist eine Frage des <emphasis>Zustands</emphasis>.
	</para>

	<itemizedlist>
		<listitem>
			<para>
			Alle TCP/IP-Verbindungen sind von Zustandsinformationen abhängig.
			</para>
			<para>
			Die TCP/IP-Verbindung enthält eine Paket-Sequenznummer.
			Diese Sequenznummer muss auf allen Maschinen in einem
			Cluster dynamisch aktualisiert werden, um eine nahtlose TCP-Ausfallsicherheit zu erreichen.
			</para>
		</listitem>
		<listitem>
			<para>
			CIFS/SMB (die Windows-Netzwerkprotokolle) benutzen TCP-Verbindungen.
			</para>
			<para>
			Dies bedeutet aus einer grundlegenden Designperspektive, dass Ausfallsicherheit
			nicht wirklich in Erwägung gezogen wurde.
			<itemizedlist>
				<listitem><para>
				Alle aktuellen SMB-Cluster sind Ausfallsicherheitslösungen,
				sie basieren darauf, dass die Clients sich neu verbinden. Sie stellen Server-Ausfallsicherheit zur Verfügung, aber die Clients können Informationen aufgrund
				eines Serverausfalls verlieren.
				</para></listitem>
			</itemizedlist>
			</para>
		</listitem>
		<listitem>
			<para>
			Server halten Zustandsinformationen über die Client-Verbindungen fest.
			<itemizedlist>
				<listitem><para>CIFS/SMB ist in viele Zustände verwickelt.</para></listitem>
				<listitem><para>Jedes Öffnen einer Datei muss mit anderen Dateiöffnungen verglichen werden,
						um Freigabemodi zu überprüfen.</para></listitem>
			</itemizedlist>
			</para>
		</listitem>
	</itemizedlist>

		<sect3>
		<title>Die Frontend-Herausforderung</title>

		<para>
		Um es einem Cluster von Dateiservern zu ermöglichen, als ein einzelner Server mit einem Namen und
		einer IP-Adresse zu erscheinen, müssen die eingehenden TCP-Datenströme von den Arbeitsstationen durch
		einen virtuellen Frontend-Server verarbeitet werden. Dieser Server muss die eingehenden Pakete auf
		SMB-Protokoll-Layerebene de-multiplexen und dann das SMB-Paket an verschiedene Server im Cluster
		weiterreichen.
		</para>

		<para>
		Einer kann dann alle IPC$-Verbindungen und RPC-Calls auf einen Server aufsplitten, um Druckaufgaben
		und Benutzeranfragen abzuarbeiten. RPC-Druckaufgaben werden zwischen verschiedenen IPC4-Sitzungen 
		aufgeteilt, da es schwierig ist, diese über geclusterte Server aufzuteilen!
		</para>

		<para>
		Konzeptionell ausgedrückt: Alle anderen Server werden nur Dateidienste zur Verfügung 
		stellen. Sich darauf zu konzentrieren, ist ein einfacheres Problem.
		</para>

		</sect3>

		<sect3>
		<title>De-Multiplexen von SMB-Anfragen</title>

		<para>
		Das De-Multiplexen von SMB-Anfragen erfordert Wissen zu SMB-Zustandsinformationen.
		Alle müssen vom <emphasis>virtuellen</emphasis> Frontend-Server bereitgehalten werden.
		Dies ist ein verblüffendes und schwer zu lösendes Problem.
		</para>

		<para>
		Windows XP und spätere Versionen von MS Windows haben die Semantik geändert, so dass 
		Zustandsinformationen (vuid, tid, fid)
		für eine erfolgreiche Durchführung zueinander passen müssen. 
		Dies macht die Dinge einfacher als zuvor und ist ein positiver Schritt vorwärts.
		</para>

		<para>
		SMB-Anfragen werden durch vuid zu ihrem Bestimmungsserver gesendet. Es existiert zurzeit
		kein Code, um diese Lösung zu beeinflussen. Dieses Problem ähnelt im Grunde dem Problem, mehrere Anfragen an einen
		Windows 2000-Terminalserver in Samba zu bearbeiten.
		</para>

		<para>
		Eine Möglichkeit, um damit zu beginnen ist es, den Serverpool den Clients direkt auszusetzen.
		Dies könnte den Schritt des De-Multiplexing überflüssig machen.
		</para>

		</sect3>

		<sect3>
		<title>Die Herausforderung 'Verteiltes Dateisystem'</title>

		<para>
<indexterm><primary>Verteilte Dateisysteme</primary></indexterm>
		Es gibt viele verteilte Dateisysteme für UNIX und Linux.
		</para>

		<para>
		Viele können von uns übernommen werden, um unsere Cluster abzusichern, 
		solange wir immer die SMB-Semantik berücksichtigen (Freigabemodi, Sperren und Oplock-Themen im Speziellen).
		Allgemein übliche freie verteilte Dateisysteme enthalten:
<indexterm><primary>NFS</primary></indexterm>
<indexterm><primary>AFS</primary></indexterm>
<indexterm><primary>OpenGFS</primary></indexterm>
<indexterm><primary>Lustre</primary></indexterm>
		</para>

		<itemizedlist>
			<listitem><para>NFS</para></listitem>
			<listitem><para>AFS</para></listitem>
			<listitem><para>OpenGFS</para></listitem>
			<listitem><para>Lustre</para></listitem>
		</itemizedlist>

		<para>
		Der Serverpool (Cluster) kann jedes verteilte Dateisystem-Backend nutzen, wenn 
		die gesamte SMB-Semantik in diesem Pool durchgeführt wird.
		</para>

		</sect3>

		<sect3>
		<title>Restriktive Zwänge in verteilten Dateisystemen</title>

		<para>
		Wo ein geclusterter Server nur SMB-Dienste zur Verfügung stellt, kann das
		Verwalten von Oplocks direkt im Serverpool erfolgen, ohne den Zwang, diese Aufgabe an den
		dahinterliegenden Dateisystem-Pool weitergeben zu müssen. 
		</para>

		<para>
		Auf der anderen Seite wird es essenziell notwendig sein, dass die Implementierung 
		Oplock-fähig ist, so dass sie mit SMB-Diensten zusammenarbeiten kann, wenn der Serverpool
		auch NFS oder andere Dateidienste zur Verfügung stellt.
		Dies ist heutzutage eine bedeutende Herausforderung.
		Ein Fehler dabei hat einen bemerkenswerten Perfomanceverlust zur Folge, 
		den die Benutzer von Microsoft Windows-Clients deutlich spüren. 
		</para>

		<para>
		Zuletzt müssen alle Zustandsinformationen über den Serverpool verteilt werden.
		</para>

		</sect3>

		<sect3>
		<title>Serverpool-Kommunikation</title>

		<para>
		Die meisten Backend-Dateisysteme unterstützen die POSIX-Dateisemantik. 
		Dies macht es schwierig, die 
		SMB-Semantik zurück ins Dateisystem zu schieben. POSIX-Sperren haben andere Eigenschaften
		und eine andere Semantik als SMB-Sperren.
		</para>

		<para>
		Alle <command>smbd</command>-Prozesse im Serverpool müssen notwendigerweise sehr schnell
		miteinander kommunizieren.
		Dadurch ist die gegenwärtig von Samba verwendete <parameter>tdb</parameter>-Dateistruktur nicht geeignet für die Nutzung über Netzwerke.
		Geclusterte <command>smbd</command>s müssen eine andere Struktur verwenden.
		</para>

		</sect3>

		<sect3>
		<title>Anforderungen an die Serverpool-Kommunikation</title>

		<para>
		Die Hochgeschwindigkeits-Interserverkommunikation innerhalb des Serverpools ist eine
		Design-Grundvoraussetzung
		für ein voll funktionsfähiges System. Verfügbare Möglichkeiten sind unter anderem:
		</para>

		<itemizedlist>
			<listitem><para>
			Proprietäre Shared-Memory-Bussysteme (Beispiel: Myrinet oder SCI [Scalable Coherent Interface]).
			Diese sind äußerst kostenintensiv.
			</para></listitem>
		
			<listitem><para>
			Gigabit-Ethernet (mittlerweile ziemlich erschwinglich)
			</para></listitem>
		
			<listitem><para>
			Raw-Ethernet-Framing (um TCP- und UDP-Overheads zu umgehen)
			</para></listitem>
		</itemizedlist>

		<para>
		Wir müssen nun die Maße für Performance-Anforderungen festlegen, um dies effektiv
		einsetzen zu können.
		</para>

		</sect3>

		<sect3>
		<title>Benötigte Änderungen an Samba</title>

		<para>
		Samba muss entscheidend geändert werden, um mit einem Hochgeschwindigkeitsserver Inter-Connect-System
		zusammenzuarbeiten und transparente Ausfallsicherheits-Cluster zu erlauben.
		</para>

		<para>
		Zu den Funktionen innerhalb von Samba, die dadurch betroffen sind, zählen:
		</para>

		<itemizedlist>
			<listitem><para>
			Die Sperren-Datenbank, Oplock-Benachrichtigungen und die Freigabemodi-Datenbank
			</para></listitem>

			<listitem><para>
			Die Fehlersemantik muss definiert werden. Samba verhält sich so wie Windows.
			Wenn Oplock-Nachrichten fehlschlagen, ist eine Anforderung zum Öffnen einer Datei
			erlaubt, doch
			dies ist in einer geclusterten Umgebung potenziell gefährlich.
			Wie soll also Inter-Serverpool-Fehlersemantik funktionieren, und wie soll diese
			implementiert werden ?
			</para></listitem>

			<listitem><para>
			Soll dies durch Nutzung eines Point-to-Point-Sperren-Managers implementiert werden, oder
			kann dies durch Multicast-Techniken erreicht werden?
			</para></listitem>

		</itemizedlist>

		</sect3>
	</sect2>

	<sect2>
	<title>Eine einfache Lösung</title>

	<para>
	Indem man ausfallsicheren Servern erlaubt, verschiedene Funktionen innerhalb des exportierten Dateisystems
	zu verwalten, beseitigt man das Problem, ein verteiltes Sperrenprotokoll zu fordern.
	</para>

	<para>
	Falls nur ein Server in einem Paar aktiv ist, wird die Forderung nach Hochgeschwindigkeits-Server-Interconnect
	vermieden. Dies erlaubt dann das Nutzen von vorhandenen Hochverfügbarkeitslösungen, anstatt neue erfinden zu
	müssen. Diese einfachere Lösung hat jedoch ihren Preis: Man muss jetzt einen wesentlich komplexeren
	Dateinamensbereich verwalten.
	Dadurch, dass es nun nicht nur ein Dateisystem gibt, müssen sich die Administratoren daran erinnern,
	wo all die Dienste beheimatet sind: eine Komplexität, mit der nicht einfach 
	umzugehen ist.
	</para>

	<para>
	Der <emphasis>virtuelle Server</emphasis> wird weiterhin benötigt, um Anfragen an den Backend-Server 
	weiterzuleiten. Für die Integrität des Backend-Dateibereichs ist der Administrator verantwortlich.
	</para>

	</sect2>

	<sect2>
	<title>Hochverfügbarkeits-Serverprodukte</title>

	<para>
	Ausfallsichere Server müssen miteinander kommunizieren, um Ressourcenausfälle behandeln zu können.
	Dies ist für hochverfügbare Dienste lebensnotwendig. Der Einsatz eines dedizierten Heartbeats ist
	dabei eine gängige Technik, um etwas Intelligenz in den ausfallsichernden Prozess einzuführen.
	Dies wird oft durch einen dedizierten Link (LAN oder seriell) bewerkstelligt.
	</para>

	<para>
<indexterm><primary>SCSI</primary></indexterm>
	Viele Ausfallsicherungslösungen (der Red Hat Cluster Manager genauso wie Microsoft Wolfpack)
	können ein geteiltes SCSI von Fiberchannel Disk Storage Arrays für eine ausfallsichere Kommunikation nutzen.
	Informationen zu den Red Hat-Hochverfügbarkeitslösungen für Samba können Sie hier erhalten:
	<ulink url="http://www.redhat.com/docs/manuals/enterprise/RHEL-AS-2.1-Manual/cluster-manager/s1-service-samba.html">www.redhat.com.</ulink>
	</para>

	<para>
	Das Linux-Hochverfügbarkeitsprojekt ist eine lesenswerte Quelle, falls Sie beabsichtigen,
	eine hochverfügbare Dateiserver-Lösung mit Samba aufzubauen. Bitte konsultieren Sie die Homepage
	<ulink url="http://www.linux-ha.org">www.linux-ha.org.</ulink>
	</para>

	<para>
	Die Komplexität der Frontend-Server bleibt eine Herausforderung an die Hochverfügbarkeit, 
	weil diese anständig mit
	Backend-Fehlern umgehen müssen, während sie zur selben Zeit den Fortlauf der Dienste für alle Netzwerkclients
	zur Verfügung stellen müssen.
	</para>
	
	</sect2>

	<sect2>
	<title>MS-DFS: Der Arme-Leute-Cluster</title>

	<para>
<indexterm><primary>MS-DFS</primary></indexterm>
<indexterm><primary>DFS</primary><see>MS-DFS, Distributed File Systems (verteilte Dateisysteme)</see></indexterm>
	MS-DFS Links können dazu benutzt werden, Clients zu verschiedenen Backend-Servern 
	umzuleiten. Dies
	verlagert die Komplexität auf den Netzwerkclient zurück, etwas, das bereits von Microsoft vorgesehen wurde.
	MS-DFS erzeugt die Illusion eines einfachen und fortlaufenden Dateinamensbereichs,
	der sogar auf Dateiebene arbeitet.
	</para>

	<para>
	Darüber hinaus kann, auf Kosten der Komplexität der Verwaltung, ein verteilter (Pseudo-)Cluster durch
	Nutzung vorhandener Samba-Funktionalität erzeugt werden.
	</para>

	</sect2>

	<sect2>
	<title>Schlussfolgerungen</title>

	<itemizedlist>
		<listitem><para>Transparentes SMB-Clustering ist schwer durchzuführen!</para></listitem>
		<listitem><para>Client-Ausfallsicherung ist das Beste, was wir heutzutage machen können.</para></listitem>
		<listitem><para>Sehr viel mehr Arbeit muss erledigt werden, bevor eine praktikable und verwaltbare
				transparente Hochverfügbarkeits-Clusterlösung möglich sein wird.</para></listitem>
		<listitem><para>MS-DFS kann dazu benutzt werden, die Illusion eines einzelnen transparenten Clusters zu erzeugen.</para></listitem>
	</itemizedlist>

	</sect2>

</sect1>
</chapter>
